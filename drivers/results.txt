mfd/tps65010.c:55: * or digital cameras.
devfreq/exynos5430_bus_mif.c:914:struct devfreq_distriction_level distriction_hd_camera[] = {
devfreq/exynos5430_bus_mif.c:924:unsigned int timeout_hd_camera[][2] = {
devfreq/exynos5430_bus_mif.c:1003:struct devfreq_distriction_level distriction_fullhd_camera[] = {
devfreq/exynos5430_bus_mif.c:1013:unsigned int timeout_fullhd_camera[][2] = {
devfreq/exynos5430_bus_mif.c:1091:struct devfreq_distriction_level distriction_wqhd_camera[] = {
devfreq/exynos5430_bus_mif.c:1101:unsigned int timeout_wqhd_camera[][2] = {
devfreq/exynos5430_bus_mif.c:1189:		if (*mif_qos > distriction_hd_camera[total_layer_count].mif_level)
devfreq/exynos5430_bus_mif.c:1190:			*mif_qos = distriction_hd_camera[total_layer_count].mif_level;
devfreq/exynos5430_bus_mif.c:1191:		timeout_table = timeout_hd_camera;
devfreq/exynos5430_bus_mif.c:1228:		if (*mif_qos > distriction_fullhd_camera[total_layer_count].mif_level)
devfreq/exynos5430_bus_mif.c:1229:			*mif_qos = distriction_fullhd_camera[total_layer_count].mif_level;
devfreq/exynos5430_bus_mif.c:1230:		timeout_table = timeout_fullhd_camera;
devfreq/exynos5430_bus_mif.c:1263:		if (*mif_qos > distriction_wqhd_camera[total_layer_count + media_enabled_gscl_local].mif_level)
devfreq/exynos5430_bus_mif.c:1264:			*mif_qos = distriction_wqhd_camera[total_layer_count + media_enabled_gscl_local].mif_level;
devfreq/exynos5430_bus_mif.c:1265:		if (*disp_qos > distriction_wqhd_camera[total_layer_count].disp_level)
devfreq/exynos5430_bus_mif.c:1266:			*disp_qos = distriction_wqhd_camera[total_layer_count].disp_level;
devfreq/exynos5430_bus_mif.c:1267:		timeout_table = timeout_wqhd_camera;
devfreq/exynos5433_bus.c:2683:struct devfreq_distriction_level distriction_fullhd_camera[] = {
devfreq/exynos5433_bus.c:2693:unsigned int timeout_fullhd_camera[][2] = {
devfreq/exynos5433_bus.c:2775:struct devfreq_distriction_level distriction_wqhd_camera[] = {
devfreq/exynos5433_bus.c:2785:struct devfreq_distriction_level distriction_wqxga_camera[] = {
devfreq/exynos5433_bus.c:2795:unsigned int timeout_wqhd_camera[][2] = {
devfreq/exynos5433_bus.c:3349:			if (mif_qos > distriction_fullhd_camera[total_layer_count].mif_level)
devfreq/exynos5433_bus.c:3350:				mif_qos = distriction_fullhd_camera[total_layer_count].mif_level;
devfreq/exynos5433_bus.c:3351:			timeout_table = timeout_fullhd_camera;
devfreq/exynos5433_bus.c:3384:			if (mif_qos > distriction_wqhd_camera[total_layer_count].mif_level)
devfreq/exynos5433_bus.c:3385:				mif_qos = distriction_wqhd_camera[total_layer_count].mif_level;
devfreq/exynos5433_bus.c:3387:				if (int_qos > distriction_wqhd_camera[total_layer_count].int_level)
devfreq/exynos5433_bus.c:3388:					int_qos = distriction_wqhd_camera[total_layer_count].int_level;
devfreq/exynos5433_bus.c:3390:				if (int_qos > distriction_wqxga_camera[total_layer_count].int_level)
devfreq/exynos5433_bus.c:3391:					int_qos = distriction_wqxga_camera[total_layer_count].int_level;
devfreq/exynos5433_bus.c:3393:			if (disp_qos > distriction_wqhd_camera[total_layer_count].disp_level)
devfreq/exynos5433_bus.c:3394:				disp_qos = distriction_wqhd_camera[total_layer_count].disp_level;
devfreq/exynos5433_bus.c:3395:			timeout_table = timeout_wqhd_camera;
input/touchscreen/synaptics_dsx/synaptics_i2c_rmi.c:2746:	if (query.proximity_controls_2 & HAS_CAMERA_GRIP_DETECTION
input/keyboard/gpio_keys.c:99: *	SW_CAMERA_LENS_COVER = 9
char/sonypi.c:81:static int camera;		/* = 0 */
char/sonypi.c:82:module_param(camera, int, 0444);
char/sonypi.c:83:MODULE_PARM_DESC(camera,
char/sonypi.c:84:		 "set this if you have a MotionEye camera (PictureBook series)");
char/sonypi.c:205:#define SONYPI_CAMERA_BRIGHTNESS		0
char/sonypi.c:206:#define SONYPI_CAMERA_CONTRAST			1
char/sonypi.c:207:#define SONYPI_CAMERA_HUE			2
char/sonypi.c:208:#define SONYPI_CAMERA_COLOR			3
char/sonypi.c:209:#define SONYPI_CAMERA_SHARPNESS			4
char/sonypi.c:211:#define SONYPI_CAMERA_PICTURE			5
char/sonypi.c:212:#define SONYPI_CAMERA_EXPOSURE_MASK		0xC
char/sonypi.c:213:#define SONYPI_CAMERA_WHITE_BALANCE_MASK	0x3
char/sonypi.c:214:#define SONYPI_CAMERA_PICTURE_MODE_MASK		0x30
char/sonypi.c:215:#define SONYPI_CAMERA_MUTE_MASK			0x40
char/sonypi.c:218:#define SONYPI_CAMERA_AGC			6
char/sonypi.c:219:#define SONYPI_CAMERA_AGC_MASK			0x30
char/sonypi.c:220:#define SONYPI_CAMERA_SHUTTER_MASK 		0x7
char/sonypi.c:222:#define SONYPI_CAMERA_SHUTDOWN_REQUEST		7
char/sonypi.c:223:#define SONYPI_CAMERA_CONTROL			0x10
char/sonypi.c:225:#define SONYPI_CAMERA_STATUS 			7
char/sonypi.c:226:#define SONYPI_CAMERA_STATUS_READY 		0x2
char/sonypi.c:227:#define SONYPI_CAMERA_STATUS_POSITION		0x4
char/sonypi.c:231:#define SONYPI_CAMERA_REVISION 			8
char/sonypi.c:232:#define SONYPI_CAMERA_ROMVERSION 		9
char/sonypi.c:370:/* The set of possible motioneye camera events */
char/sonypi.c:439:	{ SONYPI_EVENT_CAPTURE_PRESSED,	 	KEY_CAMERA },
char/sonypi.c:486:	int camera_power;
char/sonypi.c:709:/* Tests if the camera is ready */
char/sonypi.c:710:static int sonypi_camera_ready(void)
char/sonypi.c:714:	v = sonypi_call2(0x8f, SONYPI_CAMERA_STATUS);
char/sonypi.c:715:	return (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));
char/sonypi.c:718:/* Turns the camera off */
char/sonypi.c:719:static void sonypi_camera_off(void)
char/sonypi.c:721:	sonypi_set(SONYPI_CAMERA_PICTURE, SONYPI_CAMERA_MUTE_MASK);
char/sonypi.c:723:	if (!sonypi_device.camera_power)
char/sonypi.c:727:	sonypi_device.camera_power = 0;
char/sonypi.c:730:/* Turns the camera on */
char/sonypi.c:731:static void sonypi_camera_on(void)
char/sonypi.c:735:	if (sonypi_device.camera_power)
char/sonypi.c:745:			if (sonypi_camera_ready())
char/sonypi.c:754:		printk(KERN_WARNING "sonypi: failed to power on camera\n");
char/sonypi.c:759:	sonypi_device.camera_power = 1;
char/sonypi.c:1085:static void sonypi_enable(unsigned int camera_on)
char/sonypi.c:1107:	if (camera && camera_on)
char/sonypi.c:1108:		sonypi_camera_on();
char/sonypi.c:1114:	if (camera)
char/sonypi.c:1115:		sonypi_camera_off();
char/sonypi.c:1288:	       "verbose = %d, fnkeyinit = %s, camera = %s, "
char/sonypi.c:1293:	       camera ? "on" : "off",
char/sonypi.c:1460:static int old_camera_power;
char/sonypi.c:1464:	old_camera_power = sonypi_device.camera_power;
char/sonypi.c:1472:	sonypi_enable(old_camera_power);
platform/x86/intel_oaktrail.c:64: * (1 << 0):	Camera enable/disable, RW.
platform/x86/intel_oaktrail.c:73:#define OT_EC_CAMERA_MASK	(1 << 0)
platform/x86/eeepc-wmi.c:75:	{ KE_KEY, 0x82, { KEY_CAMERA } },
platform/x86/eeepc-wmi.c:76:	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
platform/x86/eeepc-wmi.c:78:	{ KE_KEY, 0xbd, { KEY_CAMERA } },
platform/x86/eeepc-wmi.c:85:	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
platform/x86/eeepc-wmi.c:86:	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
platform/x86/eeepc-wmi.c:87:	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
platform/x86/eeepc-wmi.c:88:	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
platform/x86/eeepc-wmi.c:89:	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
platform/x86/classmate-laptop.c:1049:	KEY_CAMERA,
platform/x86/msi-wmi.c:57:	WIND_KEY_CAMERA,		/* Fn+F6 webcam toggle */
platform/x86/msi-wmi.c:72:	{ KE_IGNORE, WIND_KEY_CAMERA,		{KEY_CAMERA} },
platform/x86/ideapad-laptop.c:46:#define CFG_CAMERA_BIT	(19)
platform/x86/ideapad-laptop.c:62:	VPCCMD_R_CAMERA,
platform/x86/ideapad-laptop.c:63:	VPCCMD_W_CAMERA,
platform/x86/ideapad-laptop.c:230:	if (!read_ec_data(ideapad_handle, VPCCMD_R_CAMERA, &value))
platform/x86/ideapad-laptop.c:231:		seq_printf(s, "Camera status:\t%s(%lu)\n",
platform/x86/ideapad-laptop.c:263:		if (test_bit(CFG_CAMERA_BIT, &ideapad_priv->cfg))
platform/x86/ideapad-laptop.c:264:			seq_printf(s, "Camera ");
platform/x86/ideapad-laptop.c:346:	if (read_ec_data(ideapad_handle, VPCCMD_R_CAMERA, &result))
platform/x86/ideapad-laptop.c:361:	ret = write_ec_cmd(ideapad_handle, VPCCMD_W_CAMERA, state);
platform/x86/ideapad-laptop.c:367:static DEVICE_ATTR(camera_power, 0644, show_ideapad_cam, store_ideapad_cam);
platform/x86/ideapad-laptop.c:401:	&dev_attr_camera_power.attr,
platform/x86/ideapad-laptop.c:414:	if (attr == &dev_attr_camera_power.attr)
platform/x86/ideapad-laptop.c:415:		supported = test_bit(CFG_CAMERA_BIT, &(priv->cfg));
platform/x86/ideapad-laptop.c:559:	{ KE_KEY, 7,  { KEY_CAMERA } },
platform/x86/eeepc-laptop.c:72:	DISABLE_ASL_CAMERA = 0x0008,
platform/x86/eeepc-laptop.c:88:	CM_ASL_CAMERA,
platform/x86/eeepc-laptop.c:328:EEEPC_CREATE_DEVICE_ATTR(camera, 0644, CM_ASL_CAMERA);
platform/x86/eeepc-laptop.c:457:	&dev_attr_camera.attr,
platform/x86/eeepc-laptop.c:1410:static void eeepc_enable_camera(struct eeepc_laptop *eeepc)
platform/x86/eeepc-laptop.c:1414:	 * camera so we can ignore the error.
platform/x86/eeepc-laptop.c:1416:	if (get_acpi(eeepc, CM_ASL_CAMERA) == 0)
platform/x86/eeepc-laptop.c:1417:		set_acpi(eeepc, CM_ASL_CAMERA, 1);
platform/x86/eeepc-laptop.c:1444:	eeepc_enable_camera(eeepc);
platform/x86/asus-nb-wmi.c:235:	{ KE_KEY, 0x82, { KEY_CAMERA } },
platform/x86/asus-wmi.c:125:#define ASUS_WMI_DEVID_CAMERA		0x00060013
platform/x86/asus-wmi.c:1480:ASUS_WMI_CREATE_DEVICE_ATTR(camera, 0644, ASUS_WMI_DEVID_CAMERA);
platform/x86/asus-wmi.c:1505:	&dev_attr_camera.attr,
platform/x86/asus-wmi.c:1521:	if (attr == &dev_attr_camera.attr)
platform/x86/asus-wmi.c:1522:		devid = ASUS_WMI_DEVID_CAMERA;
platform/x86/sony-laptop.c:116:static int camera;		/* = 0 */
platform/x86/sony-laptop.c:117:module_param(camera, int, 0444);
platform/x86/sony-laptop.c:118:MODULE_PARM_DESC(camera,
platform/x86/sony-laptop.c:119:		 "set this to 1 to enable Motion Eye camera controls "
platform/x86/sony-laptop.c:291:	KEY_CAMERA,	/*  0 SONYPI_EVENT_CAPTURE_PRESSED */
platform/x86/sony-laptop.c:2968:	u8				camera_power;
platform/x86/sony-laptop.c:3120:/* The set of possible motioneye camera events */
platform/x86/sony-laptop.c:3343:/* camera tests and poweron/poweroff */
platform/x86/sony-laptop.c:3344:#define SONYPI_CAMERA_PICTURE		5
platform/x86/sony-laptop.c:3345:#define SONYPI_CAMERA_CONTROL		0x10
platform/x86/sony-laptop.c:3347:#define SONYPI_CAMERA_BRIGHTNESS		0
platform/x86/sony-laptop.c:3348:#define SONYPI_CAMERA_CONTRAST			1
platform/x86/sony-laptop.c:3349:#define SONYPI_CAMERA_HUE			2
platform/x86/sony-laptop.c:3350:#define SONYPI_CAMERA_COLOR			3
platform/x86/sony-laptop.c:3351:#define SONYPI_CAMERA_SHARPNESS			4
platform/x86/sony-laptop.c:3353:#define SONYPI_CAMERA_EXPOSURE_MASK		0xC
platform/x86/sony-laptop.c:3354:#define SONYPI_CAMERA_WHITE_BALANCE_MASK	0x3
platform/x86/sony-laptop.c:3355:#define SONYPI_CAMERA_PICTURE_MODE_MASK		0x30
platform/x86/sony-laptop.c:3356:#define SONYPI_CAMERA_MUTE_MASK			0x40
platform/x86/sony-laptop.c:3359:#define SONYPI_CAMERA_AGC			6
platform/x86/sony-laptop.c:3360:#define SONYPI_CAMERA_AGC_MASK			0x30
platform/x86/sony-laptop.c:3361:#define SONYPI_CAMERA_SHUTTER_MASK 		0x7
platform/x86/sony-laptop.c:3363:#define SONYPI_CAMERA_SHUTDOWN_REQUEST		7
platform/x86/sony-laptop.c:3364:#define SONYPI_CAMERA_CONTROL			0x10
platform/x86/sony-laptop.c:3366:#define SONYPI_CAMERA_STATUS 			7
platform/x86/sony-laptop.c:3367:#define SONYPI_CAMERA_STATUS_READY 		0x2
platform/x86/sony-laptop.c:3368:#define SONYPI_CAMERA_STATUS_POSITION		0x4
platform/x86/sony-laptop.c:3372:#define SONYPI_CAMERA_REVISION 			8
platform/x86/sony-laptop.c:3373:#define SONYPI_CAMERA_ROMVERSION 		9
platform/x86/sony-laptop.c:3375:static int __sony_pic_camera_ready(void)
platform/x86/sony-laptop.c:3379:	v = sony_pic_call2(0x8f, SONYPI_CAMERA_STATUS);
platform/x86/sony-laptop.c:3380:	return (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));
platform/x86/sony-laptop.c:3383:static int __sony_pic_camera_off(void)
platform/x86/sony-laptop.c:3385:	if (!camera) {
platform/x86/sony-laptop.c:3386:		pr_warn("camera control not enabled\n");
platform/x86/sony-laptop.c:3390:	wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE,
platform/x86/sony-laptop.c:3391:				SONYPI_CAMERA_MUTE_MASK),
platform/x86/sony-laptop.c:3394:	if (spic_dev.camera_power) {
platform/x86/sony-laptop.c:3396:		spic_dev.camera_power = 0;
platform/x86/sony-laptop.c:3401:static int __sony_pic_camera_on(void)
platform/x86/sony-laptop.c:3405:	if (!camera) {
platform/x86/sony-laptop.c:3406:		pr_warn("camera control not enabled\n");
platform/x86/sony-laptop.c:3410:	if (spic_dev.camera_power)
platform/x86/sony-laptop.c:3420:			if (__sony_pic_camera_ready())
platform/x86/sony-laptop.c:3429:		pr_warn("failed to power on camera\n");
platform/x86/sony-laptop.c:3433:	wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTROL,
platform/x86/sony-laptop.c:3437:	spic_dev.camera_power = 1;
platform/x86/sony-laptop.c:3441:/* External camera command (exported to the motion eye v4l driver) */
platform/x86/sony-laptop.c:3442:int sony_pic_camera_command(int command, u8 value)
platform/x86/sony-laptop.c:3444:	if (!camera)
platform/x86/sony-laptop.c:3450:	case SONY_PIC_COMMAND_SETCAMERA:
platform/x86/sony-laptop.c:3452:			__sony_pic_camera_on();
platform/x86/sony-laptop.c:3454:			__sony_pic_camera_off();
platform/x86/sony-laptop.c:3456:	case SONY_PIC_COMMAND_SETCAMERABRIGHTNESS:
platform/x86/sony-laptop.c:3457:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_BRIGHTNESS, value),
platform/x86/sony-laptop.c:3460:	case SONY_PIC_COMMAND_SETCAMERACONTRAST:
platform/x86/sony-laptop.c:3461:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTRAST, value),
platform/x86/sony-laptop.c:3464:	case SONY_PIC_COMMAND_SETCAMERAHUE:
platform/x86/sony-laptop.c:3465:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_HUE, value),
platform/x86/sony-laptop.c:3468:	case SONY_PIC_COMMAND_SETCAMERACOLOR:
platform/x86/sony-laptop.c:3469:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_COLOR, value),
platform/x86/sony-laptop.c:3472:	case SONY_PIC_COMMAND_SETCAMERASHARPNESS:
platform/x86/sony-laptop.c:3473:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_SHARPNESS, value),
platform/x86/sony-laptop.c:3476:	case SONY_PIC_COMMAND_SETCAMERAPICTURE:
platform/x86/sony-laptop.c:3477:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE, value),
platform/x86/sony-laptop.c:3480:	case SONY_PIC_COMMAND_SETCAMERAAGC:
platform/x86/sony-laptop.c:3481:		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_AGC, value),
platform/x86/sony-laptop.c:3485:		pr_err("sony_pic_camera_command invalid: %d\n", command);
platform/x86/sony-laptop.c:3491:EXPORT_SYMBOL(sony_pic_camera_command);
platform/x86/thinkpad_acpi.c:3140:		KEY_WLAN,	KEY_CAMERA, KEY_SWITCHVIDEOMODE, KEY_FN_F8,
platform/x86/asus-laptop.c:341:	{KE_KEY, 0x82, { KEY_CAMERA } },
clk/mvebu/clk-gating-ctrl.c:173:	{ "camera", NULL, 11 },
clk/tegra/clk-tegra30.c:1449:	TEGRA_INIT_DATA_INT("vi",	"vi",		"tegra_camera",		mux_pllmcpa,		CLK_SOURCE_VI,		20,	&periph_l_regs, 0, vi),
clk/tegra/clk-tegra30.c:1467:	TEGRA_INIT_DATA_MUX("vi_sensor", "vi_sensor",	"tegra_camera",		mux_pllmcpa,		CLK_SOURCE_VI_SENSOR,	20,	&periph_l_regs, TEGRA_PERIPH_NO_RESET, vi_sensor),
clk/tegra/clk-tegra30.c:1530:	clk_register_clkdev(clk, "csus", "tengra_camera");
clk/tegra/clk-tegra30.c:1580:	clk_register_clkdev(clk, "csi", "tegra_camera");
clk/tegra/clk-tegra30.c:1586:	clk_register_clkdev(clk, "isp", "tegra_camera");
clk/tegra/clk-tegra20.c:836:	TEGRA_INIT_DATA_MUX("vi",	"vi",		"tegra_camera",	 mux_pllmcpa,	    CLK_SOURCE_VI,	  20,	&periph_l_regs, 0, vi),
clk/tegra/clk-tegra20.c:850:	TEGRA_INIT_DATA_MUX("vi_sensor", "vi_sensor",	"tegra_camera",	 mux_pllmcpa,	    CLK_SOURCE_VI_SENSOR, 20,	&periph_l_regs, TEGRA_PERIPH_NO_RESET, vi_sensor),
clk/tegra/clk-tegra20.c:918:	clk_register_clkdev(clk, "csus", "tengra_camera");
clk/tegra/clk-tegra20.c:980:	clk_register_clkdev(clk, "csi", "tegra_camera");
clk/tegra/clk-tegra20.c:986:	clk_register_clkdev(clk, "isp", "tegra_camera");
clk/tegra/clk-tegra114.c:1747:	TEGRA_INIT_DATA_MUX("vi_sensor", "vi_sensor", "tegra_camera", mux_pllm_pllc2_c_c3_pllp_plla, CLK_SOURCE_VI_SENSOR, 20, &periph_l_regs, TEGRA_PERIPH_NO_RESET, vi_sensor),
clk/tegra/clk-tegra114.c:1748:	TEGRA_INIT_DATA_INT8("vi", "vi", "tegra_camera", mux_pllm_pllc2_c_c3_pllp_plla, CLK_SOURCE_VI, 20, &periph_l_regs, 0, vi),
clk/tegra/clk-tegra114.c:1754:	TEGRA_INIT_DATA_MUX("cilab", "cilab", "tegra_camera", mux_pllp_pllc_clkm, CLK_SOURCE_CILAB, 144, &periph_w_regs, 0, cilab),
clk/tegra/clk-tegra114.c:1755:	TEGRA_INIT_DATA_MUX("cilcd", "cilcd", "tegra_camera", mux_pllp_pllc_clkm, CLK_SOURCE_CILCD, 145, &periph_w_regs, 0, cilcd),
clk/tegra/clk-tegra114.c:1756:	TEGRA_INIT_DATA_MUX("cile", "cile", "tegra_camera", mux_pllp_pllc_clkm, CLK_SOURCE_CILE, 146, &periph_w_regs, 0, cile),
clk/samsung/clk-exynos7420_evt0.c:2873:	/* camera block sysmmus */
hid/hid-gyration.c:43:	case 0x049: gy_map_key_clear(KEY_CAMERA);	break;
hid/hid-lg.c:506:	case 0x1013: lg_map_key_clear(KEY_CAMERA);		break;
hid/hid-debug.c:763:	[KEY_CAMERA] = "Camera",		[KEY_SOUND] = "Sound",
hid/hid-chicony.c:52:	case 0x00f7: ch_map_key_clear(KEY_CAMERA);	break;
hid/hid-belkin.c:41:	case 0x03b: belkin_map_key_clear(KEY_CAMERA);		break;
hid/hid-input.c:722:		case 0x065: map_key_clear(KEY_CAMERA);		break; /* Snapshot */
hid/hid-input.c:875:		case 0x071: map_key_clear(KEY_CAMERA);		break;
hid/hid-topseed.c:46:	case 0x049: ts_map_key_clear(KEY_CAMERA);	break;
media/i2c/smiapp-pll.c:4: * Generic driver for SMIA/SMIA++ compliant camera modules
media/i2c/s5c73m3/s5c73m3-core.c:2: * Samsung LSI S5C73M3 8M pixel camera driver
media/i2c/s5c73m3/s5c73m3-core.c:1713:MODULE_DESCRIPTION("Samsung S5C73M3 camera driver");
media/i2c/s5c73m3/s5c73m3-spi.c:2: * Samsung LSI S5C73M3 8M pixel camera driver
media/i2c/s5c73m3/s5c73m3-ctrls.c:2: * Samsung LSI S5C73M3 8M pixel camera driver
media/i2c/s5k4ecgx.c:1032:MODULE_DESCRIPTION("Samsung S5K4ECGX 5MP SOC camera");
media/i2c/mt9t001.c:379:#define V4L2_CID_GAIN_RED		(V4L2_CTRL_CLASS_CAMERA | 0x1001)
media/i2c/mt9t001.c:380:#define V4L2_CID_GAIN_GREEN_RED		(V4L2_CTRL_CLASS_CAMERA | 0x1002)
media/i2c/mt9t001.c:381:#define V4L2_CID_GAIN_GREEN_BLUE	(V4L2_CTRL_CLASS_CAMERA | 0x1003)
media/i2c/mt9t001.c:382:#define V4L2_CID_GAIN_BLUE		(V4L2_CTRL_CLASS_CAMERA | 0x1004)
media/i2c/mt9t001.c:839:MODULE_DESCRIPTION("Aptina (Micron) MT9T001 Camera driver");
media/i2c/soc_camera/mt9m111.c:19:#include <media/soc_camera.h>
media/i2c/soc_camera/mt9m111.c:28: * from struct soc_camera_host_desc
media/i2c/soc_camera/mt9m111.c:128: * Camera control register addresses (0x200..0x2ff not implemented)
media/i2c/soc_camera/mt9m111.c:406:	soc_camera_limit_side(&rect.left, &rect.width,
media/i2c/soc_camera/mt9m111.c:409:	soc_camera_limit_side(&rect.top, &rect.height,
media/i2c/soc_camera/mt9m111.c:801:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m111.c:804:	ret = soc_camera_power_on(&client->dev, ssdd);
media/i2c/soc_camera/mt9m111.c:811:		soc_camera_power_off(&client->dev, ssdd);
media/i2c/soc_camera/mt9m111.c:820:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m111.c:823:	soc_camera_power_off(&client->dev, ssdd);
media/i2c/soc_camera/mt9m111.c:881:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m111.c:887:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/mt9m111.c:958:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m111.c:1039:MODULE_DESCRIPTION("Micron/Aptina MT9M111/MT9M112/MT9M131 Camera driver");
media/i2c/soc_camera/imx074.c:20:#include <media/soc_camera.h>
media/i2c/soc_camera/imx074.c:274:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/imx074.c:276:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/imx074.c:433:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/imx074.c:459:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/imx074.c:484:MODULE_DESCRIPTION("Sony IMX074 Camera driver");
media/i2c/soc_camera/ov772x.c:2: * ov772x Camera Driver
media/i2c/soc_camera/ov772x.c:7: * Based on ov7670 and soc_camera_platform driver,
media/i2c/soc_camera/ov772x.c:28:#include <media/soc_camera.h>
media/i2c/soc_camera/ov772x.c:399:	struct ov772x_camera_info        *info;
media/i2c/soc_camera/ov772x.c:556: * soc_camera_ops function
media/i2c/soc_camera/ov772x.c:670:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov772x.c:672:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/ov772x.c:1022:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov772x.c:1028:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/ov772x.c:1057:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov772x.c:1127:MODULE_DESCRIPTION("SoC Camera driver for ov772x");
media/i2c/soc_camera/ov9640.c:2: * OmniVision OV96xx Camera Driver
media/i2c/soc_camera/ov9640.c:6: * Based on ov772x camera driver:
media/i2c/soc_camera/ov9640.c:11: * Based on ov7670 and soc_camera_platform driver,
media/i2c/soc_camera/ov9640.c:30:#include <media/soc_camera.h>
media/i2c/soc_camera/ov9640.c:250:/* Soft reset the camera. This has nothing to do with the RESET pin! */
media/i2c/soc_camera/ov9640.c:269:/* Set status of additional camera capabilities */
media/i2c/soc_camera/ov9640.c:339:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov9640.c:341:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/ov9640.c:655:/* Request bus settings on camera side */
media/i2c/soc_camera/ov9640.c:660:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov9640.c:666:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/ov9640.c:693:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov9640.c:754:MODULE_DESCRIPTION("SoC Camera driver for OmniVision OV96xx");
media/i2c/soc_camera/rj54n1cb0c.c:19:#include <media/soc_camera.h>
media/i2c/soc_camera/rj54n1cb0c.c:99: * When cropping, the camera automatically centers the cropped region, there
media/i2c/soc_camera/rj54n1cb0c.c:549:	soc_camera_limit_side(&dummy, &input_w,
media/i2c/soc_camera/rj54n1cb0c.c:552:	soc_camera_limit_side(&dummy, &input_h,
media/i2c/soc_camera/rj54n1cb0c.c:617: * coefficient on success. Note: we only use the "Fixed Scaling" on this camera.
media/i2c/soc_camera/rj54n1cb0c.c:722:	 * that are required for a specific resize, and the camera selects
media/i2c/soc_camera/rj54n1cb0c.c:725:	 * bits and let the camera choose? Would it increase processing time and
media/i2c/soc_camera/rj54n1cb0c.c:1186:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/rj54n1cb0c.c:1188:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/rj54n1cb0c.c:1248:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/rj54n1cb0c.c:1255:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/rj54n1cb0c.c:1264:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/rj54n1cb0c.c:1267:	if (soc_camera_apply_board_flags(ssdd, cfg) &
media/i2c/soc_camera/rj54n1cb0c.c:1337:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/rj54n1cb0c.c:1395:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/rj54n1cb0c.c:1422:MODULE_DESCRIPTION("Sharp RJ54N1CB0C Camera driver");
media/i2c/soc_camera/ov9740.c:2: * OmniVision OV9740 Camera Driver
media/i2c/soc_camera/ov9740.c:6: * Based on ov9640 camera driver.
media/i2c/soc_camera/ov9740.c:19:#include <media/soc_camera.h>
media/i2c/soc_camera/ov9740.c:755:/* Set status of additional camera capabilities */
media/i2c/soc_camera/ov9740.c:790:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov9740.c:795:		ret = soc_camera_power_on(&client->dev, ssdd);
media/i2c/soc_camera/ov9740.c:809:		soc_camera_power_off(&client->dev, ssdd);
media/i2c/soc_camera/ov9740.c:903:/* Request bus settings on camera side */
media/i2c/soc_camera/ov9740.c:908:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov9740.c:914:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/ov9740.c:954:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov9740.c:1011:MODULE_DESCRIPTION("SoC Camera driver for OmniVision OV9740");
media/i2c/soc_camera/ov2640.c:2: * ov2640 Camera Driver
media/i2c/soc_camera/ov2640.c:24:#include <media/soc_camera.h>
media/i2c/soc_camera/ov2640.c:695: * soc_camera_ops functions
media/i2c/soc_camera/ov2640.c:774:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov2640.c:776:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/ov2640.c:1049:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov2640.c:1055:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/ov2640.c:1083:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov2640.c:1151:MODULE_DESCRIPTION("SoC Camera driver for Omni Vision 2640 sensor");
media/i2c/soc_camera/mt9t112.c:2: * mt9t112 Camera Driver
media/i2c/soc_camera/mt9t112.c:29:#include <media/soc_camera.h>
media/i2c/soc_camera/mt9t112.c:90:	struct mt9t112_camera_info	*info;
media/i2c/soc_camera/mt9t112.c:348:	soc_camera_limit_side(left, width, 0, 0, MAX_WIDTH);
media/i2c/soc_camera/mt9t112.c:349:	soc_camera_limit_side(top, height, 0, 0, MAX_HEIGHT);
media/i2c/soc_camera/mt9t112.c:693:static int mt9t112_init_camera(const struct i2c_client *client)
media/i2c/soc_camera/mt9t112.c:783:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t112.c:785:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/mt9t112.c:812:		 * mt9t112 camera will be very warm.
media/i2c/soc_camera/mt9t112.c:814:		 * But current driver can not stop mt9t112 camera.
media/i2c/soc_camera/mt9t112.c:824:		ECHECKER(ret, mt9t112_init_camera(client));
media/i2c/soc_camera/mt9t112.c:1000:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t112.c:1006:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/mt9t112.c:1015:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t112.c:1018:	if (soc_camera_apply_board_flags(ssdd, cfg) & V4L2_MBUS_PCLK_SAMPLE_RISING)
media/i2c/soc_camera/mt9t112.c:1045:static int mt9t112_camera_probe(struct i2c_client *client)
media/i2c/soc_camera/mt9t112.c:1089:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t112.c:1111:	ret = mt9t112_camera_probe(client);
media/i2c/soc_camera/mt9t112.c:1143:MODULE_DESCRIPTION("SoC Camera driver for mt9t112");
media/i2c/soc_camera/mt9v022.c:19:#include <media/soc_camera.h>
media/i2c/soc_camera/mt9v022.c:28: * from struct soc_camera_host_desc
media/i2c/soc_camera/mt9v022.c:288:	soc_camera_limit_side(&rect.left, &rect.width,
media/i2c/soc_camera/mt9v022.c:291:	soc_camera_limit_side(&rect.top, &rect.height,
media/i2c/soc_camera/mt9v022.c:421:	/* No support for scaling on this camera, just crop. */
media/i2c/soc_camera/mt9v022.c:520:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9v022.c:522:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/mt9v022.c:667:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9v022.c:748:		dev_err(&client->dev, "Failed to initialise the camera\n");
media/i2c/soc_camera/mt9v022.c:796:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9v022.c:804:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/mt9v022.c:813:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9v022.c:815:	unsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/mt9v022.c:885:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9v022.c:970:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9v022.c:996:MODULE_DESCRIPTION("Micron MT9V022 Camera driver");
media/i2c/soc_camera/ov6650.c:2: * V4L2 SoC Camera driver for OmniVision OV6650 Camera Sensor
media/i2c/soc_camera/ov6650.c:6: * Based on OmniVision OV96xx Camera Driver
media/i2c/soc_camera/ov6650.c:9: * Based on ov772x camera driver:
media/i2c/soc_camera/ov6650.c:13: * Based on ov7670 and soc_camera_platform driver,
media/i2c/soc_camera/ov6650.c:34:#include <media/soc_camera.h>
media/i2c/soc_camera/ov6650.c:307:/* Get status of additional camera capabilities */
media/i2c/soc_camera/ov6650.c:340:/* Set status of additional camera capabilities */
media/i2c/soc_camera/ov6650.c:438:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov6650.c:440:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/ov6650.c:468:	soc_camera_limit_side(&rect.left, &rect.width,
media/i2c/soc_camera/ov6650.c:470:	soc_camera_limit_side(&rect.top, &rect.height,
media/i2c/soc_camera/ov6650.c:551:	struct soc_camera_device *icd = v4l2_get_subdev_hostdata(sd);
media/i2c/soc_camera/ov6650.c:552:	struct soc_camera_sense *sense = icd->sense;
media/i2c/soc_camera/ov6650.c:801:/* Soft reset the camera. This has nothing to do with the RESET pin! */
media/i2c/soc_camera/ov6650.c:890:/* Request bus settings on camera side */
media/i2c/soc_camera/ov6650.c:895:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov6650.c:903:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/ov6650.c:908:/* Alter bus settings on camera side */
media/i2c/soc_camera/ov6650.c:913:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov6650.c:914:	unsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/ov6650.c:966:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov6650.c:1061:MODULE_DESCRIPTION("SoC Camera driver for OmniVision OV6650");
media/i2c/soc_camera/mt9m001.c:17:#include <media/soc_camera.h>
media/i2c/soc_camera/mt9m001.c:26: * from struct soc_camera_host_desc
media/i2c/soc_camera/mt9m001.c:193:	soc_camera_limit_side(&rect.left, &rect.width,
media/i2c/soc_camera/mt9m001.c:196:	soc_camera_limit_side(&rect.top, &rect.height,
media/i2c/soc_camera/mt9m001.c:383:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m001.c:385:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/mt9m001.c:485:static int mt9m001_video_probe(struct soc_camera_subdev_desc *ssdd,
media/i2c/soc_camera/mt9m001.c:549:		dev_err(&client->dev, "Failed to initialise the camera\n");
media/i2c/soc_camera/mt9m001.c:561:static void mt9m001_video_remove(struct soc_camera_subdev_desc *ssdd)
media/i2c/soc_camera/mt9m001.c:608:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m001.c:615:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/mt9m001.c:624:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m001.c:666:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m001.c:723:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9m001.c:749:MODULE_DESCRIPTION("Micron MT9M001 Camera driver");
media/i2c/soc_camera/mt9t031.c:20:#include <media/soc_camera.h>
media/i2c/soc_camera/mt9t031.c:26: * ATTENTION: this driver still cannot be used outside of the soc-camera
media/i2c/soc_camera/mt9t031.c:35: * from struct soc_camera_host_desc
media/i2c/soc_camera/mt9t031.c:267:	 * .try_mbus_fmt(), soc_camera_s_crop() and soc_camera_cropcap()
media/i2c/soc_camera/mt9t031.c:306:	soc_camera_limit_side(&rect.left, &rect.width,
media/i2c/soc_camera/mt9t031.c:309:	soc_camera_limit_side(&rect.top, &rect.height,
media/i2c/soc_camera/mt9t031.c:575:	struct v4l2_subdev *sd = soc_camera_vdev_to_subdev(vdev);
media/i2c/soc_camera/mt9t031.c:611:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t031.c:612:	struct video_device *vdev = soc_camera_i2c_to_vdev(client);
media/i2c/soc_camera/mt9t031.c:616:		ret = soc_camera_power_on(&client->dev, ssdd);
media/i2c/soc_camera/mt9t031.c:622:		soc_camera_power_off(&client->dev, ssdd);
media/i2c/soc_camera/mt9t031.c:644:		dev_err(&client->dev, "Failed to initialise the camera\n");
media/i2c/soc_camera/mt9t031.c:710:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t031.c:716:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/mt9t031.c:725:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t031.c:727:	if (soc_camera_apply_board_flags(ssdd, cfg) &
media/i2c/soc_camera/mt9t031.c:761:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/mt9t031.c:849:MODULE_DESCRIPTION("Micron MT9T031 Camera driver");
media/i2c/soc_camera/ov5642.c:6: * Based on Sony IMX074 Camera Driver
media/i2c/soc_camera/ov5642.c:9: * Based on Omnivision OV7670 Camera Driver
media/i2c/soc_camera/ov5642.c:26:#include <media/soc_camera.h>
media/i2c/soc_camera/ov5642.c:937:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov5642.c:941:		return soc_camera_power_off(&client->dev, ssdd);
media/i2c/soc_camera/ov5642.c:943:	ret = soc_camera_power_on(&client->dev, ssdd);
media/i2c/soc_camera/ov5642.c:1023:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov5642.c:1050:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/ov5642.c:1075:MODULE_DESCRIPTION("Omnivision OV5642 Camera driver");
media/i2c/soc_camera/tw9910.c:28:#include <media/soc_camera.h>
media/i2c/soc_camera/tw9910.c:572:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/tw9910.c:574:	return soc_camera_set_power(&client->dev, ssdd, on);
media/i2c/soc_camera/tw9910.c:850:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/tw9910.c:857:	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/tw9910.c:866:	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/tw9910.c:868:	unsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);
media/i2c/soc_camera/tw9910.c:914:	struct soc_camera_subdev_desc	*ssdd = soc_camera_i2c_to_desc(client);
media/i2c/soc_camera/tw9910.c:963:MODULE_DESCRIPTION("SoC Camera driver for tw9910");
media/i2c/m5mols/m5mols_controls.c:2: * Controls for M-5MOLS 8M Pixel camera sensor with ISP
media/i2c/m5mols/m5mols_core.c:2: * Driver for M-5MOLS 8M Pixel camera sensor with ISP
media/i2c/m5mols/m5mols_core.c:1056:MODULE_DESCRIPTION("Fujitsu M-5MOLS 8M Pixel camera driver");
media/i2c/mt9v032.c:867:MODULE_DESCRIPTION("Aptina MT9V032 Camera driver");
media/i2c/mt9p031.c:329:		dev_err(&client->dev, "Failed to reset the camera\n");
media/i2c/mt9p031.c:1084:MODULE_DESCRIPTION("Aptina MT9P031 Camera driver");
media/i2c/tcm825x.c:4: * TCM825X camera sensor driver.
media/i2c/tcm825x.c:936:MODULE_DESCRIPTION("TCM825x camera sensor driver");
media/i2c/mt9m032.c:899:MODULE_DESCRIPTION("MT9M032 camera sensor driver");
media/i2c/s5k6aa.c:1322:#define V4L2_CID_RED_GAIN	(V4L2_CTRL_CLASS_CAMERA | 0x1001)
media/i2c/s5k6aa.c:1323:#define V4L2_CID_GREEN_GAIN	(V4L2_CTRL_CLASS_CAMERA | 0x1002)
media/i2c/s5k6aa.c:1324:#define V4L2_CID_BLUE_GAIN	(V4L2_CTRL_CLASS_CAMERA | 0x1003)
media/i2c/s5k6aa.c:1659:MODULE_DESCRIPTION("Samsung S5K6AA(FX) SXGA camera driver");
media/i2c/ov7670.c:2: * A V4L2 driver for OmniVision OV7670 cameras.
media/i2c/ov7670.c:204:	int	hstart;		/* Start/stop values for the camera.  Note */
media/i2c/ov7670.c:884: * Store a set of start/stop values into the camera.
media/i2c/noon010pc30.c:842:MODULE_DESCRIPTION("Siliconfile NOON010PC30 camera driver");
media/i2c/smiapp/smiapp-limits.c:4: * Generic driver for SMIA/SMIA++ compliant camera modules
media/i2c/smiapp/smiapp-regs.c:4: * Generic driver for SMIA/SMIA++ compliant camera modules
media/i2c/smiapp/smiapp-core.c:4: * Generic driver for SMIA/SMIA++ compliant camera modules
media/i2c/smiapp/smiapp-core.c:47: * smiapp_module_idents - supported camera modules
media/i2c/smiapp/smiapp-core.c:2891:MODULE_DESCRIPTION("Generic SMIA/SMIA++ camera module driver");
media/i2c/smiapp/smiapp-quirk.c:4: * Generic driver for SMIA/SMIA++ compliant camera modules
media/i2c/sr030pc30.c:869:MODULE_DESCRIPTION("Siliconfile SR030PC30 camera driver");
media/platform/omap24xxcam.c:4: * OMAP 2 camera block driver.
media/platform/omap24xxcam.c:87:		dev_err(cam->dev, "can't get camera fck");
media/platform/omap24xxcam.c:95:		dev_err(cam->dev, "can't get camera ick");
media/platform/omap24xxcam.c:117: * Camera core
media/platform/omap24xxcam.c:147:	 * Setting the camera core AUTOIDLE bit causes problems with frame
media/platform/omap24xxcam.c:153:	/* program the camera interface DMA packet size */
media/platform/omap24xxcam.c:157:	/* enable camera core error interrupts */
media/platform/omap24xxcam.c:166: * Enable the camera core.
media/platform/omap24xxcam.c:168: * Data transfer to the camera DMA starts from next starting frame.
media/platform/omap24xxcam.c:178: * Disable camera core.
media/platform/omap24xxcam.c:191:/* Interrupt service routine for camera core interrupts. */
media/platform/omap24xxcam.c:209:		dev_dbg(cam->dev, "resetting camera, cc_irqstatus 0x%x\n",
media/platform/omap24xxcam.c:410:			dev_dbg(cam->dev, "resetting camera, csr 0x%x\n", csr);
media/platform/omap24xxcam.c:594: * OMAP main camera system
media/platform/omap24xxcam.c:599: * Reset camera block to power-on state.
media/platform/omap24xxcam.c:605:	/* Reset whole camera subsystem */
media/platform/omap24xxcam.c:619:		dev_err(cam->dev, "camera soft reset timeout\n");
media/platform/omap24xxcam.c:623: * (Re)initialise the camera block.
media/platform/omap24xxcam.c:629:	/* set the camera subsystem autoidle bit */
media/platform/omap24xxcam.c:633:	/* set the camera MMU autoidle bit */
media/platform/omap24xxcam.c:651:		dev_dbg(cam->dev, "dma stalled, resetting camera\n");
media/platform/omap24xxcam.c:688: * Note: Resetting the camera FIFO via the CC_RST bit in the CC_CTRL
media/platform/omap24xxcam.c:689: * register is supposed to be sufficient to recover from a camera
media/platform/omap24xxcam.c:693: * entire camera subsystem prevents the problem with frame
media/platform/omap24xxcam.c:730: * Stop capture and restart it. I.e. reset the camera during use.
media/platform/omap24xxcam.c:760:		dev_err(cam->dev, "unhandled camera MMU interrupt!\n");
media/platform/omap24xxcam.c:934: * Power-up and configure camera sensor. It's ready for capturing now.
media/platform/omap24xxcam.c:1222:	strlcpy(inp->name, "camera", sizeof(inp->name));
media/platform/omap24xxcam.c:1223:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/omap24xxcam.c:1628: * Camera device (i.e. /dev/video).
media/platform/omap24xxcam.c:1764:	/* request the mem region for the camera registers */
media/platform/omap24xxcam.c:1772:			"cannot reserve camera register I/O region\n");
media/platform/omap24xxcam.c:1781:		dev_err(cam->dev, "cannot map camera register I/O region\n");
media/platform/omap24xxcam.c:1787:		dev_err(cam->dev, "no irq for camera?\n");
media/platform/omap24xxcam.c:1873:MODULE_DESCRIPTION("OMAP24xx Video for Linux camera driver");
media/platform/omap3isp/isp.c:124:		       1 << OMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL,
media/platform/omap3isp/isp.c:576: * isp_isr - Interrupt Service Routine for Camera ISP module.
media/platform/omap3isp/isp.c:2111:	/* request the mem region for the camera registers */
media/platform/omap3isp/isp.c:2122:			"cannot reserve camera register I/O region\n");
media/platform/omap3isp/isp.c:2133:		dev_err(isp->dev, "cannot map camera register I/O region\n");
media/platform/omap3isp/ispcsiphy.c:40:		phy->isp, OMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL, 0);
media/platform/omap3isp/ispcsiphy.c:47:		reg &= ~OMAP3630_CONTROL_CAMERA_PHY_CTRL_CSI1_RX_SEL_PHY2;
media/platform/omap3isp/ispcsiphy.c:48:		shift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY1_SHIFT;
media/platform/omap3isp/ispcsiphy.c:51:		shift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY1_SHIFT;
media/platform/omap3isp/ispcsiphy.c:52:		mode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_DPHY;
media/platform/omap3isp/ispcsiphy.c:55:		reg |= OMAP3630_CONTROL_CAMERA_PHY_CTRL_CSI1_RX_SEL_PHY2;
media/platform/omap3isp/ispcsiphy.c:56:		shift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY2_SHIFT;
media/platform/omap3isp/ispcsiphy.c:59:		shift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY2_SHIFT;
media/platform/omap3isp/ispcsiphy.c:60:		mode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_DPHY;
media/platform/omap3isp/ispcsiphy.c:68:			mode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_CCP2_DATA_STROBE;
media/platform/omap3isp/ispcsiphy.c:70:			mode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_CCP2_DATA_CLOCK;
media/platform/omap3isp/ispcsiphy.c:73:	reg &= ~(OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_MASK << shift);
media/platform/omap3isp/ispcsiphy.c:77:		       OMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL, 0);
media/platform/omap3isp/ispcsiphy.c:119:	if (phy->isp->mmio_base[OMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL]
media/platform/omap3isp/ispvideo.c:1181:	strlcpy(input->name, "camera", sizeof(input->name));
media/platform/omap3isp/ispvideo.c:1182:	input->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/omap3isp/ispcsi2.c:1179:		/* Link from camera to CSI2 is fixed... */
media/platform/omap/omap_vout.c:10: * Leveraged code from the OMAP2 camera driver
media/platform/omap/omap_vout.c:11: * Video-for-Linux (Version 2) camera capture driver for
media/platform/omap/omap_vout.c:12: * the OMAP24xx camera controller.
media/platform/omap/omap_voutlib.c:10: * Based on the OMAP2 camera driver
media/platform/omap/omap_voutlib.c:11: * Video-for-Linux (Version 2) camera capture driver for
media/platform/omap/omap_voutlib.c:12: * the OMAP24xx camera controller.
media/platform/exynos4-is/fimc-reg.c:2: * Register interface file for Samsung Camera Interface (FIMC) driver
media/platform/exynos4-is/fimc-reg.c:559:int fimc_hw_set_camera_polarity(struct fimc_dev *fimc,
media/platform/exynos4-is/fimc-reg.c:601:int fimc_hw_set_camera_source(struct fimc_dev *fimc,
media/platform/exynos4-is/fimc-reg.c:622:				 "Camera color format not supported: %d\n",
media/platform/exynos4-is/fimc-reg.c:649:void fimc_hw_set_camera_offset(struct fimc_dev *fimc, struct fimc_frame *f)
media/platform/exynos4-is/fimc-reg.c:668:int fimc_hw_set_camera_type(struct fimc_dev *fimc,
media/platform/exynos4-is/fimc-reg.c:702:				 "Not supported camera pixel format: %#x\n",
media/platform/exynos4-is/media-dev.c:2: * S5P/EXYNOS4 SoC series camera host interface media device driver
media/platform/exynos4-is/media-dev.c:861:		 * Some FIMC variants are not fitted with camera capture
media/platform/exynos4-is/media-dev.c:1509:MODULE_DESCRIPTION("S5P FIMC camera host interface/video postprocessor driver");
media/platform/exynos4-is/fimc-lite.c:2: * Samsung EXYNOS FIMC-LITE (camera host interface) driver
media/platform/exynos4-is/fimc-lite.c:176:	flite_hw_set_camera_bus(fimc, si);
media/platform/exynos4-is/fimc-lite.c:699:	 * raw Bayer the FIMC-LITE's output format must match its camera
media/platform/exynos4-is/fimc-lite.c:1058:		/* full camera input frame size */
media/platform/exynos4-is/fimc-isp.c:147:		/* full camera input frame size */
media/platform/exynos4-is/fimc-capture.c:2: * Samsung S5P/EXYNOS4 SoC series camera interface (camera capture) driver
media/platform/exynos4-is/fimc-capture.c:54:	fimc_hw_set_camera_polarity(fimc, si);
media/platform/exynos4-is/fimc-capture.c:55:	fimc_hw_set_camera_type(fimc, si);
media/platform/exynos4-is/fimc-capture.c:56:	fimc_hw_set_camera_source(fimc, si);
media/platform/exynos4-is/fimc-capture.c:57:	fimc_hw_set_camera_offset(fimc, &ctx->s_frame);
media/platform/exynos4-is/fimc-capture.c:148: * fimc_capture_config_update - apply the camera interface configuration
media/platform/exynos4-is/fimc-capture.c:151: * spinlock held. It updates the camera pixel crop, rotation and
media/platform/exynos4-is/fimc-capture.c:159:	fimc_hw_set_camera_offset(fimc, &ctx->s_frame);
media/platform/exynos4-is/fimc-capture.c:633:		/* Apply the camera input interface pixel constraints */
media/platform/exynos4-is/fimc-capture.c:1010:	/* Pre-configure format at camera interface input, for JPEG only */
media/platform/exynos4-is/fimc-capture.c:1063:	/* Reset cropping and set format at the camera interface input */
media/platform/exynos4-is/fimc-capture.c:1105:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/exynos4-is/fimc-capture.c:1749:	ctx->in_path	 = FIMC_IO_CAMERA;
media/platform/exynos4-is/fimc-lite-reg.c:2: * Register interface file for EXYNOS FIMC-LITE (camera interface) driver
media/platform/exynos4-is/fimc-lite-reg.c:127:/* Set camera input pixel format and resolution */
media/platform/exynos4-is/fimc-lite-reg.c:158:/* Set the camera host input window offsets (cropping) */
media/platform/exynos4-is/fimc-lite-reg.c:177:/* Select camera port (A, B) */
media/platform/exynos4-is/fimc-lite-reg.c:178:static void flite_hw_set_camera_port(struct fimc_lite *dev, int id)
media/platform/exynos4-is/fimc-lite-reg.c:188:/* Select serial or parallel bus, camera port (A,B) and set signals polarity */
media/platform/exynos4-is/fimc-lite-reg.c:189:void flite_hw_set_camera_bus(struct fimc_lite *dev,
media/platform/exynos4-is/fimc-lite-reg.c:215:	flite_hw_set_camera_port(dev, si->mux_id);
media/platform/via-camera.c:2: * Driver for the VIA Chrome integrated camera controller.
media/platform/via-camera.c:32:#include "via-camera.h"
media/platform/via-camera.c:34:MODULE_ALIAS("platform:viafb-camera");
media/platform/via-camera.c:36:MODULE_DESCRIPTION("VIA framebuffer-based camera controller driver");
media/platform/via-camera.c:48:		"The camera driver will normally refuse to load if "
media/platform/via-camera.c:50:		"to force-enable the camera.");
media/platform/via-camera.c:61: * The structure describing our camera.
media/platform/via-camera.c:65:struct via_camera {
media/platform/via-camera.c:119:static struct via_camera *via_cam_info;
media/platform/via-camera.c:186:static int via_sensor_power_setup(struct via_camera *cam)
media/platform/via-camera.c:196:	ret = gpio_request(cam->power_gpio, "viafb-camera");
media/platform/via-camera.c:201:	ret = gpio_request(cam->reset_gpio, "viafb-camera");
media/platform/via-camera.c:215:static void via_sensor_power_up(struct via_camera *cam)
media/platform/via-camera.c:224:static void via_sensor_power_down(struct via_camera *cam)
media/platform/via-camera.c:231:static void via_sensor_power_release(struct via_camera *cam)
media/platform/via-camera.c:244:static int viacam_set_flip(struct via_camera *cam)
media/platform/via-camera.c:256: * that the camera is in the correct operating state.
media/platform/via-camera.c:258:static int viacam_configure_sensor(struct via_camera *cam)
media/platform/via-camera.c:285:static inline void viacam_write_reg(struct via_camera *cam,
media/platform/via-camera.c:291:static inline int viacam_read_reg(struct via_camera *cam, int reg)
media/platform/via-camera.c:296:static inline void viacam_write_reg_mask(struct via_camera *cam,
media/platform/via-camera.c:311:	struct via_camera *cam = data;
media/platform/via-camera.c:333:static struct videobuf_buffer *viacam_next_buffer(struct via_camera *cam)
media/platform/via-camera.c:362:	struct via_camera *cam = data;
media/platform/via-camera.c:395: * camera.  Nothing else uses interrupts, though, as of this writing.
media/platform/via-camera.c:399:static void viacam_int_enable(struct via_camera *cam)
media/platform/via-camera.c:406:static void viacam_int_disable(struct via_camera *cam)
media/platform/via-camera.c:420:static int viacam_ctlr_cbufs(struct via_camera *cam)
media/platform/via-camera.c:422:	int nbuf = cam->viadev->camera_fbmem_size/cam->sensor_format.sizeimage;
media/platform/via-camera.c:470:static void viacam_set_scale(struct via_camera *cam)
media/platform/via-camera.c:492:static void viacam_ctlr_image(struct via_camera *cam)
media/platform/via-camera.c:543:static int viacam_config_controller(struct via_camera *cam)
media/platform/via-camera.c:560:static void viacam_start_engine(struct via_camera *cam)
media/platform/via-camera.c:572:static void viacam_stop_engine(struct via_camera *cam)
media/platform/via-camera.c:594:	struct via_camera *cam = q->priv_data;
media/platform/via-camera.c:608:	struct via_camera *cam = q->priv_data;
media/platform/via-camera.c:631:	struct via_camera *cam = q->priv_data;
media/platform/via-camera.c:647:	struct via_camera *cam = q->priv_data;
media/platform/via-camera.c:666:	struct via_camera *cam = video_drvdata(filp);
media/platform/via-camera.c:698:	struct via_camera *cam = video_drvdata(filp);
media/platform/via-camera.c:736:	struct via_camera *cam = video_drvdata(filp);
media/platform/via-camera.c:778:	struct via_camera *cam = video_drvdata(filp);
media/platform/via-camera.c:786:	struct via_camera *cam = video_drvdata(filp);
media/platform/via-camera.c:811:	struct via_camera *cam = priv;
media/platform/via-camera.c:831:	input->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/via-camera.c:833:	strcpy(input->name, "Camera");
media/platform/via-camera.c:918:static int viacam_do_try_fmt(struct via_camera *cam,
media/platform/via-camera.c:939:	struct via_camera *cam = priv;
media/platform/via-camera.c:953:	struct via_camera *cam = priv;
media/platform/via-camera.c:964:	struct via_camera *cam = priv;
media/platform/via-camera.c:970:	 * Camera must be idle or we can't mess with the
media/platform/via-camera.c:1002:	strcpy(cap->driver, "via-camera");
media/platform/via-camera.c:1003:	strcpy(cap->card, "via-camera");
media/platform/via-camera.c:1016:	struct via_camera *cam = priv;
media/platform/via-camera.c:1024:	struct via_camera *cam = priv;
media/platform/via-camera.c:1031:	struct via_camera *cam = priv;
media/platform/via-camera.c:1038:	struct via_camera *cam = priv;
media/platform/via-camera.c:1045:	struct via_camera *cam = priv;
media/platform/via-camera.c:1096:	struct via_camera *cam = priv;
media/platform/via-camera.c:1125:	struct via_camera *cam = priv;
media/platform/via-camera.c:1138:	struct via_camera *cam = priv;
media/platform/via-camera.c:1165:	struct via_camera *cam = priv;
media/platform/via-camera.c:1208:	struct via_camera *cam = priv;
media/platform/via-camera.c:1221:	struct via_camera *cam = priv;
media/platform/via-camera.c:1266:	.name		= "via-camera",
media/platform/via-camera.c:1277: * the camera.	They also get grumpy if we break the
media/platform/via-camera.c:1297:		printk(KERN_NOTICE "Via camera: serial port is enabled, " \
media/platform/via-camera.c:1303:	printk(KERN_NOTICE "Via camera: overriding serial port\n");
media/platform/via-camera.c:1310:	/* The XO-1.5 (only known user) clocks the camera at 90MHz. */
media/platform/via-camera.c:1331:	struct via_camera *cam;
media/platform/via-camera.c:1341:	if (viadev->camera_fbmem_size < (VGA_HEIGHT*VGA_WIDTH*4)) {
media/platform/via-camera.c:1356:	cam = kzalloc (sizeof(struct via_camera), GFP_KERNEL);
media/platform/via-camera.c:1370:	cam->fb_offset = viadev->camera_fbmem_offset;
media/platform/via-camera.c:1421:			viacam_irq, IRQF_SHARED, "via-camera", cam);
media/platform/via-camera.c:1461:	struct via_camera *cam = via_cam_info;
media/platform/via-camera.c:1476:		.name = "viafb-camera",
media/platform/soc_camera/soc_camera.c:2: * camera image capture (abstract) bus driver
media/platform/soc_camera/soc_camera.c:6: * This driver provides an interface between platform-specific camera
media/platform/soc_camera/soc_camera.c:7: * busses and camera devices. It should be used if the camera is
media/platform/soc_camera/soc_camera.c:11: * It can handle multiple cameras and / or multiple busses, which can
media/platform/soc_camera/soc_camera.c:32:#include <media/soc_camera.h>
media/platform/soc_camera/soc_camera.c:53:int soc_camera_power_on(struct device *dev, struct soc_camera_subdev_desc *ssdd)
media/platform/soc_camera/soc_camera.c:66:				"Platform failed to power-on the camera.\n");
media/platform/soc_camera/soc_camera.c:74:EXPORT_SYMBOL(soc_camera_power_on);
media/platform/soc_camera/soc_camera.c:76:int soc_camera_power_off(struct device *dev, struct soc_camera_subdev_desc *ssdd)
media/platform/soc_camera/soc_camera.c:85:				"Platform failed to power-off the camera.\n");
media/platform/soc_camera/soc_camera.c:99:EXPORT_SYMBOL(soc_camera_power_off);
media/platform/soc_camera/soc_camera.c:101:static int __soc_camera_power_on(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:103:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:113:static int __soc_camera_power_off(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:115:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:125:const struct soc_camera_format_xlate *soc_camera_xlate_by_fourcc(
media/platform/soc_camera/soc_camera.c:126:	struct soc_camera_device *icd, unsigned int fourcc)
media/platform/soc_camera/soc_camera.c:135:EXPORT_SYMBOL(soc_camera_xlate_by_fourcc);
media/platform/soc_camera/soc_camera.c:138: * soc_camera_apply_board_flags() - apply platform SOCAM_SENSOR_INVERT_* flags
media/platform/soc_camera/soc_camera.c:139: * @ssdd:	camera platform parameters
media/platform/soc_camera/soc_camera.c:143:unsigned long soc_camera_apply_board_flags(struct soc_camera_subdev_desc *ssdd,
media/platform/soc_camera/soc_camera.c:169:EXPORT_SYMBOL(soc_camera_apply_board_flags);
media/platform/soc_camera/soc_camera.c:174:static int soc_camera_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:177:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:178:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/soc_camera.c:195:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/soc_camera.c:215:static int soc_camera_try_fmt_vid_cap(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:218:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:227:	return soc_camera_try_fmt(icd, f);
media/platform/soc_camera/soc_camera.c:230:static int soc_camera_enum_input(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:236:	/* default is camera */
media/platform/soc_camera/soc_camera.c:237:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/soc_camera/soc_camera.c:239:	strcpy(inp->name, "Camera");
media/platform/soc_camera/soc_camera.c:244:static int soc_camera_g_input(struct file *file, void *priv, unsigned int *i)
media/platform/soc_camera/soc_camera.c:251:static int soc_camera_s_input(struct file *file, void *priv, unsigned int i)
media/platform/soc_camera/soc_camera.c:259:static int soc_camera_s_std(struct file *file, void *priv, v4l2_std_id a)
media/platform/soc_camera/soc_camera.c:261:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:262:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:267:static int soc_camera_g_std(struct file *file, void *priv, v4l2_std_id *a)
media/platform/soc_camera/soc_camera.c:269:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:270:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:275:static int soc_camera_enum_framesizes(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:278:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:279:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:284:static int soc_camera_reqbufs(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:288:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:289:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:312:static int soc_camera_querybuf(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:315:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:316:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:326:static int soc_camera_qbuf(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:329:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:330:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:343:static int soc_camera_dqbuf(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:346:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:347:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:360:static int soc_camera_create_bufs(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:363:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:364:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:373:static int soc_camera_prepare_buf(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:376:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:377:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:387:static int soc_camera_init_user_formats(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:389:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:390:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:420:		vmalloc(fmts * sizeof(struct soc_camera_format_xlate));
media/platform/soc_camera/soc_camera.c:454:static void soc_camera_free_user_formats(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:456:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:467:static int soc_camera_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:470:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:478:	ret = soc_camera_try_fmt(icd, f);
media/platform/soc_camera/soc_camera.c:508:static int soc_camera_open(struct file *file)
media/platform/soc_camera/soc_camera.c:511:	struct soc_camera_device *icd;
media/platform/soc_camera/soc_camera.c:512:	struct soc_camera_host *ici;
media/platform/soc_camera/soc_camera.c:518:	 * soc_camera_host_unregister().
media/platform/soc_camera/soc_camera.c:529:	ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:539:	if (!to_soc_camera_control(icd)) {
media/platform/soc_camera/soc_camera.c:551:	/* Now we really have to activate the camera */
media/platform/soc_camera/soc_camera.c:553:		struct soc_camera_desc *sdesc = to_soc_camera_desc(icd);
media/platform/soc_camera/soc_camera.c:567:		/* The camera could have been already on, try to reset */
media/platform/soc_camera/soc_camera.c:573:			dev_err(icd->pdev, "Couldn't activate the camera: %d\n", ret);
media/platform/soc_camera/soc_camera.c:577:		ret = __soc_camera_power_on(icd);
media/platform/soc_camera/soc_camera.c:592:		ret = soc_camera_set_fmt(icd, &f);
media/platform/soc_camera/soc_camera.c:608:	dev_dbg(icd->pdev, "camera device open\n");
media/platform/soc_camera/soc_camera.c:620:	__soc_camera_power_off(icd);
media/platform/soc_camera/soc_camera.c:633:static int soc_camera_close(struct file *file)
media/platform/soc_camera/soc_camera.c:635:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:636:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:646:		__soc_camera_power_off(icd);
media/platform/soc_camera/soc_camera.c:657:	dev_dbg(icd->pdev, "camera device close\n");
media/platform/soc_camera/soc_camera.c:662:static ssize_t soc_camera_read(struct file *file, char __user *buf,
media/platform/soc_camera/soc_camera.c:665:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:666:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:674:	dev_err(icd->pdev, "camera device read not implemented\n");
media/platform/soc_camera/soc_camera.c:679:static int soc_camera_mmap(struct file *file, struct vm_area_struct *vma)
media/platform/soc_camera/soc_camera.c:681:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:682:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:706:static unsigned int soc_camera_poll(struct file *file, poll_table *pt)
media/platform/soc_camera/soc_camera.c:708:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:709:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:724:void soc_camera_lock(struct vb2_queue *vq)
media/platform/soc_camera/soc_camera.c:726:	struct soc_camera_device *icd = vb2_get_drv_priv(vq);
media/platform/soc_camera/soc_camera.c:727:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:730:EXPORT_SYMBOL(soc_camera_lock);
media/platform/soc_camera/soc_camera.c:732:void soc_camera_unlock(struct vb2_queue *vq)
media/platform/soc_camera/soc_camera.c:734:	struct soc_camera_device *icd = vb2_get_drv_priv(vq);
media/platform/soc_camera/soc_camera.c:735:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:738:EXPORT_SYMBOL(soc_camera_unlock);
media/platform/soc_camera/soc_camera.c:740:static struct v4l2_file_operations soc_camera_fops = {
media/platform/soc_camera/soc_camera.c:742:	.open		= soc_camera_open,
media/platform/soc_camera/soc_camera.c:743:	.release	= soc_camera_close,
media/platform/soc_camera/soc_camera.c:745:	.read		= soc_camera_read,
media/platform/soc_camera/soc_camera.c:746:	.mmap		= soc_camera_mmap,
media/platform/soc_camera/soc_camera.c:747:	.poll		= soc_camera_poll,
media/platform/soc_camera/soc_camera.c:750:static int soc_camera_s_fmt_vid_cap(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:753:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:766:	if (is_streaming(to_soc_camera_host(icd->parent), icd)) {
media/platform/soc_camera/soc_camera.c:771:	ret = soc_camera_set_fmt(icd, f);
media/platform/soc_camera/soc_camera.c:779:static int soc_camera_enum_fmt_vid_cap(struct file *file, void  *priv,
media/platform/soc_camera/soc_camera.c:782:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:798:static int soc_camera_g_fmt_vid_cap(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:801:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:821:static int soc_camera_querycap(struct file *file, void  *priv,
media/platform/soc_camera/soc_camera.c:824:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:825:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:833:static int soc_camera_streamon(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:836:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:837:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:838:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:861:static int soc_camera_streamoff(struct file *file, void *priv,
media/platform/soc_camera/soc_camera.c:864:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:865:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:866:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:890:static int soc_camera_cropcap(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:893:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:894:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:899:static int soc_camera_g_crop(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:902:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:903:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:916:static int soc_camera_s_crop(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:919:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:920:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:956:static int soc_camera_g_selection(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:959:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:960:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:972:static int soc_camera_s_selection(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:975:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:976:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:1015:static int soc_camera_g_parm(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:1018:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:1019:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:1027:static int soc_camera_s_parm(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:1030:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:1031:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:1039:static int soc_camera_g_chip_ident(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:1042:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:1043:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1049:static int soc_camera_g_register(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:1052:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:1053:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1058:static int soc_camera_s_register(struct file *file, void *fh,
media/platform/soc_camera/soc_camera.c:1061:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/soc_camera.c:1062:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1068:static int soc_camera_probe(struct soc_camera_device *icd);
media/platform/soc_camera/soc_camera.c:1071:static void scan_add_host(struct soc_camera_host *ici)
media/platform/soc_camera/soc_camera.c:1073:	struct soc_camera_device *icd;
media/platform/soc_camera/soc_camera.c:1080:			soc_camera_probe(icd);
media/platform/soc_camera/soc_camera.c:1088:static int soc_camera_init_i2c(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:1089:			       struct soc_camera_desc *sdesc)
media/platform/soc_camera/soc_camera.c:1092:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:1093:	struct soc_camera_host_desc *shd = &sdesc->host_desc;
media/platform/soc_camera/soc_camera.c:1122:static void soc_camera_free_i2c(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:1125:		to_i2c_client(to_soc_camera_control(icd));
media/platform/soc_camera/soc_camera.c:1134:#define soc_camera_init_i2c(icd, sdesc)	(-ENODEV)
media/platform/soc_camera/soc_camera.c:1135:#define soc_camera_free_i2c(icd)	do {} while (0)
media/platform/soc_camera/soc_camera.c:1138:static int soc_camera_video_start(struct soc_camera_device *icd);
media/platform/soc_camera/soc_camera.c:1139:static int video_dev_create(struct soc_camera_device *icd);
media/platform/soc_camera/soc_camera.c:1141:static int soc_camera_probe(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:1143:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:1144:	struct soc_camera_desc *sdesc = to_soc_camera_desc(icd);
media/platform/soc_camera/soc_camera.c:1145:	struct soc_camera_host_desc *shd = &sdesc->host_desc;
media/platform/soc_camera/soc_camera.c:1146:	struct soc_camera_subdev_desc *ssdd = &sdesc->subdev_desc;
media/platform/soc_camera/soc_camera.c:1165:	/* The camera could have been already on, try to reset */
media/platform/soc_camera/soc_camera.c:1180:	/* Non-i2c cameras, e.g., soc_camera_platform, have no board_info */
media/platform/soc_camera/soc_camera.c:1182:		ret = soc_camera_init_i2c(icd, sdesc);
media/platform/soc_camera/soc_camera.c:1200:		control = to_soc_camera_control(icd);
media/platform/soc_camera/soc_camera.c:1209:	sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1210:	sd->grp_id = soc_camera_grp_id(icd);
media/platform/soc_camera/soc_camera.c:1218:	ret = soc_camera_init_user_formats(icd);
media/platform/soc_camera/soc_camera.c:1231:	ret = soc_camera_video_start(icd);
media/platform/soc_camera/soc_camera.c:1251:	soc_camera_free_user_formats(icd);
media/platform/soc_camera/soc_camera.c:1255:		soc_camera_free_i2c(icd);
media/platform/soc_camera/soc_camera.c:1277:static int soc_camera_remove(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:1279:	struct soc_camera_desc *sdesc = to_soc_camera_desc(icd);
media/platform/soc_camera/soc_camera.c:1291:		soc_camera_free_i2c(icd);
media/platform/soc_camera/soc_camera.c:1293:		struct device_driver *drv = to_soc_camera_control(icd)->driver;
media/platform/soc_camera/soc_camera.c:1299:	soc_camera_free_user_formats(icd);
media/platform/soc_camera/soc_camera.c:1304:static int default_cropcap(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:1307:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1311:static int default_g_crop(struct soc_camera_device *icd, struct v4l2_crop *a)
media/platform/soc_camera/soc_camera.c:1313:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1317:static int default_s_crop(struct soc_camera_device *icd, const struct v4l2_crop *a)
media/platform/soc_camera/soc_camera.c:1319:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1323:static int default_g_parm(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:1326:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1330:static int default_s_parm(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:1333:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1337:static int default_enum_framesizes(struct soc_camera_device *icd,
media/platform/soc_camera/soc_camera.c:1341:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/soc_camera.c:1342:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/soc_camera.c:1346:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/soc_camera.c:1362:int soc_camera_host_register(struct soc_camera_host *ici)
media/platform/soc_camera/soc_camera.c:1364:	struct soc_camera_host *ix;
media/platform/soc_camera/soc_camera.c:1418:EXPORT_SYMBOL(soc_camera_host_register);
media/platform/soc_camera/soc_camera.c:1421:void soc_camera_host_unregister(struct soc_camera_host *ici)
media/platform/soc_camera/soc_camera.c:1423:	struct soc_camera_device *icd;
media/platform/soc_camera/soc_camera.c:1429:		if (icd->iface == ici->nr && to_soc_camera_control(icd))
media/platform/soc_camera/soc_camera.c:1430:			soc_camera_remove(icd);
media/platform/soc_camera/soc_camera.c:1436:EXPORT_SYMBOL(soc_camera_host_unregister);
media/platform/soc_camera/soc_camera.c:1439:static int soc_camera_device_register(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:1441:	struct soc_camera_device *ix;
media/platform/soc_camera/soc_camera.c:1457:		 * ok, we have 256 cameras on this host...
media/platform/soc_camera/soc_camera.c:1471:static const struct v4l2_ioctl_ops soc_camera_ioctl_ops = {
media/platform/soc_camera/soc_camera.c:1472:	.vidioc_querycap	 = soc_camera_querycap,
media/platform/soc_camera/soc_camera.c:1473:	.vidioc_try_fmt_vid_cap  = soc_camera_try_fmt_vid_cap,
media/platform/soc_camera/soc_camera.c:1474:	.vidioc_g_fmt_vid_cap    = soc_camera_g_fmt_vid_cap,
media/platform/soc_camera/soc_camera.c:1475:	.vidioc_s_fmt_vid_cap    = soc_camera_s_fmt_vid_cap,
media/platform/soc_camera/soc_camera.c:1476:	.vidioc_enum_fmt_vid_cap = soc_camera_enum_fmt_vid_cap,
media/platform/soc_camera/soc_camera.c:1477:	.vidioc_enum_input	 = soc_camera_enum_input,
media/platform/soc_camera/soc_camera.c:1478:	.vidioc_g_input		 = soc_camera_g_input,
media/platform/soc_camera/soc_camera.c:1479:	.vidioc_s_input		 = soc_camera_s_input,
media/platform/soc_camera/soc_camera.c:1480:	.vidioc_s_std		 = soc_camera_s_std,
media/platform/soc_camera/soc_camera.c:1481:	.vidioc_g_std		 = soc_camera_g_std,
media/platform/soc_camera/soc_camera.c:1482:	.vidioc_enum_framesizes  = soc_camera_enum_framesizes,
media/platform/soc_camera/soc_camera.c:1483:	.vidioc_reqbufs		 = soc_camera_reqbufs,
media/platform/soc_camera/soc_camera.c:1484:	.vidioc_querybuf	 = soc_camera_querybuf,
media/platform/soc_camera/soc_camera.c:1485:	.vidioc_qbuf		 = soc_camera_qbuf,
media/platform/soc_camera/soc_camera.c:1486:	.vidioc_dqbuf		 = soc_camera_dqbuf,
media/platform/soc_camera/soc_camera.c:1487:	.vidioc_create_bufs	 = soc_camera_create_bufs,
media/platform/soc_camera/soc_camera.c:1488:	.vidioc_prepare_buf	 = soc_camera_prepare_buf,
media/platform/soc_camera/soc_camera.c:1489:	.vidioc_streamon	 = soc_camera_streamon,
media/platform/soc_camera/soc_camera.c:1490:	.vidioc_streamoff	 = soc_camera_streamoff,
media/platform/soc_camera/soc_camera.c:1491:	.vidioc_cropcap		 = soc_camera_cropcap,
media/platform/soc_camera/soc_camera.c:1492:	.vidioc_g_crop		 = soc_camera_g_crop,
media/platform/soc_camera/soc_camera.c:1493:	.vidioc_s_crop		 = soc_camera_s_crop,
media/platform/soc_camera/soc_camera.c:1494:	.vidioc_g_selection	 = soc_camera_g_selection,
media/platform/soc_camera/soc_camera.c:1495:	.vidioc_s_selection	 = soc_camera_s_selection,
media/platform/soc_camera/soc_camera.c:1496:	.vidioc_g_parm		 = soc_camera_g_parm,
media/platform/soc_camera/soc_camera.c:1497:	.vidioc_s_parm		 = soc_camera_s_parm,
media/platform/soc_camera/soc_camera.c:1498:	.vidioc_g_chip_ident     = soc_camera_g_chip_ident,
media/platform/soc_camera/soc_camera.c:1500:	.vidioc_g_register	 = soc_camera_g_register,
media/platform/soc_camera/soc_camera.c:1501:	.vidioc_s_register	 = soc_camera_s_register,
media/platform/soc_camera/soc_camera.c:1505:static int video_dev_create(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:1507:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera.c:1517:	vdev->fops		= &soc_camera_fops;
media/platform/soc_camera/soc_camera.c:1518:	vdev->ioctl_ops		= &soc_camera_ioctl_ops;
media/platform/soc_camera/soc_camera.c:1530: * Called from soc_camera_probe() above with .host_lock held
media/platform/soc_camera/soc_camera.c:1532:static int soc_camera_video_start(struct soc_camera_device *icd)
media/platform/soc_camera/soc_camera.c:1552:static int soc_camera_pdrv_probe(struct platform_device *pdev)
media/platform/soc_camera/soc_camera.c:1554:	struct soc_camera_desc *sdesc = pdev->dev.platform_data;
media/platform/soc_camera/soc_camera.c:1555:	struct soc_camera_subdev_desc *ssdd = &sdesc->subdev_desc;
media/platform/soc_camera/soc_camera.c:1556:	struct soc_camera_device *icd;
media/platform/soc_camera/soc_camera.c:1579:	return soc_camera_device_register(icd);
media/platform/soc_camera/soc_camera.c:1587:static int soc_camera_pdrv_remove(struct platform_device *pdev)
media/platform/soc_camera/soc_camera.c:1589:	struct soc_camera_device *icd = platform_get_drvdata(pdev);
media/platform/soc_camera/soc_camera.c:1599:static struct platform_driver __refdata soc_camera_pdrv = {
media/platform/soc_camera/soc_camera.c:1600:	.probe = soc_camera_pdrv_probe,
media/platform/soc_camera/soc_camera.c:1601:	.remove  = soc_camera_pdrv_remove,
media/platform/soc_camera/soc_camera.c:1603:		.name	= "soc-camera-pdrv",
media/platform/soc_camera/soc_camera.c:1608:module_platform_driver(soc_camera_pdrv);
media/platform/soc_camera/soc_camera.c:1613:MODULE_ALIAS("platform:soc-camera-pdrv");
media/platform/soc_camera/mx2_camera.c:2: * V4L2 Driver for i.MX27 camera host
media/platform/soc_camera/mx2_camera.c:37:#include <media/soc_camera.h>
media/platform/soc_camera/mx2_camera.c:42:#include <linux/platform_data/camera-mx2.h>
media/platform/soc_camera/mx2_camera.c:46:#define MX2_CAM_DRV_NAME "mx2-camera"
media/platform/soc_camera/mx2_camera.c:48:#define MX2_CAM_DRIVER_DESCRIPTION "i.MX2x_Camera"
media/platform/soc_camera/mx2_camera.c:232:enum mx2_camera_type {
media/platform/soc_camera/mx2_camera.c:233:	IMX27_CAMERA,
media/platform/soc_camera/mx2_camera.c:236:struct mx2_camera_dev {
media/platform/soc_camera/mx2_camera.c:238:	struct soc_camera_host	soc_host;
media/platform/soc_camera/mx2_camera.c:239:	struct soc_camera_device *icd;
media/platform/soc_camera/mx2_camera.c:245:	struct mx2_camera_platform_data *pdata;
media/platform/soc_camera/mx2_camera.c:260:	enum mx2_camera_type	devtype;
media/platform/soc_camera/mx2_camera.c:273:static struct platform_device_id mx2_camera_devtype[] = {
media/platform/soc_camera/mx2_camera.c:275:		.name = "imx27-camera",
media/platform/soc_camera/mx2_camera.c:276:		.driver_data = IMX27_CAMERA,
media/platform/soc_camera/mx2_camera.c:281:MODULE_DEVICE_TABLE(platform, mx2_camera_devtype);
media/platform/soc_camera/mx2_camera.c:385:static void mx27_update_emma_buf(struct mx2_camera_dev *pcdev,
media/platform/soc_camera/mx2_camera.c:408:static void mx2_camera_deactivate(struct mx2_camera_dev *pcdev)
media/platform/soc_camera/mx2_camera.c:418: * there can be only one camera on mx2 camera sensor interface
media/platform/soc_camera/mx2_camera.c:420:static int mx2_camera_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/mx2_camera.c:422:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:423:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:447:	dev_info(icd->parent, "Camera driver attached to camera %d\n",
media/platform/soc_camera/mx2_camera.c:458:static void mx2_camera_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/mx2_camera.c:460:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:461:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:465:	dev_info(icd->parent, "Camera driver detached from camera %d\n",
media/platform/soc_camera/mx2_camera.c:468:	mx2_camera_deactivate(pcdev);
media/platform/soc_camera/mx2_camera.c:481:	struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
media/platform/soc_camera/mx2_camera.c:482:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:483:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:508:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/mx2_camera.c:538:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/mx2_camera.c:539:	struct soc_camera_host *ici =
media/platform/soc_camera/mx2_camera.c:540:		to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:541:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:555:static void mx27_camera_emma_buf_init(struct soc_camera_device *icd,
media/platform/soc_camera/mx2_camera.c:558:	struct soc_camera_host *ici =
media/platform/soc_camera/mx2_camera.c:559:		to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:560:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:583:static void mx2_prp_resize_commit(struct mx2_camera_dev *pcdev)
media/platform/soc_camera/mx2_camera.c:653:	struct soc_camera_device *icd = soc_camera_from_vb2q(q);
media/platform/soc_camera/mx2_camera.c:654:	struct soc_camera_host *ici =
media/platform/soc_camera/mx2_camera.c:655:		to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:656:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:720:	mx27_camera_emma_buf_init(icd, bytesperline);
media/platform/soc_camera/mx2_camera.c:749:	struct soc_camera_device *icd = soc_camera_from_vb2q(q);
media/platform/soc_camera/mx2_camera.c:750:	struct soc_camera_host *ici =
media/platform/soc_camera/mx2_camera.c:751:		to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:752:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:791:static int mx2_camera_init_videobuf(struct vb2_queue *q,
media/platform/soc_camera/mx2_camera.c:792:			      struct soc_camera_device *icd)
media/platform/soc_camera/mx2_camera.c:815:static int mx27_camera_emma_prp_reset(struct mx2_camera_dev *pcdev)
media/platform/soc_camera/mx2_camera.c:832:static int mx2_camera_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/mx2_camera.c:834:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx2_camera.c:835:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:836:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:848:				 "Flags incompatible: camera 0x%x, host 0x%x\n",
media/platform/soc_camera/mx2_camera.c:860:		if (pcdev->platform_flags & MX2_CAMERA_HSYNC_HIGH)
media/platform/soc_camera/mx2_camera.c:868:		if (pcdev->platform_flags & MX2_CAMERA_PCLK_SAMPLE_RISING)
media/platform/soc_camera/mx2_camera.c:877:		dev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",
media/platform/soc_camera/mx2_camera.c:890:	if (pcdev->platform_flags & MX2_CAMERA_EXT_VSYNC)
media/platform/soc_camera/mx2_camera.c:892:	if (pcdev->platform_flags & MX2_CAMERA_CCIR)
media/platform/soc_camera/mx2_camera.c:894:	if (pcdev->platform_flags & MX2_CAMERA_CCIR_INTERLACE)
media/platform/soc_camera/mx2_camera.c:896:	if (pcdev->platform_flags & MX2_CAMERA_GATED_CLOCK)
media/platform/soc_camera/mx2_camera.c:898:	if (pcdev->platform_flags & MX2_CAMERA_INV_DATA)
media/platform/soc_camera/mx2_camera.c:908:	ret = mx27_camera_emma_prp_reset(pcdev);
media/platform/soc_camera/mx2_camera.c:917:static int mx2_camera_set_crop(struct soc_camera_device *icd,
media/platform/soc_camera/mx2_camera.c:922:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx2_camera.c:926:	soc_camera_limit_side(&rect->left, &rect->width, 0, 2, 4096);
media/platform/soc_camera/mx2_camera.c:927:	soc_camera_limit_side(&rect->top, &rect->height, 0, 2, 4096);
media/platform/soc_camera/mx2_camera.c:947:static int mx2_camera_get_formats(struct soc_camera_device *icd,
media/platform/soc_camera/mx2_camera.c:949:				  struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/mx2_camera.c:951:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx2_camera.c:1007:static int mx2_emmaprp_resize(struct mx2_camera_dev *pcdev,
media/platform/soc_camera/mx2_camera.c:1124:static int mx2_camera_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/mx2_camera.c:1127:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:1128:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:1129:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx2_camera.c:1130:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx2_camera.c:1138:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/mx2_camera.c:1186:static int mx2_camera_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/mx2_camera.c:1189:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx2_camera.c:1190:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx2_camera.c:1194:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx2_camera.c:1195:	struct mx2_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx2_camera.c:1202:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/mx2_camera.c:1262:static int mx2_camera_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/mx2_camera.c:1272:static unsigned int mx2_camera_poll(struct file *file, poll_table *pt)
media/platform/soc_camera/mx2_camera.c:1274:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/mx2_camera.c:1279:static struct soc_camera_host_ops mx2_soc_camera_host_ops = {
media/platform/soc_camera/mx2_camera.c:1281:	.add		= mx2_camera_add_device,
media/platform/soc_camera/mx2_camera.c:1282:	.remove		= mx2_camera_remove_device,
media/platform/soc_camera/mx2_camera.c:1283:	.set_fmt	= mx2_camera_set_fmt,
media/platform/soc_camera/mx2_camera.c:1284:	.set_crop	= mx2_camera_set_crop,
media/platform/soc_camera/mx2_camera.c:1285:	.get_formats	= mx2_camera_get_formats,
media/platform/soc_camera/mx2_camera.c:1286:	.try_fmt	= mx2_camera_try_fmt,
media/platform/soc_camera/mx2_camera.c:1287:	.init_videobuf2	= mx2_camera_init_videobuf,
media/platform/soc_camera/mx2_camera.c:1288:	.poll		= mx2_camera_poll,
media/platform/soc_camera/mx2_camera.c:1289:	.querycap	= mx2_camera_querycap,
media/platform/soc_camera/mx2_camera.c:1290:	.set_bus_param	= mx2_camera_set_bus_param,
media/platform/soc_camera/mx2_camera.c:1293:static void mx27_camera_frame_done_emma(struct mx2_camera_dev *pcdev,
media/platform/soc_camera/mx2_camera.c:1381:static irqreturn_t mx27_camera_emma_irq(int irq_emma, void *data)
media/platform/soc_camera/mx2_camera.c:1383:	struct mx2_camera_dev *pcdev = data;
media/platform/soc_camera/mx2_camera.c:1407:		mx27_camera_frame_done_emma(pcdev,
media/platform/soc_camera/mx2_camera.c:1419:		mx27_camera_frame_done_emma(pcdev, ibuf->bufnum, false);
media/platform/soc_camera/mx2_camera.c:1422:		mx27_camera_frame_done_emma(pcdev, 0, false);
media/platform/soc_camera/mx2_camera.c:1424:		mx27_camera_frame_done_emma(pcdev, 1, false);
media/platform/soc_camera/mx2_camera.c:1433:static int mx27_camera_emma_init(struct platform_device *pdev)
media/platform/soc_camera/mx2_camera.c:1435:	struct mx2_camera_dev *pcdev = platform_get_drvdata(pdev);
media/platform/soc_camera/mx2_camera.c:1454:	err = devm_request_irq(pcdev->dev, irq_emma, mx27_camera_emma_irq, 0,
media/platform/soc_camera/mx2_camera.c:1457:		dev_err(pcdev->dev, "Camera EMMA interrupt register failed\n");
media/platform/soc_camera/mx2_camera.c:1477:	err = mx27_camera_emma_prp_reset(pcdev);
media/platform/soc_camera/mx2_camera.c:1491:static int mx2_camera_probe(struct platform_device *pdev)
media/platform/soc_camera/mx2_camera.c:1493:	struct mx2_camera_dev *pcdev;
media/platform/soc_camera/mx2_camera.c:1560:	err = mx27_camera_emma_init(pdev);
media/platform/soc_camera/mx2_camera.c:1571:	pcdev->soc_host.ops		= &mx2_soc_camera_host_ops,
media/platform/soc_camera/mx2_camera.c:1581:	err = soc_camera_host_register(&pcdev->soc_host);
media/platform/soc_camera/mx2_camera.c:1585:	dev_info(&pdev->dev, "MX2 Camera (CSI) driver probed, clock frequency: %ld\n",
media/platform/soc_camera/mx2_camera.c:1599:static int mx2_camera_remove(struct platform_device *pdev)
media/platform/soc_camera/mx2_camera.c:1601:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/mx2_camera.c:1602:	struct mx2_camera_dev *pcdev = container_of(soc_host,
media/platform/soc_camera/mx2_camera.c:1603:			struct mx2_camera_dev, soc_host);
media/platform/soc_camera/mx2_camera.c:1605:	soc_camera_host_unregister(&pcdev->soc_host);
media/platform/soc_camera/mx2_camera.c:1612:	dev_info(&pdev->dev, "MX2 Camera driver unloaded\n");
media/platform/soc_camera/mx2_camera.c:1617:static struct platform_driver mx2_camera_driver = {
media/platform/soc_camera/mx2_camera.c:1621:	.id_table	= mx2_camera_devtype,
media/platform/soc_camera/mx2_camera.c:1622:	.remove		= mx2_camera_remove,
media/platform/soc_camera/mx2_camera.c:1625:module_platform_driver_probe(mx2_camera_driver, mx2_camera_probe);
media/platform/soc_camera/mx2_camera.c:1627:MODULE_DESCRIPTION("i.MX27 SoC Camera Host driver");
media/platform/soc_camera/soc_camera_platform.c:2: * Generic Platform Camera Driver
media/platform/soc_camera/soc_camera_platform.c:20:#include <media/soc_camera.h>
media/platform/soc_camera/soc_camera_platform.c:21:#include <media/soc_camera_platform.h>
media/platform/soc_camera/soc_camera_platform.c:23:struct soc_camera_platform_priv {
media/platform/soc_camera/soc_camera_platform.c:27:static struct soc_camera_platform_priv *get_priv(struct platform_device *pdev)
media/platform/soc_camera/soc_camera_platform.c:30:	return container_of(subdev, struct soc_camera_platform_priv, subdev);
media/platform/soc_camera/soc_camera_platform.c:33:static int soc_camera_platform_s_stream(struct v4l2_subdev *sd, int enable)
media/platform/soc_camera/soc_camera_platform.c:35:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:39:static int soc_camera_platform_fill_fmt(struct v4l2_subdev *sd,
media/platform/soc_camera/soc_camera_platform.c:42:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:53:static int soc_camera_platform_s_power(struct v4l2_subdev *sd, int on)
media/platform/soc_camera/soc_camera_platform.c:55:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:57:	return soc_camera_set_power(p->icd->control, &p->icd->sdesc->subdev_desc, on);
media/platform/soc_camera/soc_camera_platform.c:61:	.s_power = soc_camera_platform_s_power,
media/platform/soc_camera/soc_camera_platform.c:64:static int soc_camera_platform_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
media/platform/soc_camera/soc_camera_platform.c:67:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:76:static int soc_camera_platform_g_crop(struct v4l2_subdev *sd,
media/platform/soc_camera/soc_camera_platform.c:79:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:90:static int soc_camera_platform_cropcap(struct v4l2_subdev *sd,
media/platform/soc_camera/soc_camera_platform.c:93:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:107:static int soc_camera_platform_g_mbus_config(struct v4l2_subdev *sd,
media/platform/soc_camera/soc_camera_platform.c:110:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
media/platform/soc_camera/soc_camera_platform.c:119:	.s_stream	= soc_camera_platform_s_stream,
media/platform/soc_camera/soc_camera_platform.c:120:	.enum_mbus_fmt	= soc_camera_platform_enum_fmt,
media/platform/soc_camera/soc_camera_platform.c:121:	.cropcap	= soc_camera_platform_cropcap,
media/platform/soc_camera/soc_camera_platform.c:122:	.g_crop		= soc_camera_platform_g_crop,
media/platform/soc_camera/soc_camera_platform.c:123:	.try_mbus_fmt	= soc_camera_platform_fill_fmt,
media/platform/soc_camera/soc_camera_platform.c:124:	.g_mbus_fmt	= soc_camera_platform_fill_fmt,
media/platform/soc_camera/soc_camera_platform.c:125:	.s_mbus_fmt	= soc_camera_platform_fill_fmt,
media/platform/soc_camera/soc_camera_platform.c:126:	.g_mbus_config	= soc_camera_platform_g_mbus_config,
media/platform/soc_camera/soc_camera_platform.c:134:static int soc_camera_platform_probe(struct platform_device *pdev)
media/platform/soc_camera/soc_camera_platform.c:136:	struct soc_camera_host *ici;
media/platform/soc_camera/soc_camera_platform.c:137:	struct soc_camera_platform_priv *priv;
media/platform/soc_camera/soc_camera_platform.c:138:	struct soc_camera_platform_info *p = pdev->dev.platform_data;
media/platform/soc_camera/soc_camera_platform.c:139:	struct soc_camera_device *icd;
media/platform/soc_camera/soc_camera_platform.c:147:			"Platform has not set soc_camera_device pointer!\n");
media/platform/soc_camera/soc_camera_platform.c:157:	/* soc-camera convention: control's drvdata points to the subdev */
media/platform/soc_camera/soc_camera_platform.c:162:	ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/soc_camera_platform.c:179:static int soc_camera_platform_remove(struct platform_device *pdev)
media/platform/soc_camera/soc_camera_platform.c:181:	struct soc_camera_platform_priv *priv = get_priv(pdev);
media/platform/soc_camera/soc_camera_platform.c:182:	struct soc_camera_platform_info *p = v4l2_get_subdevdata(&priv->subdev);
media/platform/soc_camera/soc_camera_platform.c:190:static struct platform_driver soc_camera_platform_driver = {
media/platform/soc_camera/soc_camera_platform.c:192:		.name	= "soc_camera_platform",
media/platform/soc_camera/soc_camera_platform.c:195:	.probe		= soc_camera_platform_probe,
media/platform/soc_camera/soc_camera_platform.c:196:	.remove		= soc_camera_platform_remove,
media/platform/soc_camera/soc_camera_platform.c:199:module_platform_driver(soc_camera_platform_driver);
media/platform/soc_camera/soc_camera_platform.c:201:MODULE_DESCRIPTION("SoC Camera Platform driver");
media/platform/soc_camera/soc_camera_platform.c:204:MODULE_ALIAS("platform:soc_camera_platform");
media/platform/soc_camera/sh_mobile_csi2.c:23:#include <media/soc_camera.h>
media/platform/soc_camera/sh_mobile_csi2.c:147:	struct soc_camera_device *icd = v4l2_get_subdev_hostdata(sd);
media/platform/soc_camera/sh_mobile_csi2.c:148:	struct v4l2_subdev *client_sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_csi2.c:206:	struct soc_camera_device *icd = v4l2_get_subdev_hostdata(&priv->subdev);
media/platform/soc_camera/sh_mobile_csi2.c:207:	struct v4l2_subdev *client_sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_csi2.c:225:	/* Check if we can support this camera */
media/platform/soc_camera/sh_mobile_csi2.c:257:	/* All good: camera MIPI configuration supported */
media/platform/soc_camera/soc_mediabus.c:2: * soc-camera media bus helper routines
media/platform/soc_camera/soc_mediabus.c:527:MODULE_DESCRIPTION("soc-camera media bus interface");
media/platform/soc_camera/sh_mobile_ceu_camera.c:6: * Based on V4L2 Driver for PXA camera host - "pxa_camera.c",
media/platform/soc_camera/sh_mobile_ceu_camera.c:40:#include <media/soc_camera.h>
media/platform/soc_camera/sh_mobile_ceu_camera.c:56:#define CSTCR  0x20 /* Camera strobe control register (<= sh7722) */
media/platform/soc_camera/sh_mobile_ceu_camera.c:57:#define CSECR  0x24 /* Camera strobe emission count register (<= sh7722) */
media/platform/soc_camera/sh_mobile_ceu_camera.c:97:	struct soc_camera_host ici;
media/platform/soc_camera/sh_mobile_ceu_camera.c:98:	struct soc_camera_device *icd;
media/platform/soc_camera/sh_mobile_ceu_camera.c:129:	/* CEU offsets within the camera output, before the CEU scaler */
media/platform/soc_camera/sh_mobile_ceu_camera.c:141:	/* Camera cropping rectangle */
media/platform/soc_camera/sh_mobile_ceu_camera.c:166:	struct soc_camera_device *icd = pcdev->icd;
media/platform/soc_camera/sh_mobile_ceu_camera.c:211:	struct soc_camera_device *icd = container_of(vq, struct soc_camera_device, vb2_vidq);
media/platform/soc_camera/sh_mobile_ceu_camera.c:212:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:216:		const struct soc_camera_format_xlate *xlate = soc_camera_xlate_by_fourcc(icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:280:	struct soc_camera_device *icd = pcdev->icd;
media/platform/soc_camera/sh_mobile_ceu_camera.c:376:	struct soc_camera_device *icd = container_of(vb->vb2_queue, struct soc_camera_device, vb2_vidq);
media/platform/soc_camera/sh_mobile_ceu_camera.c:377:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:426:	struct soc_camera_device *icd = container_of(vb->vb2_queue, struct soc_camera_device, vb2_vidq);
media/platform/soc_camera/sh_mobile_ceu_camera.c:427:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:455:	struct soc_camera_device *icd = container_of(vb->vb2_queue, struct soc_camera_device, vb2_vidq);
media/platform/soc_camera/sh_mobile_ceu_camera.c:456:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:470:	struct soc_camera_device *icd = container_of(q, struct soc_camera_device, vb2_vidq);
media/platform/soc_camera/sh_mobile_ceu_camera.c:471:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:493:	.wait_prepare	= soc_camera_unlock,
media/platform/soc_camera/sh_mobile_ceu_camera.c:494:	.wait_finish	= soc_camera_lock,
media/platform/soc_camera/sh_mobile_ceu_camera.c:548:static int sh_mobile_ceu_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:550:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:559:		 "SuperH Mobile CEU driver attached to camera %d\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:570:		csi2_sd->grp_id = soc_camera_grp_id(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:582:	 * has not found this soc-camera device among its clients
media/platform/soc_camera/sh_mobile_ceu_camera.c:592:static void sh_mobile_ceu_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:594:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:619:		 "SuperH Mobile CEU driver detached from camera %d\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:655:/* rect is guaranteed to not exceed the scaled camera rectangle */
media/platform/soc_camera/sh_mobile_ceu_camera.c:656:static void sh_mobile_ceu_set_rect(struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:658:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:763:					   struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:767:		if (csi2_sd && csi2_sd->grp_id == soc_camera_grp_id(icd))
media/platform/soc_camera/sh_mobile_ceu_camera.c:771:	return soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:783:static int sh_mobile_ceu_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:785:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:929:static int sh_mobile_ceu_try_bus_param(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:932:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:998:static struct soc_camera_device *ctrl_to_icd(struct v4l2_ctrl *ctrl)
media/platform/soc_camera/sh_mobile_ceu_camera.c:1000:	return container_of(ctrl->handler, struct soc_camera_device,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1006:	struct soc_camera_device *icd = ctrl_to_icd(ctrl);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1007:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1030:static int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int idx,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1031:				     struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/sh_mobile_ceu_camera.c:1033:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1035:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1097:					soc_camera_grp_id(icd), video,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1110:		dev_geo(dev, "camera fmt %ux%u\n", mf.width, mf.height);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1116:		/* We are called with current camera crop, initialise subrect with it */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1141:		 * Our case is simple so far: for any of the above four camera
media/platform/soc_camera/sh_mobile_ceu_camera.c:1179:static void sh_mobile_ceu_put_formats(struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:1224:	/* Camera driver doesn't support .g_crop(), assume default rectangle */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1266:static int client_s_crop(struct soc_camera_device *icd, struct v4l2_crop *crop,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1269:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1283:	 * Now cam_crop contains the current camera input rectangle, and it must
media/platform/soc_camera/sh_mobile_ceu_camera.c:1284:	 * be within camera cropcap bounds
media/platform/soc_camera/sh_mobile_ceu_camera.c:1287:		/* Even if camera S_CROP failed, but camera rectangle matches */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1288:		dev_dbg(dev, "Camera S_CROP successful for %dx%d@%d:%d\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:1294:	/* Try to fix cropping, that camera hasn't managed to set */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1295:	dev_geo(dev, "Fix camera S_CROP for %dx%d@%d:%d to %dx%d@%d:%d\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:1306:	soc_camera_limit_side(&rect->left, &rect->width, cap.bounds.left, 2,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1308:	soc_camera_limit_side(&rect->top, &rect->height, cap.bounds.top, 4,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1312:	 * Popular special case - some cameras can only handle fixed sizes like
media/platform/soc_camera/sh_mobile_ceu_camera.c:1333:		 * We do not know what capabilities the camera has to set up
media/platform/soc_camera/sh_mobile_ceu_camera.c:1335:		 * them, e.g., if camera current left is to the right of the
media/platform/soc_camera/sh_mobile_ceu_camera.c:1357:		dev_geo(dev, "Camera S_CROP %d for %dx%d@%d:%d\n", ret,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1365:		 * The camera failed to configure a suitable cropping,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1371:		dev_geo(dev, "Camera S_CROP %d for max %dx%d@%d:%d\n", ret,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1385:static int client_s_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1388:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1391:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1400:					 soc_camera_grp_id(icd), video,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1405:	dev_geo(dev, "camera scaled to %ux%u\n", mf->width, mf->height);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1426:	/* Camera set a format, but geometry is not precise, try to improve */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1438:					soc_camera_grp_id(icd), video,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1440:		dev_geo(dev, "Camera scaled to %ux%u\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:1466: * @mf		- in- / output camera output window
media/platform/soc_camera/sh_mobile_ceu_camera.c:1468:static int client_scale(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1480:	 * 5. Apply iterative camera S_FMT for camera user window (also updates
media/platform/soc_camera/sh_mobile_ceu_camera.c:1487:	dev_geo(dev, "5: camera scaled to %ux%u\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:1490:	/* 6. Retrieve camera output window (g_fmt) */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1503:	 * 8. Calculate new CEU crop - apply camera scales to previously
media/platform/soc_camera/sh_mobile_ceu_camera.c:1517: * Documentation/video4linux/sh_mobile_ceu_camera.txt for a description of
media/platform/soc_camera/sh_mobile_ceu_camera.c:1520:static int sh_mobile_ceu_set_crop(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1526:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1531:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1542:	/* During camera cropping its output window can change too, stop CEU */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1547:	 * 1. - 2. Apply iterative camera S_CROP for new input window, read back
media/platform/soc_camera/sh_mobile_ceu_camera.c:1548:	 * actual camera rectangle.
media/platform/soc_camera/sh_mobile_ceu_camera.c:1554:	dev_geo(dev, "1-2: camera cropped to %ux%u@%u:%u\n",
media/platform/soc_camera/sh_mobile_ceu_camera.c:1558:	/* On success cam_crop contains current camera crop */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1560:	/* 3. Retrieve camera output window */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1568:	/* 4. Calculate camera scales */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1594:					soc_camera_grp_id(icd), video,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1599:		dev_geo(dev, "New camera output %ux%u\n", mf.width, mf.height);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1606:	/* Cache camera output window */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1619:	 * 5. Calculate CEU scales from camera scales from results of (5) and
media/platform/soc_camera/sh_mobile_ceu_camera.c:1654:	/* Even if only camera cropping succeeded */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1658:static int sh_mobile_ceu_get_crop(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1674:static void calculate_client_output(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1690:	/* 1.-2. Current camera scales and subwin - cached. */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1719:static int sh_mobile_ceu_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1723:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1729:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/sh_mobile_ceu_camera.c:1751:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1777:	dev_geo(dev, "4: request camera output %ux%u\n", mf.width, mf.height);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1785:	/* Done with the camera. Now see if we can improve the result */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1847:static int sh_mobile_ceu_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1850:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1852:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/sh_mobile_ceu_camera.c:1854:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1863:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1889:	ret = v4l2_device_call_until_err(sd->v4l2_dev, soc_camera_grp_id(icd),
media/platform/soc_camera/sh_mobile_ceu_camera.c:1904:		/* FIXME: check against rect_max after converting soc-camera */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1905:		/* We can scale precisely, need a bigger image from camera */
media/platform/soc_camera/sh_mobile_ceu_camera.c:1915:					soc_camera_grp_id(icd), video,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1950:static int sh_mobile_ceu_set_livecrop(struct soc_camera_device *icd,
media/platform/soc_camera/sh_mobile_ceu_camera.c:1953:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/sh_mobile_ceu_camera.c:1954:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/sh_mobile_ceu_camera.c:2008:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/sh_mobile_ceu_camera.c:2013:static int sh_mobile_ceu_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/sh_mobile_ceu_camera.c:2022:				       struct soc_camera_device *icd)
media/platform/soc_camera/sh_mobile_ceu_camera.c:2035:static struct soc_camera_host_ops sh_mobile_ceu_host_ops = {
media/platform/soc_camera/sh_mobile_ceu_camera.c:2163:	err = soc_camera_host_register(&pcdev->ici);
media/platform/soc_camera/sh_mobile_ceu_camera.c:2239:	soc_camera_host_unregister(&pcdev->ici);
media/platform/soc_camera/sh_mobile_ceu_camera.c:2252:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/sh_mobile_ceu_camera.c:2257:	soc_camera_host_unregister(soc_host);
media/platform/soc_camera/omap1_camera.c:2: * V4L2 SoC Camera driver for OMAP1 Camera Interface
media/platform/soc_camera/omap1_camera.c:6: * Based on V4L2 Driver for i.MXL/i.MXL camera (CSI) host
media/platform/soc_camera/omap1_camera.c:10: * Based on PXA SoC camera driver
media/platform/soc_camera/omap1_camera.c:31:#include <media/omap1_camera.h>
media/platform/soc_camera/omap1_camera.c:32:#include <media/soc_camera.h>
media/platform/soc_camera/omap1_camera.c:40:#define DRIVER_NAME		"omap1-camera"
media/platform/soc_camera/omap1_camera.c:43:#define OMAP_DMA_CAMERA_IF_RX		20
media/platform/soc_camera/omap1_camera.c:47: *  OMAP1 Camera Interface registers
media/platform/soc_camera/omap1_camera.c:104:/* end of OMAP1 Camera Interface registers */
media/platform/soc_camera/omap1_camera.c:152:	struct soc_camera_host		soc_host;
media/platform/soc_camera/omap1_camera.c:153:	struct soc_camera_device	*icd;
media/platform/soc_camera/omap1_camera.c:209:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/omap1_camera.c:210:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:215:	if (!*count || *count < OMAP1_CAMERA_MIN_BUF_COUNT(pcdev->vb_mode))
media/platform/soc_camera/omap1_camera.c:216:		*count = OMAP1_CAMERA_MIN_BUF_COUNT(pcdev->vb_mode);
media/platform/soc_camera/omap1_camera.c:239:		struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/omap1_camera.c:253:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/omap1_camera.c:255:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:483:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/omap1_camera.c:484:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:536:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/omap1_camera.c:538:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/omap1_camera.c:805:		dev_warn(dev, "%s: unhandled camera interrupt, status == %#x\n",
media/platform/soc_camera/omap1_camera.c:865:		dev_warn(dev, "%s: unhandled camera interrupt, status == %#x\n",
media/platform/soc_camera/omap1_camera.c:885: * SOC Camera host operations
media/platform/soc_camera/omap1_camera.c:890:	/* apply/release camera sensor reset if requested by platform data */
media/platform/soc_camera/omap1_camera.c:891:	if (pcdev->pflags & OMAP1_CAMERA_RST_HIGH)
media/platform/soc_camera/omap1_camera.c:893:	else if (pcdev->pflags & OMAP1_CAMERA_RST_LOW)
media/platform/soc_camera/omap1_camera.c:899: * there can be only one camera on OMAP1 camera sensor interface
media/platform/soc_camera/omap1_camera.c:901:static int omap1_cam_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/omap1_camera.c:903:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:946:	dev_dbg(icd->parent, "OMAP1 Camera driver attached to camera %d\n",
media/platform/soc_camera/omap1_camera.c:951:static void omap1_cam_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/omap1_camera.c:953:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:980:		"OMAP1 Camera driver detached from camera %d\n", icd->devnum);
media/platform/soc_camera/omap1_camera.c:1068:static int omap1_cam_get_formats(struct soc_camera_device *icd,
media/platform/soc_camera/omap1_camera.c:1069:		unsigned int idx, struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/omap1_camera.c:1071:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/omap1_camera.c:1162:	struct soc_camera_sense sense = {					     \
media/platform/soc_camera/omap1_camera.c:1177:				"%s: pixel clock %lu set by the camera too high!\n", \
media/platform/soc_camera/omap1_camera.c:1186:		struct soc_camera_device *icd, struct v4l2_subdev *sd,
media/platform/soc_camera/omap1_camera.c:1188:		const struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/omap1_camera.c:1218:static int omap1_cam_set_crop(struct soc_camera_device *icd,
media/platform/soc_camera/omap1_camera.c:1222:	const struct soc_camera_format_xlate *xlate = icd->current_fmt;
media/platform/soc_camera/omap1_camera.c:1223:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/omap1_camera.c:1225:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/omap1_camera.c:1267:static int omap1_cam_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/omap1_camera.c:1270:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/omap1_camera.c:1271:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/omap1_camera.c:1273:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/omap1_camera.c:1279:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/omap1_camera.c:1316:static int omap1_cam_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/omap1_camera.c:1319:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/omap1_camera.c:1320:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/omap1_camera.c:1326:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/omap1_camera.c:1363:	struct soc_camera_device *icd = q->priv_data;
media/platform/soc_camera/omap1_camera.c:1364:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:1377:				     struct soc_camera_device *icd)
media/platform/soc_camera/omap1_camera.c:1379:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/omap1_camera.c:1407:static int omap1_cam_reqbufs(struct soc_camera_device *icd,
media/platform/soc_camera/omap1_camera.c:1428:static int omap1_cam_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/omap1_camera.c:1432:	strlcpy(cap->card, "OMAP1 Camera", sizeof(cap->card));
media/platform/soc_camera/omap1_camera.c:1438:static int omap1_cam_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/omap1_camera.c:1440:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/omap1_camera.c:1442:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/omap1_camera.c:1445:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/omap1_camera.c:1457:				 "Flags incompatible: camera 0x%x, host 0x%x\n",
media/platform/soc_camera/omap1_camera.c:1471:				pcdev->pdata->flags & OMAP1_CAMERA_LCLK_RISING)
media/platform/soc_camera/omap1_camera.c:1480:		dev_dbg(dev, "camera s_mbus_config(0x%lx) returned %d\n",
media/platform/soc_camera/omap1_camera.c:1502:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/omap1_camera.c:1519:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/omap1_camera.c:1534:static struct soc_camera_host_ops omap1_host_ops = {
media/platform/soc_camera/omap1_camera.c:1627:	err = omap_request_dma(OMAP_DMA_CAMERA_IF_RX, DRIVER_NAME,
media/platform/soc_camera/omap1_camera.c:1630:		dev_err(&pdev->dev, "Can't request DMA for OMAP1 Camera\n");
media/platform/soc_camera/omap1_camera.c:1646:		dev_err(&pdev->dev, "Camera interrupt register failed\n");
media/platform/soc_camera/omap1_camera.c:1656:	err = soc_camera_host_register(&pcdev->soc_host);
media/platform/soc_camera/omap1_camera.c:1660:	dev_info(&pdev->dev, "OMAP1 Camera Interface driver loaded\n");
media/platform/soc_camera/omap1_camera.c:1682:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/omap1_camera.c:1691:	soc_camera_host_unregister(soc_host);
media/platform/soc_camera/omap1_camera.c:1702:	dev_info(&pdev->dev, "OMAP1 Camera Interface driver unloaded\n");
media/platform/soc_camera/omap1_camera.c:1720:MODULE_DESCRIPTION("OMAP1 Camera Interface driver");
media/platform/soc_camera/mx1_camera.c:2: * V4L2 Driver for i.MXL/i.MXL camera (CSI) host
media/platform/soc_camera/mx1_camera.c:7: * Based on PXA SoC camera driver
media/platform/soc_camera/mx1_camera.c:35:#include <media/soc_camera.h>
media/platform/soc_camera/mx1_camera.c:46:#include <linux/platform_data/camera-mx1.h>
media/platform/soc_camera/mx1_camera.c:76:#define DRIVER_NAME "mx1-camera"
media/platform/soc_camera/mx1_camera.c:101: * i.MX1/i.MXL is only supposed to handle one camera on its Camera Sensor
media/platform/soc_camera/mx1_camera.c:103: * one camera, they will have to modify this driver too
media/platform/soc_camera/mx1_camera.c:105:struct mx1_camera_dev {
media/platform/soc_camera/mx1_camera.c:106:	struct soc_camera_host		soc_host;
media/platform/soc_camera/mx1_camera.c:107:	struct soc_camera_device	*icd;
media/platform/soc_camera/mx1_camera.c:108:	struct mx1_camera_pdata		*pdata;
media/platform/soc_camera/mx1_camera.c:128:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/mx1_camera.c:145:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/mx1_camera.c:166:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/mx1_camera.c:220:static int mx1_camera_setup_dma(struct mx1_camera_dev *pcdev)
media/platform/soc_camera/mx1_camera.c:246:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/mx1_camera.c:247:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx1_camera.c:248:	struct mx1_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx1_camera.c:262:		if (!mx1_camera_setup_dma(pcdev)) {
media/platform/soc_camera/mx1_camera.c:277:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/mx1_camera.c:302:static void mx1_camera_wakeup(struct mx1_camera_dev *pcdev,
media/platform/soc_camera/mx1_camera.c:306:	/* _init is used to debug races, see comment in mx1_camera_reqbufs() */
media/platform/soc_camera/mx1_camera.c:322:	if (likely(!mx1_camera_setup_dma(pcdev))) {
media/platform/soc_camera/mx1_camera.c:331:static void mx1_camera_dma_irq(int channel, void *data)
media/platform/soc_camera/mx1_camera.c:333:	struct mx1_camera_dev *pcdev = data;
media/platform/soc_camera/mx1_camera.c:354:	mx1_camera_wakeup(pcdev, vb, buf);
media/platform/soc_camera/mx1_camera.c:366:static void mx1_camera_init_videobuf(struct videobuf_queue *q,
media/platform/soc_camera/mx1_camera.c:367:				     struct soc_camera_device *icd)
media/platform/soc_camera/mx1_camera.c:369:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx1_camera.c:370:	struct mx1_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx1_camera.c:378:static int mclk_get_divisor(struct mx1_camera_dev *pcdev)
media/platform/soc_camera/mx1_camera.c:399:static void mx1_camera_activate(struct mx1_camera_dev *pcdev)
media/platform/soc_camera/mx1_camera.c:417:static void mx1_camera_deactivate(struct mx1_camera_dev *pcdev)
media/platform/soc_camera/mx1_camera.c:429: * there can be only one camera on i.MX1/i.MXL camera sensor interface
media/platform/soc_camera/mx1_camera.c:431:static int mx1_camera_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/mx1_camera.c:433:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx1_camera.c:434:	struct mx1_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx1_camera.c:439:	dev_info(icd->parent, "MX1 Camera driver attached to camera %d\n",
media/platform/soc_camera/mx1_camera.c:442:	mx1_camera_activate(pcdev);
media/platform/soc_camera/mx1_camera.c:449:static void mx1_camera_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/mx1_camera.c:451:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx1_camera.c:452:	struct mx1_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx1_camera.c:464:	dev_info(icd->parent, "MX1 Camera driver detached from camera %d\n",
media/platform/soc_camera/mx1_camera.c:467:	mx1_camera_deactivate(pcdev);
media/platform/soc_camera/mx1_camera.c:472:static int mx1_camera_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/mx1_camera.c:474:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx1_camera.c:475:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx1_camera.c:476:	struct mx1_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/mx1_camera.c:488:				 "Flags incompatible: camera 0x%x, host 0x%x\n",
media/platform/soc_camera/mx1_camera.c:502:			     pcdev->pdata->flags & MX1_CAMERA_VSYNC_HIGH)
media/platform/soc_camera/mx1_camera.c:511:			     pcdev->pdata->flags & MX1_CAMERA_PCLK_RISING)
media/platform/soc_camera/mx1_camera.c:520:			     pcdev->pdata->flags & MX1_CAMERA_DATA_HIGH)
media/platform/soc_camera/mx1_camera.c:529:		dev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",
media/platform/soc_camera/mx1_camera.c:548:static int mx1_camera_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/mx1_camera.c:551:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx1_camera.c:552:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx1_camera.c:557:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/mx1_camera.c:594:static int mx1_camera_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/mx1_camera.c:597:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx1_camera.c:598:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx1_camera.c:604:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/mx1_camera.c:630:static int mx1_camera_reqbufs(struct soc_camera_device *icd,
media/platform/soc_camera/mx1_camera.c:651:static unsigned int mx1_camera_poll(struct file *file, poll_table *pt)
media/platform/soc_camera/mx1_camera.c:653:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/mx1_camera.c:668:static int mx1_camera_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/mx1_camera.c:672:	strlcpy(cap->card, "i.MX1/i.MXL Camera", sizeof(cap->card));
media/platform/soc_camera/mx1_camera.c:678:static struct soc_camera_host_ops mx1_soc_camera_host_ops = {
media/platform/soc_camera/mx1_camera.c:680:	.add		= mx1_camera_add_device,
media/platform/soc_camera/mx1_camera.c:681:	.remove		= mx1_camera_remove_device,
media/platform/soc_camera/mx1_camera.c:682:	.set_bus_param	= mx1_camera_set_bus_param,
media/platform/soc_camera/mx1_camera.c:683:	.set_fmt	= mx1_camera_set_fmt,
media/platform/soc_camera/mx1_camera.c:684:	.try_fmt	= mx1_camera_try_fmt,
media/platform/soc_camera/mx1_camera.c:685:	.init_videobuf	= mx1_camera_init_videobuf,
media/platform/soc_camera/mx1_camera.c:686:	.reqbufs	= mx1_camera_reqbufs,
media/platform/soc_camera/mx1_camera.c:687:	.poll		= mx1_camera_poll,
media/platform/soc_camera/mx1_camera.c:688:	.querycap	= mx1_camera_querycap,
media/platform/soc_camera/mx1_camera.c:695:static int __init mx1_camera_probe(struct platform_device *pdev)
media/platform/soc_camera/mx1_camera.c:697:	struct mx1_camera_dev *pcdev;
media/platform/soc_camera/mx1_camera.c:768:	imx_dma_setup_handlers(pcdev->dma_chan, mx1_camera_dma_irq, NULL,
media/platform/soc_camera/mx1_camera.c:779:		dev_err(&pdev->dev, "Camera interrupt register failed\n");
media/platform/soc_camera/mx1_camera.c:783:	set_fiq_handler(&mx1_camera_sof_fiq_start, &mx1_camera_sof_fiq_end -
media/platform/soc_camera/mx1_camera.c:784:						   &mx1_camera_sof_fiq_start);
media/platform/soc_camera/mx1_camera.c:797:	pcdev->soc_host.ops		= &mx1_soc_camera_host_ops;
media/platform/soc_camera/mx1_camera.c:801:	err = soc_camera_host_register(&pcdev->soc_host);
media/platform/soc_camera/mx1_camera.c:805:	dev_info(&pdev->dev, "MX1 Camera driver loaded\n");
media/platform/soc_camera/mx1_camera.c:827:static int __exit mx1_camera_remove(struct platform_device *pdev)
media/platform/soc_camera/mx1_camera.c:829:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/mx1_camera.c:830:	struct mx1_camera_dev *pcdev = container_of(soc_host,
media/platform/soc_camera/mx1_camera.c:831:					struct mx1_camera_dev, soc_host);
media/platform/soc_camera/mx1_camera.c:841:	soc_camera_host_unregister(soc_host);
media/platform/soc_camera/mx1_camera.c:850:	dev_info(&pdev->dev, "MX1 Camera driver unloaded\n");
media/platform/soc_camera/mx1_camera.c:855:static struct platform_driver mx1_camera_driver = {
media/platform/soc_camera/mx1_camera.c:859:	.remove		= __exit_p(mx1_camera_remove),
media/platform/soc_camera/mx1_camera.c:862:module_platform_driver_probe(mx1_camera_driver, mx1_camera_probe);
media/platform/soc_camera/mx1_camera.c:864:MODULE_DESCRIPTION("i.MX1/i.MXL SoC Camera Host driver");
media/platform/soc_camera/pxa_camera.c:2: * V4L2 Driver for PXA camera host
media/platform/soc_camera/pxa_camera.c:35:#include <media/soc_camera.h>
media/platform/soc_camera/pxa_camera.c:41:#include <linux/platform_data/camera-pxa.h>
media/platform/soc_camera/pxa_camera.c:44:#define PXA_CAM_DRV_NAME "pxa27x-camera"
media/platform/soc_camera/pxa_camera.c:46:/* Camera Interface */
media/platform/soc_camera/pxa_camera.c:62:#define CICR0_ENB	(1 << 28)	/* Camera interface enable */
media/platform/soc_camera/pxa_camera.c:63:#define CICR0_DIS	(1 << 27)	/* Camera interface disable */
media/platform/soc_camera/pxa_camera.c:124:#define CISR_CQD	(1 << 6)	/* Camera interface quick disable */
media/platform/soc_camera/pxa_camera.c:125:#define CISR_CDD	(1 << 5)	/* Camera interface disable done */
media/platform/soc_camera/pxa_camera.c:171:enum pxa_camera_active_dma {
media/platform/soc_camera/pxa_camera.c:193:	enum pxa_camera_active_dma	active_dma;
media/platform/soc_camera/pxa_camera.c:196:struct pxa_camera_dev {
media/platform/soc_camera/pxa_camera.c:197:	struct soc_camera_host	soc_host;
media/platform/soc_camera/pxa_camera.c:199:	 * PXA27x is only supposed to handle one camera on its Quick Capture
media/platform/soc_camera/pxa_camera.c:201:	 * one camera, they will have to modify this driver too
media/platform/soc_camera/pxa_camera.c:203:	struct soc_camera_device *icd;
media/platform/soc_camera/pxa_camera.c:212:	struct pxacamera_platform_data *pdata;
media/platform/soc_camera/pxa_camera.c:234:static const char *pxa_cam_driver_description = "PXA_Camera";
media/platform/soc_camera/pxa_camera.c:244:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/pxa_camera.c:260:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/pxa_camera.c:261:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:315: * @pcdev: pxa camera device
media/platform/soc_camera/pxa_camera.c:319: * @cibr: camera Receive Buffer Register
media/platform/soc_camera/pxa_camera.c:324: * Prepares the pxa dma descriptors to transfer one camera channel.
media/platform/soc_camera/pxa_camera.c:329:static int pxa_init_dma_channel(struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:410:static void pxa_videobuf_set_actdma(struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:420: *   Documentation/video4linux/pxa_camera.txt
media/platform/soc_camera/pxa_camera.c:421: * Please check also in pxa_camera_check_link_miss() to understand why DMA chain
media/platform/soc_camera/pxa_camera.c:427:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/pxa_camera.c:428:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:429:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:542: * @pcdev: pxa camera device
media/platform/soc_camera/pxa_camera.c:547:static void pxa_dma_start_channels(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:563:static void pxa_dma_stop_channels(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:574:static void pxa_dma_add_tail_buf(struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:594: * pxa_camera_start_capture - start video capturing
media/platform/soc_camera/pxa_camera.c:595: * @pcdev: camera device
media/platform/soc_camera/pxa_camera.c:601:static void pxa_camera_start_capture(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:612:static void pxa_camera_stop_capture(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:629:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/pxa_camera.c:630:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:631:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:643:		pxa_camera_start_capture(pcdev);
media/platform/soc_camera/pxa_camera.c:651:	struct soc_camera_device *icd = vq->priv_data;
media/platform/soc_camera/pxa_camera.c:676:static void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:682:	/* _init is used to debug races, see comment in pxa_camera_reqbufs() */
media/platform/soc_camera/pxa_camera.c:692:		pxa_camera_stop_capture(pcdev);
media/platform/soc_camera/pxa_camera.c:703: * pxa_camera_check_link_miss - check missed DMA linking
media/platform/soc_camera/pxa_camera.c:704: * @pcdev: camera device
media/platform/soc_camera/pxa_camera.c:714: *   Documentation/video4linux/pxa_camera.txt
media/platform/soc_camera/pxa_camera.c:718:static void pxa_camera_check_link_miss(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:729:		pxa_camera_start_capture(pcdev);
media/platform/soc_camera/pxa_camera.c:732:static void pxa_camera_dma_irq(int channel, struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:733:			       enum pxa_camera_active_dma act_dma)
media/platform/soc_camera/pxa_camera.c:738:	u32 status, camera_status, overrun;
media/platform/soc_camera/pxa_camera.c:746:	camera_status = __raw_readl(pcdev->base + CISR);
media/platform/soc_camera/pxa_camera.c:790:		if (camera_status & overrun &&
media/platform/soc_camera/pxa_camera.c:793:				camera_status);
media/platform/soc_camera/pxa_camera.c:794:			pxa_camera_stop_capture(pcdev);
media/platform/soc_camera/pxa_camera.c:795:			pxa_camera_start_capture(pcdev);
media/platform/soc_camera/pxa_camera.c:800:			pxa_camera_wakeup(pcdev, vb, buf);
media/platform/soc_camera/pxa_camera.c:801:			pxa_camera_check_link_miss(pcdev);
media/platform/soc_camera/pxa_camera.c:809:static void pxa_camera_dma_irq_y(int channel, void *data)
media/platform/soc_camera/pxa_camera.c:811:	struct pxa_camera_dev *pcdev = data;
media/platform/soc_camera/pxa_camera.c:812:	pxa_camera_dma_irq(channel, pcdev, DMA_Y);
media/platform/soc_camera/pxa_camera.c:815:static void pxa_camera_dma_irq_u(int channel, void *data)
media/platform/soc_camera/pxa_camera.c:817:	struct pxa_camera_dev *pcdev = data;
media/platform/soc_camera/pxa_camera.c:818:	pxa_camera_dma_irq(channel, pcdev, DMA_U);
media/platform/soc_camera/pxa_camera.c:821:static void pxa_camera_dma_irq_v(int channel, void *data)
media/platform/soc_camera/pxa_camera.c:823:	struct pxa_camera_dev *pcdev = data;
media/platform/soc_camera/pxa_camera.c:824:	pxa_camera_dma_irq(channel, pcdev, DMA_V);
media/platform/soc_camera/pxa_camera.c:834:static void pxa_camera_init_videobuf(struct videobuf_queue *q,
media/platform/soc_camera/pxa_camera.c:835:			      struct soc_camera_device *icd)
media/platform/soc_camera/pxa_camera.c:837:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:838:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:850:			    struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:870:	if (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)
media/platform/soc_camera/pxa_camera.c:879:static void recalculate_fifo_timeout(struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:888:static void pxa_camera_activate(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:895:	if (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)
media/platform/soc_camera/pxa_camera.c:897:	if (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)
media/platform/soc_camera/pxa_camera.c:899:	if (pcdev->platform_flags & PXA_CAMERA_PCP)
media/platform/soc_camera/pxa_camera.c:901:	if (pcdev->platform_flags & PXA_CAMERA_HSP)
media/platform/soc_camera/pxa_camera.c:903:	if (pcdev->platform_flags & PXA_CAMERA_VSP)
media/platform/soc_camera/pxa_camera.c:908:	if (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)
media/platform/soc_camera/pxa_camera.c:918:static void pxa_camera_deactivate(struct pxa_camera_dev *pcdev)
media/platform/soc_camera/pxa_camera.c:923:static irqreturn_t pxa_camera_irq(int irq, void *data)
media/platform/soc_camera/pxa_camera.c:925:	struct pxa_camera_dev *pcdev = data;
media/platform/soc_camera/pxa_camera.c:932:		"Camera interrupt status 0x%lx\n", status);
media/platform/soc_camera/pxa_camera.c:961: * there can be only one camera on PXA quick capture interface
media/platform/soc_camera/pxa_camera.c:964:static int pxa_camera_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/pxa_camera.c:966:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:967:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:972:	pxa_camera_activate(pcdev);
media/platform/soc_camera/pxa_camera.c:976:	dev_info(icd->parent, "PXA Camera driver attached to camera %d\n",
media/platform/soc_camera/pxa_camera.c:983:static void pxa_camera_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/pxa_camera.c:985:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:986:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:990:	dev_info(icd->parent, "PXA Camera driver detached from camera %d\n",
media/platform/soc_camera/pxa_camera.c:1001:	pxa_camera_deactivate(pcdev);
media/platform/soc_camera/pxa_camera.c:1006:static int test_platform_param(struct pxa_camera_dev *pcdev,
media/platform/soc_camera/pxa_camera.c:1014:	*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?
media/platform/soc_camera/pxa_camera.c:1031:static void pxa_camera_setup_cicr(struct soc_camera_device *icd,
media/platform/soc_camera/pxa_camera.c:1034:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:1035:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1036:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1067:	if (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)
media/platform/soc_camera/pxa_camera.c:1069:	if (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)
media/platform/soc_camera/pxa_camera.c:1121:	cicr0 = (cicr0 & CICR0_ENB) | (pcdev->platform_flags & PXA_CAMERA_MASTER ?
media/platform/soc_camera/pxa_camera.c:1127:static int pxa_camera_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/pxa_camera.c:1129:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1130:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:1131:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1149:				 "Flags incompatible: camera 0x%x, host 0x%lx\n",
media/platform/soc_camera/pxa_camera.c:1164:		if (pcdev->platform_flags & PXA_CAMERA_HSP)
media/platform/soc_camera/pxa_camera.c:1172:		if (pcdev->platform_flags & PXA_CAMERA_VSP)
media/platform/soc_camera/pxa_camera.c:1180:		if (pcdev->platform_flags & PXA_CAMERA_PCP)
media/platform/soc_camera/pxa_camera.c:1189:		dev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",
media/platform/soc_camera/pxa_camera.c:1196:	pxa_camera_setup_cicr(icd, common_flags, pixfmt);
media/platform/soc_camera/pxa_camera.c:1201:static int pxa_camera_try_bus_param(struct soc_camera_device *icd,
media/platform/soc_camera/pxa_camera.c:1204:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1205:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/pxa_camera.c:1206:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1220:				 "Flags incompatible: camera 0x%x, host 0x%lx\n",
media/platform/soc_camera/pxa_camera.c:1231:static const struct soc_mbus_pixelfmt pxa_camera_formats[] = {
media/platform/soc_camera/pxa_camera.c:1243:static bool pxa_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)
media/platform/soc_camera/pxa_camera.c:1252:static int pxa_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,
media/platform/soc_camera/pxa_camera.c:1253:				  struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/pxa_camera.c:1255:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1274:	ret = pxa_camera_try_bus_param(icd, fmt->bits_per_sample);
media/platform/soc_camera/pxa_camera.c:1292:			xlate->host_fmt	= &pxa_camera_formats[0];
media/platform/soc_camera/pxa_camera.c:1296:				pxa_camera_formats[0].name, code);
media/platform/soc_camera/pxa_camera.c:1308:		if (!pxa_camera_packing_supported(fmt))
media/platform/soc_camera/pxa_camera.c:1327:static void pxa_camera_put_formats(struct soc_camera_device *icd)
media/platform/soc_camera/pxa_camera.c:1333:static int pxa_camera_check_frame(u32 width, u32 height)
media/platform/soc_camera/pxa_camera.c:1340:static int pxa_camera_set_crop(struct soc_camera_device *icd,
media/platform/soc_camera/pxa_camera.c:1345:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/pxa_camera.c:1346:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1347:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1348:	struct soc_camera_sense sense = {
media/platform/soc_camera/pxa_camera.c:1358:	if (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)
media/platform/soc_camera/pxa_camera.c:1375:	if (pxa_camera_check_frame(mf.width, mf.height)) {
media/platform/soc_camera/pxa_camera.c:1377:		 * Camera cropping produced a frame beyond our capabilities.
media/platform/soc_camera/pxa_camera.c:1387:		if (pxa_camera_check_frame(mf.width, mf.height)) {
media/platform/soc_camera/pxa_camera.c:1397:				"pixel clock %lu set by the camera too high!",
media/platform/soc_camera/pxa_camera.c:1407:	pxa_camera_setup_cicr(icd, cam->flags, fourcc);
media/platform/soc_camera/pxa_camera.c:1412:static int pxa_camera_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/pxa_camera.c:1416:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/pxa_camera.c:1417:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1418:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1419:	const struct soc_camera_format_xlate *xlate = NULL;
media/platform/soc_camera/pxa_camera.c:1420:	struct soc_camera_sense sense = {
media/platform/soc_camera/pxa_camera.c:1428:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/pxa_camera.c:1435:	if (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)
media/platform/soc_camera/pxa_camera.c:1455:	} else if (pxa_camera_check_frame(mf.width, mf.height)) {
media/platform/soc_camera/pxa_camera.c:1457:			 "Camera driver produced an unsupported frame %dx%d\n",
media/platform/soc_camera/pxa_camera.c:1463:				"pixel clock %lu set by the camera too high!",
media/platform/soc_camera/pxa_camera.c:1482:static int pxa_camera_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/pxa_camera.c:1485:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/pxa_camera.c:1486:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/pxa_camera.c:1492:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/pxa_camera.c:1539:static int pxa_camera_reqbufs(struct soc_camera_device *icd,
media/platform/soc_camera/pxa_camera.c:1560:static unsigned int pxa_camera_poll(struct file *file, poll_table *pt)
media/platform/soc_camera/pxa_camera.c:1562:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/pxa_camera.c:1577:static int pxa_camera_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/pxa_camera.c:1587:static int pxa_camera_suspend(struct device *dev)
media/platform/soc_camera/pxa_camera.c:1589:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/pxa_camera.c:1590:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1600:		struct v4l2_subdev *sd = soc_camera_to_subdev(pcdev->icd);
media/platform/soc_camera/pxa_camera.c:1609:static int pxa_camera_resume(struct device *dev)
media/platform/soc_camera/pxa_camera.c:1611:	struct soc_camera_host *ici = to_soc_camera_host(dev);
media/platform/soc_camera/pxa_camera.c:1612:	struct pxa_camera_dev *pcdev = ici->priv;
media/platform/soc_camera/pxa_camera.c:1626:		struct v4l2_subdev *sd = soc_camera_to_subdev(pcdev->icd);
media/platform/soc_camera/pxa_camera.c:1634:		pxa_camera_start_capture(pcdev);
media/platform/soc_camera/pxa_camera.c:1639:static struct soc_camera_host_ops pxa_soc_camera_host_ops = {
media/platform/soc_camera/pxa_camera.c:1641:	.add		= pxa_camera_add_device,
media/platform/soc_camera/pxa_camera.c:1642:	.remove		= pxa_camera_remove_device,
media/platform/soc_camera/pxa_camera.c:1643:	.set_crop	= pxa_camera_set_crop,
media/platform/soc_camera/pxa_camera.c:1644:	.get_formats	= pxa_camera_get_formats,
media/platform/soc_camera/pxa_camera.c:1645:	.put_formats	= pxa_camera_put_formats,
media/platform/soc_camera/pxa_camera.c:1646:	.set_fmt	= pxa_camera_set_fmt,
media/platform/soc_camera/pxa_camera.c:1647:	.try_fmt	= pxa_camera_try_fmt,
media/platform/soc_camera/pxa_camera.c:1648:	.init_videobuf	= pxa_camera_init_videobuf,
media/platform/soc_camera/pxa_camera.c:1649:	.reqbufs	= pxa_camera_reqbufs,
media/platform/soc_camera/pxa_camera.c:1650:	.poll		= pxa_camera_poll,
media/platform/soc_camera/pxa_camera.c:1651:	.querycap	= pxa_camera_querycap,
media/platform/soc_camera/pxa_camera.c:1652:	.set_bus_param	= pxa_camera_set_bus_param,
media/platform/soc_camera/pxa_camera.c:1655:static int pxa_camera_probe(struct platform_device *pdev)
media/platform/soc_camera/pxa_camera.c:1657:	struct pxa_camera_dev *pcdev;
media/platform/soc_camera/pxa_camera.c:1682:	if (!(pcdev->platform_flags & (PXA_CAMERA_DATAWIDTH_8 |
media/platform/soc_camera/pxa_camera.c:1683:			PXA_CAMERA_DATAWIDTH_9 | PXA_CAMERA_DATAWIDTH_10))) {
media/platform/soc_camera/pxa_camera.c:1690:		pcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;
media/platform/soc_camera/pxa_camera.c:1692:	if (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_8)
media/platform/soc_camera/pxa_camera.c:1694:	if (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_9)
media/platform/soc_camera/pxa_camera.c:1696:	if (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_10)
media/platform/soc_camera/pxa_camera.c:1723:			      pxa_camera_dma_irq_y, pcdev);
media/platform/soc_camera/pxa_camera.c:1732:			      pxa_camera_dma_irq_u, pcdev);
media/platform/soc_camera/pxa_camera.c:1741:			      pxa_camera_dma_irq_v, pcdev);
media/platform/soc_camera/pxa_camera.c:1754:	err = devm_request_irq(&pdev->dev, pcdev->irq, pxa_camera_irq, 0,
media/platform/soc_camera/pxa_camera.c:1757:		dev_err(&pdev->dev, "Camera interrupt register failed\n");
media/platform/soc_camera/pxa_camera.c:1762:	pcdev->soc_host.ops		= &pxa_soc_camera_host_ops;
media/platform/soc_camera/pxa_camera.c:1767:	err = soc_camera_host_register(&pcdev->soc_host);
media/platform/soc_camera/pxa_camera.c:1782:static int pxa_camera_remove(struct platform_device *pdev)
media/platform/soc_camera/pxa_camera.c:1784:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/pxa_camera.c:1785:	struct pxa_camera_dev *pcdev = container_of(soc_host,
media/platform/soc_camera/pxa_camera.c:1786:					struct pxa_camera_dev, soc_host);
media/platform/soc_camera/pxa_camera.c:1792:	soc_camera_host_unregister(soc_host);
media/platform/soc_camera/pxa_camera.c:1794:	dev_info(&pdev->dev, "PXA Camera driver unloaded\n");
media/platform/soc_camera/pxa_camera.c:1799:static const struct dev_pm_ops pxa_camera_pm = {
media/platform/soc_camera/pxa_camera.c:1800:	.suspend	= pxa_camera_suspend,
media/platform/soc_camera/pxa_camera.c:1801:	.resume		= pxa_camera_resume,
media/platform/soc_camera/pxa_camera.c:1804:static struct platform_driver pxa_camera_driver = {
media/platform/soc_camera/pxa_camera.c:1807:		.pm	= &pxa_camera_pm,
media/platform/soc_camera/pxa_camera.c:1809:	.probe		= pxa_camera_probe,
media/platform/soc_camera/pxa_camera.c:1810:	.remove		= pxa_camera_remove,
media/platform/soc_camera/pxa_camera.c:1813:module_platform_driver(pxa_camera_driver);
media/platform/soc_camera/pxa_camera.c:1815:MODULE_DESCRIPTION("PXA27x SoC Camera Host driver");
media/platform/soc_camera/atmel-isi.c:26:#include <media/soc_camera.h>
media/platform/soc_camera/atmel-isi.c:95:	/* ISI_MCK, feed to camera sensor to generate pixel clock */
media/platform/soc_camera/atmel-isi.c:105:	struct soc_camera_device	*icd;
media/platform/soc_camera/atmel-isi.c:106:	struct soc_camera_host		soc_host;
media/platform/soc_camera/atmel-isi.c:232:	 * pixel clock from the camera.
media/platform/soc_camera/atmel-isi.c:259:	struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
media/platform/soc_camera/atmel-isi.c:260:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:307:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/atmel-isi.c:309:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:349:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/atmel-isi.c:350:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:389:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/atmel-isi.c:390:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:408:	struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
media/platform/soc_camera/atmel-isi.c:409:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:453:	struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
media/platform/soc_camera/atmel-isi.c:454:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:501:	.wait_prepare		= soc_camera_unlock,
media/platform/soc_camera/atmel-isi.c:502:	.wait_finish		= soc_camera_lock,
media/platform/soc_camera/atmel-isi.c:506:	SOC camera operations for the device
media/platform/soc_camera/atmel-isi.c:508:static int isi_camera_init_videobuf(struct vb2_queue *q,
media/platform/soc_camera/atmel-isi.c:509:				     struct soc_camera_device *icd)
media/platform/soc_camera/atmel-isi.c:522:static int isi_camera_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/atmel-isi.c:525:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:527:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/atmel-isi.c:528:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/atmel-isi.c:533:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/atmel-isi.c:572:static int isi_camera_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/atmel-isi.c:575:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/atmel-isi.c:576:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/atmel-isi.c:582:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/atmel-isi.c:624:static const struct soc_mbus_pixelfmt isi_camera_formats[] = {
media/platform/soc_camera/atmel-isi.c:636:static bool isi_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)
media/platform/soc_camera/atmel-isi.c:654:static int isi_camera_try_bus_param(struct soc_camera_device *icd,
media/platform/soc_camera/atmel-isi.c:657:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/atmel-isi.c:658:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:670:				 "Flags incompatible: camera 0x%x, host 0x%x\n",
media/platform/soc_camera/atmel-isi.c:684:static int isi_camera_get_formats(struct soc_camera_device *icd,
media/platform/soc_camera/atmel-isi.c:686:				  struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/atmel-isi.c:688:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/atmel-isi.c:692:	/* soc camera host format */
media/platform/soc_camera/atmel-isi.c:708:	ret = isi_camera_try_bus_param(icd, fmt->bits_per_sample);
media/platform/soc_camera/atmel-isi.c:722:			xlate->host_fmt	= &isi_camera_formats[0];
media/platform/soc_camera/atmel-isi.c:726:				isi_camera_formats[0].name, code);
media/platform/soc_camera/atmel-isi.c:730:		if (!isi_camera_packing_supported(fmt))
media/platform/soc_camera/atmel-isi.c:750:static int isi_camera_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/atmel-isi.c:752:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:770:	dev_dbg(icd->parent, "Atmel ISI Camera driver attached to camera %d\n",
media/platform/soc_camera/atmel-isi.c:775:static void isi_camera_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/atmel-isi.c:777:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:786:	dev_dbg(icd->parent, "Atmel ISI Camera driver detached from camera %d\n",
media/platform/soc_camera/atmel-isi.c:790:static unsigned int isi_camera_poll(struct file *file, poll_table *pt)
media/platform/soc_camera/atmel-isi.c:792:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/atmel-isi.c:797:static int isi_camera_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/atmel-isi.c:807:static int isi_camera_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/atmel-isi.c:809:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/atmel-isi.c:810:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/atmel-isi.c:823:				 "Flags incompatible: camera 0x%x, host 0x%x\n",
media/platform/soc_camera/atmel-isi.c:863:		dev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",
media/platform/soc_camera/atmel-isi.c:887:static struct soc_camera_host_ops isi_soc_camera_host_ops = {
media/platform/soc_camera/atmel-isi.c:889:	.add		= isi_camera_add_device,
media/platform/soc_camera/atmel-isi.c:890:	.remove		= isi_camera_remove_device,
media/platform/soc_camera/atmel-isi.c:891:	.set_fmt	= isi_camera_set_fmt,
media/platform/soc_camera/atmel-isi.c:892:	.try_fmt	= isi_camera_try_fmt,
media/platform/soc_camera/atmel-isi.c:893:	.get_formats	= isi_camera_get_formats,
media/platform/soc_camera/atmel-isi.c:894:	.init_videobuf2	= isi_camera_init_videobuf,
media/platform/soc_camera/atmel-isi.c:895:	.poll		= isi_camera_poll,
media/platform/soc_camera/atmel-isi.c:896:	.querycap	= isi_camera_querycap,
media/platform/soc_camera/atmel-isi.c:897:	.set_bus_param	= isi_camera_set_bus_param,
media/platform/soc_camera/atmel-isi.c:903:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/atmel-isi.c:908:	soc_camera_host_unregister(soc_host);
media/platform/soc_camera/atmel-isi.c:933:	struct soc_camera_host *soc_host;
media/platform/soc_camera/atmel-isi.c:1037:	soc_host->drv_name	= "isi-camera";
media/platform/soc_camera/atmel-isi.c:1038:	soc_host->ops		= &isi_soc_camera_host_ops;
media/platform/soc_camera/atmel-isi.c:1043:	ret = soc_camera_host_register(soc_host);
media/platform/soc_camera/atmel-isi.c:1045:		dev_err(&pdev->dev, "Unable to register soc camera host\n");
media/platform/soc_camera/atmel-isi.c:1046:		goto err_register_soc_camera_host;
media/platform/soc_camera/atmel-isi.c:1050:err_register_soc_camera_host:
media/platform/soc_camera/mx3_camera.c:2: * V4L2 Driver for i.MX3x camera host
media/platform/soc_camera/mx3_camera.c:25:#include <media/soc_camera.h>
media/platform/soc_camera/mx3_camera.c:28:#include <linux/platform_data/camera-mx3.h>
media/platform/soc_camera/mx3_camera.c:31:#define MX3_CAM_DRV_NAME "mx3-camera"
media/platform/soc_camera/mx3_camera.c:64:struct mx3_camera_buffer {
media/platform/soc_camera/mx3_camera.c:77: * struct mx3_camera_dev - i.MX3x camera (CSI) object
media/platform/soc_camera/mx3_camera.c:78: * @dev:		camera device, to which the coherent buffer is attached
media/platform/soc_camera/mx3_camera.c:79: * @icd:		currently attached camera sensor
media/platform/soc_camera/mx3_camera.c:91:struct mx3_camera_dev {
media/platform/soc_camera/mx3_camera.c:93:	 * i.MX3x is only supposed to handle one camera on its Camera Sensor
media/platform/soc_camera/mx3_camera.c:95:	 * camera _simultaneously_, they will have to modify this driver too
media/platform/soc_camera/mx3_camera.c:97:	struct soc_camera_device *icd;
media/platform/soc_camera/mx3_camera.c:102:	struct mx3_camera_pdata	*pdata;
media/platform/soc_camera/mx3_camera.c:110:	struct mx3_camera_buffer *active;
media/platform/soc_camera/mx3_camera.c:119:	struct soc_camera_host	soc_host;
media/platform/soc_camera/mx3_camera.c:123:	struct mx3_camera_dev	*mx3_cam;
media/platform/soc_camera/mx3_camera.c:127:static u32 csi_reg_read(struct mx3_camera_dev *mx3, off_t reg)
media/platform/soc_camera/mx3_camera.c:132:static void csi_reg_write(struct mx3_camera_dev *mx3, u32 value, off_t reg)
media/platform/soc_camera/mx3_camera.c:137:static struct mx3_camera_buffer *to_mx3_vb(struct vb2_buffer *vb)
media/platform/soc_camera/mx3_camera.c:139:	return container_of(vb, struct mx3_camera_buffer, vb);
media/platform/soc_camera/mx3_camera.c:148:	struct mx3_camera_dev *mx3_cam = ichannel->client;
media/platform/soc_camera/mx3_camera.c:156:		struct mx3_camera_buffer *buf = to_mx3_vb(vb);
media/platform/soc_camera/mx3_camera.c:177:				     struct mx3_camera_buffer, queue);
media/platform/soc_camera/mx3_camera.c:193:	struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
media/platform/soc_camera/mx3_camera.c:194:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:195:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:201:		const struct soc_camera_format_xlate *xlate = soc_camera_xlate_by_fourcc(icd,
media/platform/soc_camera/mx3_camera.c:261:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/mx3_camera.c:262:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:263:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:264:	struct mx3_camera_buffer *buf = to_mx3_vb(vb);
media/platform/soc_camera/mx3_camera.c:362:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/mx3_camera.c:363:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:364:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:365:	struct mx3_camera_buffer *buf = to_mx3_vb(vb);
media/platform/soc_camera/mx3_camera.c:395:	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
media/platform/soc_camera/mx3_camera.c:396:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:397:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:398:	struct mx3_camera_buffer *buf = to_mx3_vb(vb);
media/platform/soc_camera/mx3_camera.c:413:	struct soc_camera_device *icd = soc_camera_from_vb2q(q);
media/platform/soc_camera/mx3_camera.c:414:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:415:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:417:	struct mx3_camera_buffer *buf, *tmp;
media/platform/soc_camera/mx3_camera.c:444:	.wait_prepare	= soc_camera_unlock,
media/platform/soc_camera/mx3_camera.c:445:	.wait_finish	= soc_camera_lock,
media/platform/soc_camera/mx3_camera.c:449:static int mx3_camera_init_videobuf(struct vb2_queue *q,
media/platform/soc_camera/mx3_camera.c:450:				     struct soc_camera_device *icd)
media/platform/soc_camera/mx3_camera.c:457:	q->buf_struct_size = sizeof(struct mx3_camera_buffer);
media/platform/soc_camera/mx3_camera.c:464:static void mx3_camera_activate(struct mx3_camera_dev *mx3_cam,
media/platform/soc_camera/mx3_camera.c:465:				struct soc_camera_device *icd)
media/platform/soc_camera/mx3_camera.c:482:	if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_15)
media/platform/soc_camera/mx3_camera.c:484:	else if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_10)
media/platform/soc_camera/mx3_camera.c:486:	else if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_8)
media/platform/soc_camera/mx3_camera.c:488:	else/* if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_4)*/
media/platform/soc_camera/mx3_camera.c:491:	if (mx3_cam->platform_flags & MX3_CAMERA_CLK_SRC)
media/platform/soc_camera/mx3_camera.c:493:	if (mx3_cam->platform_flags & MX3_CAMERA_EXT_VSYNC)
media/platform/soc_camera/mx3_camera.c:495:	if (mx3_cam->platform_flags & MX3_CAMERA_DP)
media/platform/soc_camera/mx3_camera.c:497:	if (mx3_cam->platform_flags & MX3_CAMERA_PCP)
media/platform/soc_camera/mx3_camera.c:499:	if (mx3_cam->platform_flags & MX3_CAMERA_HSP)
media/platform/soc_camera/mx3_camera.c:501:	if (mx3_cam->platform_flags & MX3_CAMERA_VSP)
media/platform/soc_camera/mx3_camera.c:515:static int mx3_camera_add_device(struct soc_camera_device *icd)
media/platform/soc_camera/mx3_camera.c:517:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:518:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:523:	mx3_camera_activate(mx3_cam, icd);
media/platform/soc_camera/mx3_camera.c:528:	dev_info(icd->parent, "MX3 Camera driver attached to camera %d\n",
media/platform/soc_camera/mx3_camera.c:535:static void mx3_camera_remove_device(struct soc_camera_device *icd)
media/platform/soc_camera/mx3_camera.c:537:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:538:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:552:	dev_info(icd->parent, "MX3 Camera driver detached from camera %d\n",
media/platform/soc_camera/mx3_camera.c:556:static int test_platform_param(struct mx3_camera_dev *mx3_cam,
media/platform/soc_camera/mx3_camera.c:569:	 * camera interface only works in master mode, i.e., uses HSYNC and
media/platform/soc_camera/mx3_camera.c:585:static int mx3_camera_try_bus_param(struct soc_camera_device *icd,
media/platform/soc_camera/mx3_camera.c:588:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx3_camera.c:589:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:590:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:606:				 "Flags incompatible: camera 0x%x, host 0x%lx\n",
media/platform/soc_camera/mx3_camera.c:620:	struct mx3_camera_pdata *pdata;
media/platform/soc_camera/mx3_camera.c:634:static const struct soc_mbus_pixelfmt mx3_camera_formats[] = {
media/platform/soc_camera/mx3_camera.c:653:static bool mx3_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)
media/platform/soc_camera/mx3_camera.c:662:static int mx3_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,
media/platform/soc_camera/mx3_camera.c:663:				  struct soc_camera_format_xlate *xlate)
media/platform/soc_camera/mx3_camera.c:665:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx3_camera.c:684:	ret = mx3_camera_try_bus_param(icd, fmt->bits_per_sample);
media/platform/soc_camera/mx3_camera.c:692:			xlate->host_fmt	= &mx3_camera_formats[0];
media/platform/soc_camera/mx3_camera.c:696:				mx3_camera_formats[0].name, code);
media/platform/soc_camera/mx3_camera.c:702:			xlate->host_fmt	= &mx3_camera_formats[1];
media/platform/soc_camera/mx3_camera.c:706:				mx3_camera_formats[1].name, code);
media/platform/soc_camera/mx3_camera.c:710:		if (!mx3_camera_packing_supported(fmt))
media/platform/soc_camera/mx3_camera.c:730:static void configure_geometry(struct mx3_camera_dev *mx3_cam,
media/platform/soc_camera/mx3_camera.c:764:static int acquire_dma_channel(struct mx3_camera_dev *mx3_cam)
media/platform/soc_camera/mx3_camera.c:800: * default g_crop and cropcap from soc_camera.c
media/platform/soc_camera/mx3_camera.c:802:static int mx3_camera_set_crop(struct soc_camera_device *icd,
media/platform/soc_camera/mx3_camera.c:807:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:808:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:809:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx3_camera.c:813:	soc_camera_limit_side(&rect->left, &rect->width, 0, 2, 4096);
media/platform/soc_camera/mx3_camera.c:814:	soc_camera_limit_side(&rect->top, &rect->height, 0, 2, 4096);
media/platform/soc_camera/mx3_camera.c:849:static int mx3_camera_set_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/mx3_camera.c:852:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:853:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:854:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx3_camera.c:855:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx3_camera.c:860:	xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
media/platform/soc_camera/mx3_camera.c:909:static int mx3_camera_try_fmt(struct soc_camera_device *icd,
media/platform/soc_camera/mx3_camera.c:912:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx3_camera.c:913:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx3_camera.c:919:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/mx3_camera.c:961:static int mx3_camera_reqbufs(struct soc_camera_device *icd,
media/platform/soc_camera/mx3_camera.c:967:static unsigned int mx3_camera_poll(struct file *file, poll_table *pt)
media/platform/soc_camera/mx3_camera.c:969:	struct soc_camera_device *icd = file->private_data;
media/platform/soc_camera/mx3_camera.c:974:static int mx3_camera_querycap(struct soc_camera_host *ici,
media/platform/soc_camera/mx3_camera.c:978:	strlcpy(cap->card, "i.MX3x Camera", sizeof(cap->card));
media/platform/soc_camera/mx3_camera.c:984:static int mx3_camera_set_bus_param(struct soc_camera_device *icd)
media/platform/soc_camera/mx3_camera.c:986:	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
media/platform/soc_camera/mx3_camera.c:987:	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
media/platform/soc_camera/mx3_camera.c:988:	struct mx3_camera_dev *mx3_cam = ici->priv;
media/platform/soc_camera/mx3_camera.c:996:	const struct soc_camera_format_xlate *xlate;
media/platform/soc_camera/mx3_camera.c:1003:	xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
media/platform/soc_camera/mx3_camera.c:1023:				 "Flags incompatible: camera 0x%x, host 0x%lx\n",
media/platform/soc_camera/mx3_camera.c:1039:		if (mx3_cam->platform_flags & MX3_CAMERA_HSP)
media/platform/soc_camera/mx3_camera.c:1047:		if (mx3_cam->platform_flags & MX3_CAMERA_VSP)
media/platform/soc_camera/mx3_camera.c:1055:		if (mx3_cam->platform_flags & MX3_CAMERA_DP)
media/platform/soc_camera/mx3_camera.c:1063:		if (mx3_cam->platform_flags & MX3_CAMERA_PCP)
media/platform/soc_camera/mx3_camera.c:1072:		dev_dbg(dev, "camera s_mbus_config(0x%lx) returned %d\n",
media/platform/soc_camera/mx3_camera.c:1093:	/* This has been set in mx3_camera_activate(), but we clear it above */
media/platform/soc_camera/mx3_camera.c:1132:static struct soc_camera_host_ops mx3_soc_camera_host_ops = {
media/platform/soc_camera/mx3_camera.c:1134:	.add		= mx3_camera_add_device,
media/platform/soc_camera/mx3_camera.c:1135:	.remove		= mx3_camera_remove_device,
media/platform/soc_camera/mx3_camera.c:1136:	.set_crop	= mx3_camera_set_crop,
media/platform/soc_camera/mx3_camera.c:1137:	.set_fmt	= mx3_camera_set_fmt,
media/platform/soc_camera/mx3_camera.c:1138:	.try_fmt	= mx3_camera_try_fmt,
media/platform/soc_camera/mx3_camera.c:1139:	.get_formats	= mx3_camera_get_formats,
media/platform/soc_camera/mx3_camera.c:1140:	.init_videobuf2	= mx3_camera_init_videobuf,
media/platform/soc_camera/mx3_camera.c:1141:	.reqbufs	= mx3_camera_reqbufs,
media/platform/soc_camera/mx3_camera.c:1142:	.poll		= mx3_camera_poll,
media/platform/soc_camera/mx3_camera.c:1143:	.querycap	= mx3_camera_querycap,
media/platform/soc_camera/mx3_camera.c:1144:	.set_bus_param	= mx3_camera_set_bus_param,
media/platform/soc_camera/mx3_camera.c:1147:static int mx3_camera_probe(struct platform_device *pdev)
media/platform/soc_camera/mx3_camera.c:1149:	struct mx3_camera_dev *mx3_cam;
media/platform/soc_camera/mx3_camera.c:1153:	struct soc_camera_host *soc_host;
media/platform/soc_camera/mx3_camera.c:1163:		dev_err(&pdev->dev, "Could not allocate mx3 camera object\n");
media/platform/soc_camera/mx3_camera.c:1176:	if (!(mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_MASK)) {
media/platform/soc_camera/mx3_camera.c:1183:		mx3_cam->platform_flags |= MX3_CAMERA_DATAWIDTH_8;
media/platform/soc_camera/mx3_camera.c:1185:	if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_4)
media/platform/soc_camera/mx3_camera.c:1187:	if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_8)
media/platform/soc_camera/mx3_camera.c:1189:	if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_10)
media/platform/soc_camera/mx3_camera.c:1191:	if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_15)
media/platform/soc_camera/mx3_camera.c:1217:	soc_host->ops		= &mx3_soc_camera_host_ops;
media/platform/soc_camera/mx3_camera.c:1228:	err = soc_camera_host_register(soc_host);
media/platform/soc_camera/mx3_camera.c:1250:static int mx3_camera_remove(struct platform_device *pdev)
media/platform/soc_camera/mx3_camera.c:1252:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
media/platform/soc_camera/mx3_camera.c:1253:	struct mx3_camera_dev *mx3_cam = container_of(soc_host,
media/platform/soc_camera/mx3_camera.c:1254:					struct mx3_camera_dev, soc_host);
media/platform/soc_camera/mx3_camera.c:1258:	soc_camera_host_unregister(soc_host);
media/platform/soc_camera/mx3_camera.c:1278:static struct platform_driver mx3_camera_driver = {
media/platform/soc_camera/mx3_camera.c:1282:	.probe		= mx3_camera_probe,
media/platform/soc_camera/mx3_camera.c:1283:	.remove		= mx3_camera_remove,
media/platform/soc_camera/mx3_camera.c:1286:module_platform_driver(mx3_camera_driver);
media/platform/soc_camera/mx3_camera.c:1288:MODULE_DESCRIPTION("i.MX3x SoC Camera Host driver");
media/platform/omap24xxcam-dma.c:84:			    | CAMDMA_CCR_SYNCHRO_CAMERA);
media/platform/omap24xxcam-dma.c:124:			    | CAMDMA_CCR_SYNCHRO_CAMERA);
media/platform/omap24xxcam-dma.c:193:/* Start a DMA transfer from the camera to memory.
media/platform/omap24xxcam-dma.c:297:/* Camera DMA interrupt service routine. */
media/platform/omap24xxcam-dma.c:311:		/* A camera DMA interrupt occurred while all channels
media/platform/omap24xxcam-dma.c:498: * Queue a scatter-gather DMA transfer from the camera to memory.
media/platform/s3c-camif/camif-regs.c:105:/* Set camera input pixel format and resolution */
media/platform/s3c-camif/camif-regs.c:130:/* Set the camera host input window offsets (cropping) */
media/platform/s3c-camif/camif-regs.c:131:void camif_hw_set_camera_crop(struct camif_dev *camif)
media/platform/s3c-camif/camif-regs.c:170:void camif_hw_set_camera_bus(struct camif_dev *camif)
media/platform/s3c-camif/camif-regs.c:312:		/* We currently support only YCbCr 4:2:2 at the camera input */
media/platform/s3c-camif/camif-core.c:2: * s3c24xx/s3c64xx SoC series Camera Interface (CAMIF) driver
media/platform/s3c-camif/camif-core.c:43:	/* CAMIF / external camera sensor master clock */
media/platform/s3c-camif/camif-core.c:44:	[CLK_CAM]	= "camera",
media/platform/s3c-camif/camif-core.c:378: * that can source data from memory or the common camera input frontend.
media/platform/s3c-camif/camif-core.c:660:MODULE_DESCRIPTION("S3C24XX/S3C64XX SoC camera interface driver");
media/platform/s3c-camif/camif-capture.c:2: * s3c24xx/s3c64xx SoC series Camera Interface (CAMIF) driver
media/platform/s3c-camif/camif-capture.c:77:	camif_hw_set_camera_bus(camif);
media/platform/s3c-camif/camif-capture.c:79:	camif_hw_set_camera_crop(camif);
media/platform/s3c-camif/camif-capture.c:93: * Initialize the video path, only up from the scaler stage. The camera
media/platform/s3c-camif/camif-capture.c:367:		camif_hw_set_camera_crop(camif);
media/platform/s3c-camif/camif-capture.c:687:	input->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/s3c-camif/camif-capture.c:767:	 * camera input interface crop rectangle and the resizer's capabilities.
media/platform/s3c-camif/camif-capture.c:1230: *  Camera input interface subdev operations
media/platform/s3c-camif/camif-capture.c:1261:		/* full camera input pixel size */
media/platform/s3c-camif/camif-capture.c:1266:		/* crop rectangle at camera interface input */
media/platform/s3c-camif/camif-capture.c:1326:	 * No pixel format change at the camera input is allowed
media/platform/marvell-ccic/cafe-driver.c:2: * A driver for the CMOS camera controller in the Marvell 88ALP01 "cafe"
media/platform/marvell-ccic/cafe-driver.c:45:MODULE_DESCRIPTION("Marvell 88ALP01 CMOS Camera Controller driver");
media/platform/marvell-ccic/cafe-driver.c:52:struct cafe_camera {
media/platform/marvell-ccic/cafe-driver.c:54:	struct mcam_camera mcam;
media/platform/marvell-ccic/cafe-driver.c:60: * Most of the camera controller registers are defined in mcam-core.h,
media/platform/marvell-ccic/cafe-driver.c:121:#define	  GFCR_GPIO_ON	  0x08		/* Camera GPIO enabled */
media/platform/marvell-ccic/cafe-driver.c:139: * The I2C/SMBUS interface to the camera itself starts here.  The
media/platform/marvell-ccic/cafe-driver.c:145:static inline struct cafe_camera *to_cam(struct v4l2_device *dev)
media/platform/marvell-ccic/cafe-driver.c:147:	struct mcam_camera *m = container_of(dev, struct mcam_camera, v4l2_dev);
media/platform/marvell-ccic/cafe-driver.c:148:	return container_of(m, struct cafe_camera, mcam);
media/platform/marvell-ccic/cafe-driver.c:152:static int cafe_smbus_write_done(struct mcam_camera *mcam)
media/platform/marvell-ccic/cafe-driver.c:169:static int cafe_smbus_write_data(struct cafe_camera *cam,
media/platform/marvell-ccic/cafe-driver.c:174:	struct mcam_camera *mcam = &cam->mcam;
media/platform/marvell-ccic/cafe-driver.c:229:static int cafe_smbus_read_done(struct mcam_camera *mcam)
media/platform/marvell-ccic/cafe-driver.c:248:static int cafe_smbus_read_data(struct cafe_camera *cam,
media/platform/marvell-ccic/cafe-driver.c:253:	struct mcam_camera *mcam = &cam->mcam;
media/platform/marvell-ccic/cafe-driver.c:295:	struct cafe_camera *cam = i2c_get_adapdata(adapter);
media/platform/marvell-ccic/cafe-driver.c:315:static void cafe_smbus_enable_irq(struct cafe_camera *cam)
media/platform/marvell-ccic/cafe-driver.c:335:static int cafe_smbus_setup(struct cafe_camera *cam)
media/platform/marvell-ccic/cafe-driver.c:356:static void cafe_smbus_shutdown(struct cafe_camera *cam)
media/platform/marvell-ccic/cafe-driver.c:367:static void cafe_ctlr_init(struct mcam_camera *mcam)
media/platform/marvell-ccic/cafe-driver.c:403:static void cafe_ctlr_power_up(struct mcam_camera *mcam)
media/platform/marvell-ccic/cafe-driver.c:420:static void cafe_ctlr_power_down(struct mcam_camera *mcam)
media/platform/marvell-ccic/cafe-driver.c:434:	struct cafe_camera *cam = data;
media/platform/marvell-ccic/cafe-driver.c:435:	struct mcam_camera *mcam = &cam->mcam;
media/platform/marvell-ccic/cafe-driver.c:460:	struct cafe_camera *cam;
media/platform/marvell-ccic/cafe-driver.c:461:	struct mcam_camera *mcam;
media/platform/marvell-ccic/cafe-driver.c:464:	 * Start putting together one of our big camera structures.
media/platform/marvell-ccic/cafe-driver.c:467:	cam = kzalloc(sizeof(struct cafe_camera), GFP_KERNEL);
media/platform/marvell-ccic/cafe-driver.c:547:static void cafe_shutdown(struct cafe_camera *cam)
media/platform/marvell-ccic/cafe-driver.c:559:	struct cafe_camera *cam = to_cam(v4l2_dev);
media/platform/marvell-ccic/cafe-driver.c:577:	struct cafe_camera *cam = to_cam(v4l2_dev);
media/platform/marvell-ccic/cafe-driver.c:592:	struct cafe_camera *cam = to_cam(v4l2_dev);
media/platform/marvell-ccic/cafe-driver.c:634:	printk(KERN_NOTICE "Marvell M88ALP01 'CAFE' Camera Controller version %d\n",
media/platform/marvell-ccic/mmp-driver.c:2: * Support for the camera device found on Marvell MMP processors; known
media/platform/marvell-ccic/mmp-driver.c:22:#include <media/mmp-camera.h>
media/platform/marvell-ccic/mmp-driver.c:33:MODULE_ALIAS("platform:mmp-camera");
media/platform/marvell-ccic/mmp-driver.c:37:struct mmp_camera {
media/platform/marvell-ccic/mmp-driver.c:40:	struct mcam_camera mcam;
media/platform/marvell-ccic/mmp-driver.c:45:static inline struct mmp_camera *mcam_to_cam(struct mcam_camera *mcam)
media/platform/marvell-ccic/mmp-driver.c:47:	return container_of(mcam, struct mmp_camera, mcam);
media/platform/marvell-ccic/mmp-driver.c:59:static void mmpcam_add_device(struct mmp_camera *cam)
media/platform/marvell-ccic/mmp-driver.c:66:static void mmpcam_remove_device(struct mmp_camera *cam)
media/platform/marvell-ccic/mmp-driver.c:78:static struct mmp_camera *mmpcam_find_device(struct platform_device *pdev)
media/platform/marvell-ccic/mmp-driver.c:80:	struct mmp_camera *cam;
media/platform/marvell-ccic/mmp-driver.c:109:static void mmpcam_power_up_ctlr(struct mmp_camera *cam)
media/platform/marvell-ccic/mmp-driver.c:116:static void mmpcam_power_up(struct mcam_camera *mcam)
media/platform/marvell-ccic/mmp-driver.c:118:	struct mmp_camera *cam = mcam_to_cam(mcam);
media/platform/marvell-ccic/mmp-driver.c:119:	struct mmp_camera_platform_data *pdata;
media/platform/marvell-ccic/mmp-driver.c:138:static void mmpcam_power_down(struct mcam_camera *mcam)
media/platform/marvell-ccic/mmp-driver.c:140:	struct mmp_camera *cam = mcam_to_cam(mcam);
media/platform/marvell-ccic/mmp-driver.c:141:	struct mmp_camera_platform_data *pdata;
media/platform/marvell-ccic/mmp-driver.c:158:	struct mcam_camera *mcam = data;
media/platform/marvell-ccic/mmp-driver.c:171:	struct mmp_camera *cam;
media/platform/marvell-ccic/mmp-driver.c:172:	struct mcam_camera *mcam;
media/platform/marvell-ccic/mmp-driver.c:174:	struct mmp_camera_platform_data *pdata;
media/platform/marvell-ccic/mmp-driver.c:268:			"mmp-camera", mcam);
media/platform/marvell-ccic/mmp-driver.c:291:static int mmpcam_remove(struct mmp_camera *cam)
media/platform/marvell-ccic/mmp-driver.c:293:	struct mcam_camera *mcam = &cam->mcam;
media/platform/marvell-ccic/mmp-driver.c:294:	struct mmp_camera_platform_data *pdata;
media/platform/marvell-ccic/mmp-driver.c:311:	struct mmp_camera *cam = mmpcam_find_device(pdev);
media/platform/marvell-ccic/mmp-driver.c:325:	struct mmp_camera *cam = mmpcam_find_device(pdev);
media/platform/marvell-ccic/mmp-driver.c:335:	struct mmp_camera *cam = mmpcam_find_device(pdev);
media/platform/marvell-ccic/mmp-driver.c:357:		.name	= "mmp-camera",
media/platform/marvell-ccic/mmp-driver.c:376:		printk(KERN_ERR "mmp_camera leaving devices behind\n");
media/platform/marvell-ccic/mcam-core.c:2: * The Marvell camera core.  This device appears in a number of settings,
media/platform/marvell-ccic/mcam-core.c:40: * memory) or when somebody tries to use the camera (riskier), and,
media/platform/marvell-ccic/mcam-core.c:193:static void mcam_buffer_done(struct mcam_camera *cam, int frame,
media/platform/marvell-ccic/mcam-core.c:218:static void mcam_reset_buffers(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:227:static inline int mcam_needs_config(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:232:static void mcam_set_config_needed(struct mcam_camera *cam, int needed)
media/platform/marvell-ccic/mcam-core.c:245:static void mcam_ctlr_start(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:252:static void mcam_ctlr_stop(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:267:static int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)
media/platform/marvell-ccic/mcam-core.c:308:static void mcam_free_dma_bufs(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:324:static void mcam_ctlr_dma_vmalloc(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:348:	struct mcam_camera *cam = (struct mcam_camera *) data;
media/platform/marvell-ccic/mcam-core.c:388:static int mcam_check_dma_buffers(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:397:static void mcam_vmalloc_done(struct mcam_camera *cam, int frame)
media/platform/marvell-ccic/mcam-core.c:404:static inline int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)
media/platform/marvell-ccic/mcam-core.c:409:static inline void mcam_free_dma_bufs(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:414:static inline int mcam_check_dma_buffers(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:437:static void mcam_set_contig_buffer(struct mcam_camera *cam, int frame)
media/platform/marvell-ccic/mcam-core.c:466:static void mcam_ctlr_dma_contig(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:477:static void mcam_dma_contig_done(struct mcam_camera *cam, int frame)
media/platform/marvell-ccic/mcam-core.c:500:static void mcam_sg_next_buffer(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:523:static void mcam_ctlr_dma_sg(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:553:static void mcam_dma_sg_done(struct mcam_camera *cam, int frame)
media/platform/marvell-ccic/mcam-core.c:592:static void mcam_sg_restart(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:601:static inline void mcam_sg_restart(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:616:static void mcam_ctlr_image(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:667:static int mcam_ctlr_configure(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:680:static void mcam_ctlr_irq_enable(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:690:static void mcam_ctlr_irq_disable(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:697:static void mcam_ctlr_init(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:724:static void mcam_ctlr_stop_dma(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:729:	 * Theory: stop the camera controller (whether it is operating
media/platform/marvell-ccic/mcam-core.c:757:static void mcam_ctlr_power_up(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:768:static void mcam_ctlr_power_down(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:788:static int __mcam_cam_reset(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:797:static int mcam_cam_init(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:834:static int mcam_cam_set_flip(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:845:static int mcam_cam_configure(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:864:static int mcam_read_setup(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:908:	struct mcam_camera *cam = vb2_get_drv_priv(vq);
media/platform/marvell-ccic/mcam-core.c:924:	struct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);
media/platform/marvell-ccic/mcam-core.c:946:	struct mcam_camera *cam = vb2_get_drv_priv(vq);
media/platform/marvell-ccic/mcam-core.c:953:	struct mcam_camera *cam = vb2_get_drv_priv(vq);
media/platform/marvell-ccic/mcam-core.c:963:	struct mcam_camera *cam = vb2_get_drv_priv(vq);
media/platform/marvell-ccic/mcam-core.c:986:	struct mcam_camera *cam = vb2_get_drv_priv(vq);
media/platform/marvell-ccic/mcam-core.c:1026:	struct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);
media/platform/marvell-ccic/mcam-core.c:1042:	struct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);
media/platform/marvell-ccic/mcam-core.c:1062:	struct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);
media/platform/marvell-ccic/mcam-core.c:1071:	struct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);
media/platform/marvell-ccic/mcam-core.c:1095:static int mcam_setup_vb2(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:1139:static void mcam_cleanup_vb2(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:1157:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1170:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1183:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1196:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1208:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1220:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1255:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1276:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1318: * Return our stored notion of how the camera is/should be configured.
media/platform/marvell-ccic/mcam-core.c:1320: * the camera (and not mess with it at open time).  Someday.
media/platform/marvell-ccic/mcam-core.c:1325:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1340:	input->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/marvell-ccic/mcam-core.c:1342:	strcpy(input->name, "Camera");
media/platform/marvell-ccic/mcam-core.c:1372:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1385:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1398:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1412:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1424:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1437:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1450:	struct mcam_camera *cam = priv;
media/platform/marvell-ccic/mcam-core.c:1493:	struct mcam_camera *cam = video_drvdata(filp);
media/platform/marvell-ccic/mcam-core.c:1519:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1540:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1555:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1567:	struct mcam_camera *cam = filp->private_data;
media/platform/marvell-ccic/mcam-core.c:1607:static void mcam_frame_complete(struct mcam_camera *cam, int frame)
media/platform/marvell-ccic/mcam-core.c:1633:int mccic_irq(struct mcam_camera *cam, unsigned int irqs)
media/platform/marvell-ccic/mcam-core.c:1683:int mccic_register(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:1775:void mccic_shutdown(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:1800:void mccic_suspend(struct mcam_camera *cam)
media/platform/marvell-ccic/mcam-core.c:1813:int mccic_resume(struct mcam_camera *cam)
media/platform/exynos/gsc_1.3/gsc-capture.c:518:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/exynos/gsc_1.3/gsc-capture.c:1339:				cap->ctx->in_path = GSC_CAMERA;
media/platform/exynos/gsc_1.3/gsc-capture.c:1342:				cap->ctx->in_path = GSC_CAMERA;
media/platform/exynos/gsc_1.3/gsc-capture.c:1446:	ctx->in_path	 = GSC_CAMERA;
media/platform/exynos/gsc/gsc-capture.c:454:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/exynos/fimc-is2/fimc-is-video-3aac.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-3aap.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:67:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:69:#define CAMERA_WORKQUEUE_MAX_WAITING	1000
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:334:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:377:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:408:		core->running_front_camera = true;
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:410:		core->running_rear_camera = true;
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:436:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:486:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:498:				waitWorkqueue < CAMERA_WORKQUEUE_MAX_WAITING) {
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:607:			core->running_front_camera = false;
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:609:			core->running_rear_camera = false;
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:791:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-device-companion.c:820:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/fimc-is-dvfs.c:16:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video.c:564:		ext_size = sizeof(struct camera2_shot_ext) - sizeof(struct camera2_shot);
media/platform/exynos/fimc-is2/fimc-is-video.c:577:		frame->shot = (struct camera2_shot *)frame->kvaddr_shot;
media/platform/exynos/fimc-is2/fimc-is-video.c:578:		frame->shot_ext = (struct camera2_shot_ext *)queue->buf_kva[index][spare];
media/platform/exynos/fimc-is2/fimc-is-video.c:592:		frame->stream = (struct camera2_stream *)queue->buf_kva[index][spare];
media/platform/exynos/fimc-is2/fimc-is-video.c:1313:			panic("intentional panic from camera HAL");
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:51:/* Camera Source size */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:103:/* Camera Window Offset */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:119:/* Camera Output DMA Format */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:130:/* Camera Output Canvas */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:135:/* Camera Output DMA Offset */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:140:/* Camera Output DMA Address */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:144:/* Camera Status */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:161:/* Camera Status2 */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:166:/* Camera Status3 */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:175:/* Camera General Purpose */
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:701:static void flite_hw_set_camera_type(u32 __iomem *base_reg)
media/platform/exynos/fimc-is2/fimc-is-device-flite.c:891:	flite_hw_set_camera_type(base_reg);
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:592:		.max_number = CAMERA2_MAX_FACES,
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:818:		info("Camera: the %s FW were applied successfully.\n",
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:819:			((cam_id == CAMERA_SINGLE_REAR) &&
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:957:		info("Camera: the %s Setfile were applied successfully.\n",
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:958:			((cam_id == CAMERA_SINGLE_REAR) &&
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:964:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR) || defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:989:		err("Camera : Did not load cal data.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:993:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1016:	info("Camera : Front Sensor Version : 0x%x\n", cal_buf[0x5C]);
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1025:			info("Front Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1028:				err("Front Camera : CRC32 error but only header section is no problem.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1031:				err("Front Camera : CRC32 error for all section.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1039:			info("Rear Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1042:				err("Rear Camera : CRC32 error but only header section is no problem.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1045:				err("Rear Camera : CRC32 error for all section.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1063:#if !defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1088:		err("Camera : Did not load cal data.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1121:				info("Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1123:				info("Camera : Did not load dumped Cal. Sensor version is lower than V004.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1127:			info("Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1131:				err("Camera : CRC32 error but only header section is no problem.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1134:				err("Camera : CRC32 error for all section.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1144:				info("Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1146:				info("Camera : Did not load dumped Cal. Sensor version is lower than V004.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1150:			info("Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1154:				err("Camera : CRC32 error but only header section is no problem.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:1157:				err("Camera : CRC32 error for all section.");
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:2031:	struct camera2_sm *capability;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:2041:		sizeof(struct camera2_sm));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:2192:		merr("shot_ext size : %zd", device, sizeof(struct camera2_shot_ext));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:2992:	struct camera2_sm *capability = NULL;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:2994:	capability = kzalloc(sizeof(struct camera2_sm), GFP_KERNEL);
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3008:	ret = copy_to_user((void *)user_ptr, capability, sizeof(struct camera2_sm));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3139:	memset(&device->cur_peri_ctl, 0, sizeof(struct camera2_uctl));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3140:	memset(&device->peri_ctls, 0, sizeof(struct camera2_uctl)*SENSOR_MAX_CTL);
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3412:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3421:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3652:	device->is_region->parameter.TaAlg.ParameterAeConfig.uiCameraEntrance = device->sensor->fade_in_mode;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:3655:	memset(&device->cur_peri_ctl.fdUd, 0x0, sizeof(struct camera2_fd_uctl));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:4265:	struct camera2_node *node)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:4270:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:4459:	struct camera2_node *node)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:4464:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:4961:	struct camera2_node *node)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:4966:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:5116:	struct camera2_node *node)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:5121:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:5776:	struct camera2_node *node)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:5781:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6041:	struct camera2_node *node)
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6046:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6635:	struct camera2_node_group *node_group;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6636:	struct camera2_node *cap_node;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6694:	struct camera2_node_group *node_group;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6695:	struct camera2_node *cap_node;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6776:	struct camera2_node_group *node_group;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6777:	struct camera2_node *cap_node;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6902:	struct camera2_node_group *node_group;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6983:			sizeof(struct camera2_aa_ctl));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:6985:			sizeof(struct camera2_scaler_ctl));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7007:	memcpy(&frame->shot->uctl.fdUd, &device->cur_peri_ctl.fdUd, sizeof(struct camera2_fd_uctl));
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7094:	struct camera2_node_group *node_group;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7243:	struct camera2_node_group *node_group;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7351:	struct camera2_uctl *applied_ctl;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7353:	struct camera2_sensor_ctl *isp_sensor_ctl;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7354:	struct camera2_lens_ctl *isp_lens_ctl;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7355:	struct camera2_flash_ctl *isp_flash_ctl;
media/platform/exynos/fimc-is2/fimc-is-device-ischain.c:7395:	struct camera2_uctl *applied_ctl;
media/platform/exynos/fimc-is2/fimc-is-video-isp.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-mem.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-ispc.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx219.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-8b1.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-3h7.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx175.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:9712:/*CAMERA_RECORDING WITH 30fps  */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14842: *CAMERA_BRIGHTNESS_1 (1/9) M4   *
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14853: *CAMERA_BRIGHTNESS_2 (2/9) M3  *
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14865:  CAMERA_BRIGHTNESS_3 (3/9) M2
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14876:  CAMERA_BRIGHTNESS_4 (4/9) M1
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14888:  CAMERA_BRIGHTNESS_5 (5/9) Default
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14899:  CAMERA_BRIGHTNESS_6 (6/9) P1
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14910:  CAMERA_BRIGHTNESS_7 (7/9) P2
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14921:  CAMERA_BRIGHTNESS_8 (8/9) P3
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:14933:  CAMERA_BRIGHTNESS_9 (9/9) P4
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:15125:/*CAMERA_SCENE_off                         */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:15273:/*CAMERA_SCENE_Landscape                   */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:15427:/*CAMERA_SCENE_Party                       */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:15582:/*CAMERA_SCENE_sunset                      */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:15751:/*CAMERA_SCENE_Dawn                        */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:15919:/*CAMERA_SCENE_Fall                        */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:16073:/*CAMERA_SCENE_Nightshot	          */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:16232:/*CAMERA_SCENE_Backlight                        */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:16375:/*CAMERA_SCENE_Candle                      */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:16544:/*CAMERA_SCENE_Beach      */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:16692:/*CAMERA_SCENE_Sports              */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:16845:/*CAMERA_SCENE_Firework                      */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:17563:	case V4L2_CID_CAMERA_EXIF_EXPTIME:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:17566:	case V4L2_CID_CAMERA_EXIF_FLASH:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:17569:	case V4L2_CID_CAMERA_EXIF_ISO:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:17572:	case V4L2_CID_CAMERA_EXIF_TV:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr352-soc.c:17575:	case V4L2_CID_CAMERA_EXIF_BV:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4h5.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr030-soc.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr030-soc.c:1528:	case V4L2_CID_CAMERA_EXIF_EXPTIME:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr030-soc.c:1531:	case V4L2_CID_CAMERA_EXIF_FLASH:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr030-soc.c:1534:	case V4L2_CID_CAMERA_EXIF_ISO:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr030-soc.c:1537:	case V4L2_CID_CAMERA_EXIF_TV:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-sr030-soc.c:1540:	case V4L2_CID_CAMERA_EXIF_BV:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-2p2_12m.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-2t2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-5e3.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-5e3.c:610:	/* FRONT CAMERA  - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-5e3.c:618:	/* FRONT CAMERA  - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx228.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx240.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx240.c:208:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6a3.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6d1.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6d1.c:658:	/* FRONT CAMERA  - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6d1.c:667:	/* FRONT CAMERA  - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-2p2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-2p2.c:210:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6.c:665:	/* FRONT CAMERA  - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6.c:674:	/* FRONT CAMERA  - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6.c:684:	/* VISION CAMERA  - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6.c:693:	/* VISION CAMERA  - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-3h7_sunny.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-2p3.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4ec-soc.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4ec-soc.c:7543:	case V4L2_CID_CAMERA_EXIF_EXPTIME:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4ec-soc.c:7546:	case V4L2_CID_CAMERA_EXIF_FLASH:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4ec-soc.c:7549:	case V4L2_CID_CAMERA_EXIF_ISO:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4ec-soc.c:7552:	case V4L2_CID_CAMERA_EXIF_TV:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4ec-soc.c:7555:	case V4L2_CID_CAMERA_EXIF_BV:
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6b2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6b2.c:638:	/* FRONT CAMERA - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-6b2.c:647:	/* FRONT CAMERA - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx134.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e5.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-3h5.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-imx135.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6-c2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6-c2.c:341:	/* FRONT CAMERA  - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6-c2.c:362:	/* FRONT CAMERA  - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6-c2.c:386:#ifdef CAMERA_PARALLEL_RETENTION_SEQUENCE
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6-c2.c:450:	/* VISION CAMERA  - POWER ON */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-4e6-c2.c:459:	/* VISION CAMERA  - POWER OFF */
media/platform/exynos/fimc-is2/sensor/module/fimc-is-device-3l2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-core.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-core.c:555:	core->running_rear_camera = false;
media/platform/exynos/fimc-is2/fimc-is-core.c:556:	core->running_front_camera = false;
media/platform/exynos/fimc-is2/fimc-is-resourcemgr.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-companion.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-3aa.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-3aa.c:507:	case V4L2_CID_IS_CAMERA_TYPE:
media/platform/exynos/fimc-is2/fimc-is-video-3aa.c:522:					/* change value to X when TWIZ & back | frist time back camera */
media/platform/exynos/fimc-is2/fimc-is-video-scc.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:58:extern struct device *camera_front_dev;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:59:extern struct device *camera_rear_dev;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:594:		core->running_front_camera = true;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:596:		core->running_rear_camera = true;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:711:			core->running_front_camera = false;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:713:			core->running_rear_camera = false;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:919:	struct camera2_sensor_ctl *rsensor_ctl;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:920:	struct camera2_sensor_ctl *csensor_ctl;
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:1296:	memset(&device->sensor_ctl, 0, sizeof(struct camera2_sensor_ctl));
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:1297:	memset(&device->lens_ctl, 0, sizeof(struct camera2_lens_ctl));
media/platform/exynos/fimc-is2/fimc-is-device-sensor.c:1298:	memset(&device->flash_ctl, 0, sizeof(struct camera2_flash_ctl));
media/platform/exynos/fimc-is2/fimc-is-video-dis.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-scp.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/vendor/fimc-is-companion.c:661:	info("Camera: SPI write cal data, name = %s\n", name);
media/platform/exynos/fimc-is2/vendor/fimc-is-companion.c:747:	pr_info("===Camera: I2C read cal data, addr [0x%04x], size(%d)\n", addr,data_size);
media/platform/exynos/fimc-is2/vendor/fimc-is-companion.c:760://		pr_info("===Camera: I2C read addr[0x%04x],data[0x%04x]\n", data1,data2);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:28:struct class *camera_class = NULL;
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:29:struct device *camera_front_dev;
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:30:struct device *camera_rear_dev;
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:32:struct device *camera_ois_dev;
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:52:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:58:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:66:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:81:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:86:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:110:	if (!sysfs_core->running_rear_camera) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:116:			if (!sysfs_core->running_rear_camera) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:125:static ssize_t camera_front_sensorid_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:141:static ssize_t camera_rear_sensorid_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:166:static DEVICE_ATTR(front_sensorid, S_IRUGO, camera_front_sensorid_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:167:static DEVICE_ATTR(rear_sensorid, S_IRUGO, camera_rear_sensorid_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:226:static ssize_t camera_front_camtype_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:241:static ssize_t camera_front_camfw_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:244:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:280:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:281:static ssize_t camera_front_camfw_full_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:307:static ssize_t camera_front_checkfw_factory_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:316:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:326:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:336:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:346:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:347:static ssize_t camera_front_info_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:350:	char camera_info[110] = {0, };
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:353:	strcpy(camera_info, "ISP=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:356:			strcat(camera_info, "INT;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:359:			strcat(camera_info, "EXT;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:362:			strcat(camera_info, "SOC;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:365:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:369:	strcat(camera_info, "CALMEM=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:372:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:377:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:380:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:384:	strcat(camera_info, "READVER=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:387:			strcat(camera_info, "SYSFS;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:390:			strcat(camera_info, "CAMON;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:393:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:397:	strcat(camera_info, "COREVOLT=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:400:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:403:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:406:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:410:	strcat(camera_info, "UPGRADE=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:413:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:416:			strcat(camera_info, "SYSFS;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:419:			strcat(camera_info, "CAMON;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:422:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:426:	strcat(camera_info, "FWWRITE=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:429:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:432:			strcat(camera_info, "OS;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:435:			strcat(camera_info, "SD;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:438:			strcat(camera_info, "ALL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:441:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:445:	strcat(camera_info, "FWDUMP=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:448:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:451:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:454:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:458:	strcat(camera_info, "CC=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:461:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:464:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:467:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:471:	strcat(camera_info, "OIS=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:474:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:477:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:480:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:484:	return sprintf(buf, "%s\n", camera_info);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:486:	strcpy(camera_info, "ISP=NULL;CALMEM=NULL;READVER=NULL;COREVOLT=NULL;UPGRADE=NULL;"
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:489:	return sprintf(buf, "%s\n", camera_info);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:494:		camera_front_camtype_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:495:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:497:		camera_front_info_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:499:static DEVICE_ATTR(front_camfw, S_IRUGO, camera_front_camfw_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:500:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:501:static DEVICE_ATTR(front_camfw_full, S_IRUGO, camera_front_camfw_full_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:502:static DEVICE_ATTR(front_checkfw_factory, S_IRUGO, camera_front_checkfw_factory_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:505:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:506:static ssize_t camera_rear_writefw_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:521:static ssize_t camera_rear_camtype_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:536:static ssize_t camera_rear_camfw_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:554:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:589:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:601:static ssize_t camera_rear_camfw_full_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:615:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:650:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:662:static ssize_t camera_rear_checkfw_user_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:704:static ssize_t camera_rear_checkfw_factory_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:720:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:735:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:744:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:758:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:766:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:775:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:776:static ssize_t camera_rear_info_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:779:	char camera_info[110] = {0, };
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:783:	strcpy(camera_info, "ISP=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:786:			strcat(camera_info, "INT;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:789:			strcat(camera_info, "EXT;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:792:			strcat(camera_info, "SOC;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:795:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:799:	strcat(camera_info, "CALMEM=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:802:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:807:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:810:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:814:	strcat(camera_info, "READVER=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:817:			strcat(camera_info, "SYSFS;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:820:			strcat(camera_info, "CAMON;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:823:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:827:	strcat(camera_info, "COREVOLT=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:830:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:833:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:836:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:840:	strcat(camera_info, "UPGRADE=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:843:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:846:			strcat(camera_info, "SYSFS;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:849:			strcat(camera_info, "CAMON;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:852:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:856:	strcat(camera_info, "FWWRITE=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:859:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:862:			strcat(camera_info, "OS;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:865:			strcat(camera_info, "SD;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:868:			strcat(camera_info, "ALL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:871:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:875:	strcat(camera_info, "FWDUMP=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:878:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:881:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:884:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:888:	strcat(camera_info, "CC=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:891:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:894:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:897:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:901:	strcat(camera_info, "OIS=");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:904:			strcat(camera_info, "N;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:907:			strcat(camera_info, "Y;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:910:			strcat(camera_info, "NULL;");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:914:	return sprintf(buf, "%s\n", camera_info);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:916:	strcpy(camera_info, "ISP=NULL;CALMEM=NULL;READVER=NULL;COREVOLT=NULL;UPGRADE=NULL;"
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:919:	return sprintf(buf, "%s\n", camera_info);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:923:static ssize_t camera_rear_sensor_standby(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:939:static ssize_t camera_rear_sensor_standby_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:946:static ssize_t camera_rear_companionfw_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:959:static ssize_t camera_rear_companionfw_full_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:972:static ssize_t camera_rear_camfw_write(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:986:static ssize_t camera_rear_calcheck_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:993:#ifdef CONFIG_CAMERA_EEPROM_SUPPORT_FRONT
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1004:#ifdef CONFIG_CAMERA_EEPROM_SUPPORT_FRONT
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1036:static ssize_t camera_isp_core_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1054:static ssize_t camera_ois_power_store(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1078:static ssize_t camera_ois_selftest_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1133:static ssize_t camera_ois_rawdata_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1161:static ssize_t camera_ois_version_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1182:static ssize_t camera_ois_diff_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1198:static ssize_t camera_hw_init_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1209:static ssize_t camera_ois_exif_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1227:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1229:		camera_rear_writefw_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1232:		camera_rear_camtype_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1234:		camera_rear_camfw_show, camera_rear_camfw_write);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1236:		camera_rear_camfw_full_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1239:		camera_rear_companionfw_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1241:		camera_rear_companionfw_full_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1244:		camera_rear_calcheck_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1246:		camera_rear_checkfw_user_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1248:		camera_rear_checkfw_factory_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1250:		camera_rear_sensor_standby_show, camera_rear_sensor_standby);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1251:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1253:		camera_rear_info_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1257:		camera_isp_core_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1260:		camera_hw_init_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1263:		camera_ois_selftest_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1265:		NULL, camera_ois_power_store);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1267:		camera_ois_rawdata_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1269:		camera_ois_version_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1271:		camera_ois_diff_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1273:		camera_ois_exif_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1277:static ssize_t camera_rear_force_cal_load_show(struct device *dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1284:static DEVICE_ATTR(rear_force_cal_load, S_IRUGO, camera_rear_force_cal_load_show, NULL);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1294:	if (camera_class == NULL) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1295:		camera_class = class_create(THIS_MODULE, "camera");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1296:		if (IS_ERR(camera_class)) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1297:			pr_err("Failed to create class(camera)!\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1298:			return PTR_ERR(camera_class);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1302:	camera_front_dev = device_create(camera_class, NULL, 0, NULL, "front");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1303:	if (IS_ERR(camera_front_dev)) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1306:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1312:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1318:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1324:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1325:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1331:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1339:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1340:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1347:	camera_rear_dev = device_create(camera_class, NULL, 1, NULL, "rear");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1348:	if (IS_ERR(camera_rear_dev)) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1351:		if (device_create_file(camera_rear_dev, &dev_attr_rear_sensorid) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1355:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1356:		if (device_create_file(camera_rear_dev, &dev_attr_from_write) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1361:		if (device_create_file(camera_rear_dev, &dev_attr_rear_camtype) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1365:		if (device_create_file(camera_rear_dev, &dev_attr_rear_camfw) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1369:		if (device_create_file(camera_rear_dev, &dev_attr_rear_camfw_full) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1373:		if (device_create_file(camera_rear_dev, &dev_attr_rear_checkfw_user) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1377:		if (device_create_file(camera_rear_dev, &dev_attr_rear_checkfw_factory) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1381:		if (device_create_file(camera_rear_dev, &dev_attr_rear_sensor_standby) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1385:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1386:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1394:		if (device_create_file(camera_rear_dev, &dev_attr_rear_companionfw) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1398:		if (device_create_file(camera_rear_dev, &dev_attr_rear_companionfw_full) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1403:		if (device_create_file(camera_rear_dev, &dev_attr_rear_calcheck) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1408:		if (device_create_file(camera_rear_dev, &dev_attr_isp_core) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1413:		if (device_create_file(camera_rear_dev, &dev_attr_fw_update) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1418:		if (device_create_file(camera_rear_dev, &dev_attr_rear_force_cal_load) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1426:	camera_ois_dev = device_create(camera_class, NULL, 2, NULL, "ois");
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1427:	if (IS_ERR(camera_ois_dev)) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1430:		if (device_create_file(camera_ois_dev, &dev_attr_selftest) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1434:		if (device_create_file(camera_ois_dev, &dev_attr_ois_power) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1438:		if (device_create_file(camera_ois_dev, &dev_attr_ois_rawdata) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1442:		if (device_create_file(camera_ois_dev, &dev_attr_oisfw) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1446:		if (device_create_file(camera_ois_dev, &dev_attr_ois_diff) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1450:		if (device_create_file(camera_ois_dev, &dev_attr_ois_exif) < 0) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1464:	if (camera_front_dev) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1465:		device_remove_file(camera_front_dev, &dev_attr_front_sensorid);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1466:		device_remove_file(camera_front_dev, &dev_attr_front_camtype);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1467:		device_remove_file(camera_front_dev, &dev_attr_front_camfw);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1468:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1469:		device_remove_file(camera_front_dev, &dev_attr_front_camfw_full);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1470:		device_remove_file(camera_front_dev, &dev_attr_front_checkfw_factory);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1472:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1473:		device_remove_file(camera_front_dev, &dev_attr_front_caminfo);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1477:	if (camera_rear_dev) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1478:		device_remove_file(camera_rear_dev, &dev_attr_rear_sensorid);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1479:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1480:		device_remove_file(camera_rear_dev, &dev_attr_from_write);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1482:		device_remove_file(camera_rear_dev, &dev_attr_rear_camtype);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1483:		device_remove_file(camera_rear_dev, &dev_attr_rear_camfw);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1484:		device_remove_file(camera_rear_dev, &dev_attr_rear_camfw_full);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1485:		device_remove_file(camera_rear_dev, &dev_attr_rear_checkfw_user);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1486:		device_remove_file(camera_rear_dev, &dev_attr_rear_checkfw_factory);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1487:		device_remove_file(camera_rear_dev, &dev_attr_rear_sensor_standby);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1489:		device_remove_file(camera_rear_dev, &dev_attr_rear_companionfw);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1490:		device_remove_file(camera_rear_dev, &dev_attr_rear_companionfw_full);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1492:		device_remove_file(camera_rear_dev, &dev_attr_rear_calcheck);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1493:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1494:		device_remove_file(camera_rear_dev, &dev_attr_rear_caminfo);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1497:		device_remove_file(camera_rear_dev, &dev_attr_isp_core);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1500:		device_remove_file(camera_rear_dev, &dev_attr_rear_force_cal_load);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1502:		device_remove_file(camera_rear_dev, &dev_attr_fw_update);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1506:	if (camera_ois_dev) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1507:		device_remove_file(camera_ois_dev, &dev_attr_selftest);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1508:		device_remove_file(camera_ois_dev, &dev_attr_ois_power);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1509:		device_remove_file(camera_ois_dev, &dev_attr_ois_rawdata);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1510:		device_remove_file(camera_ois_dev, &dev_attr_oisfw);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1511:		device_remove_file(camera_ois_dev, &dev_attr_ois_diff);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1512:		device_remove_file(camera_ois_dev, &dev_attr_ois_exif);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1516:	if (camera_class) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1517:		if (camera_front_dev)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1518:			device_destroy(camera_class, camera_front_dev->devt);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1520:		if (camera_rear_dev)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1521:			device_destroy(camera_class, camera_rear_dev->devt);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1524:		if (camera_ois_dev)
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1525:			device_destroy(camera_class, camera_ois_dev->devt);
media/platform/exynos/fimc-is2/vendor/fimc-is-sysfs.c:1529:	class_destroy(camera_class);
media/platform/exynos/fimc-is2/vendor/fimc-is-companion_c2.c:1068:	info("Camera: SPI write cal data, name = %s\n", name);
media/platform/exynos/fimc-is2/vendor/fimc-is-companion_c2.c:1159:	pr_info("===Camera: I2C read cal data, addr [0x%04x], size(%d)\n", addr,data_size);
media/platform/exynos/fimc-is2/vendor/fimc-is-companion_c2.c:1172://		pr_info("===Camera: I2C read addr[0x%04x],data[0x%04x]\n", data1,data2);
media/platform/exynos/fimc-is2/vendor/fimc-is-companion_c2.c:1878:		err("Camera module is not valid. Does not use M2M cal Data.)");
media/platform/exynos/fimc-is2/vendor/fimc-is-companion_c2.c:1999:		err("Camera module is not valid. Does not use M2M cal Data.)");
media/platform/exynos/fimc-is2/vendor/fimc-is-device-af.c:296:	pr_info("af_noise : running_rear_camera = %d, onoff = %d\n", core->running_rear_camera, onoff);
media/platform/exynos/fimc-is2/vendor/fimc-is-device-af.c:297:	if (!core->running_rear_camera) {
media/platform/exynos/fimc-is2/vendor/fimc-is-device-af.c:347:	if (!core->running_rear_camera) {
media/platform/exynos/fimc-is2/vendor/fimc-is-device-af.c:369:	pr_info("fimc_is_af_move_lens : running_rear_camera = %d\n", core->running_rear_camera);
media/platform/exynos/fimc-is2/vendor/fimc-is-device-af.c:370:	if (!core->running_rear_camera) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:17:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR) || defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:60:static int cam_id = CAMERA_SINGLE_REAR;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:64://struct class *camera_class;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:65://struct device *camera_front_dev; /*sys/class/camera/front*/
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:66://struct device *camera_rear_dev; /*sys/class/camera/rear*/
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:69:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:78:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:109:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:177:	read_data_from_file("/data/CameraID.txt", buf, 1, &pos);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:179:		cam_id = CAMERA_SINGLE_REAR;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:181:		cam_id = CAMERA_SINGLE_FRONT;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:183:		cam_id = CAMERA_DUAL_REAR;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:185:		cam_id = CAMERA_DUAL_FRONT;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:210:	if (cam_id == CAMERA_SINGLE_FRONT ||
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:211:		cam_id == CAMERA_DUAL_FRONT) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:251:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:290:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:294:		compare_version = CAMERA_MODULE_ES_VERSION_FRONT;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:300:		compare_version = CAMERA_MODULE_ES_VERSION_REAR;
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:338:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:350:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:359:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:369:		err("Camera: CRC32 error at the header (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:383:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:389:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:397:		err("Camera: OEM address has error: start(0x%08X), end(0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:405:		err("Camera: CRC32 error at the OEM (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:406:#if !defined(CONFIG_CAMERA_ROYCE)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:418:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:424:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:432:		err("Camera: AWB address has error: start(0x%08X), end(0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:440:		err("Camera: CRC32 error at the AWB (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:450:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:456:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:464:		err("Camera: Shading address has error: start(0x%08X), end(0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:472:		err("Camera: CRC32 error at the Shading (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:487:			err("Camera: C2 Shading address has error: start(0x%08X), end(0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:496:			err("Camera: CRC32 error at the C2 Shading (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:513:			err("Camera: pdaf address has error: start(0x%08X), end(0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:521:			err("Camera: CRC32 error at the pdaf cal (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:533:			err("Camera: concord cal address has error: start(0x%08X), end(0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:541:			err("Camera: CRC32 error at the concord cal (0x%08X != 0x%08X)", checksum, buf32[checksum_base]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:549:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:581:	info("Camera: Start checking CRC32 FW\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:586:		err("Camera: CRC32 error at the binary section (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:593:	info("Camera: End checking CRC32 FW\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:598:#if defined(CONFIG_CAMERA_OTPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:614:		err("Camera: CRC32 error at the header data section (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:618:		pr_info("Camera: End checking CRC32 (0x%08X = 0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:642:	info("Camera: Start checking CRC32 Setfile\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:647:		err("Camera: CRC32 error at the binary section (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:654:	info("Camera: End checking CRC32 Setfile\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:674:	info("Camera: Start checking CRC32 Companion FW\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:679:		err("Camera: CRC32 error at the binary section (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:686:	info("Camera: End checking CRC32 Companion FW\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1179:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR) || defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1322:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1334:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1339:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1345:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1379:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1394:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1407:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1416:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1426:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1442:	printk(KERN_INFO "Camera: EEPROM Cal map_version = %c%c%c%c\n", finfo->cal_map_ver[0],
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1446:		info("Camera: Do not read eeprom cal data. EEPROM version is low.\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1453:	info("Camera: I2C read cal data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1454:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1467:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1479:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1575:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1674:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1690:#if defined(CONFIG_CAMERA_OTPROM_SUPPORT_REAR) || defined(CONFIG_CAMERA_OTPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1714:#if defined(CONFIG_CAMERA_OTPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1721:#if defined(CONFIG_CAMERA_OTPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1748:	printk(KERN_INFO "Camera: otp_bank = %d\n", selected_page[0]);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1750:		printk(KERN_INFO "Camera: OTP 3 page selected\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1766:		printk(KERN_INFO "Camera: Cal Map version read fail or there's no available data.\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1771:	printk(KERN_INFO "Camera: OTPROM Cal map_version = %c%c%c%c\n", finfo->cal_map_ver[0],
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1784:	pr_info("Camera: I2C read cal data\n\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1791:#if defined(CONFIG_CAMERA_OTPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1799:#if defined(CONFIG_CAMERA_OTPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1859:			if (sysfs_finfo.header_ver[10] >= CAMERA_MODULE_ES_VERSION) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1921:#if !defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:1961:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2015:	info("Camera: Start SPI read header data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2090:	info("Camera: End SPI read header data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2302:	if (!core->running_rear_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2321:	if (!core->running_rear_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2418:	info("Camera: FROM Module ID = 0x%04x\n", id);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2427:	info("Camera: FROM Cal map_version = %c%c%c%c\n", sysfs_finfo.cal_map_ver[0],
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2432:	info("Camera: SPI read cal data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2714:		if (sysfs_finfo.header_ver[10] >= CAMERA_MODULE_ES_VERSION_REAR) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2723:#if defined(CAMERA_MODULE_CORE_CS_VERSION)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2724:		    && sysfs_finfo.header_ver[0] == CAMERA_MODULE_CORE_CS_VERSION
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2768:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2776:	info("Camera: FW need to be dumped\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2780:	info("Camera: Start SPI read fw data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2788:	info("Camera: End SPI read fw data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2806:	info("Camera: FW Data has dumped successfully\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2819:	info("Camera: Setfile need to be dumped\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2823:	info("Camera: Start SPI read setfile data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2836:	info("Camera: End SPI read setfile data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2855:	info("Camera: Setfile has dumped successfully\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2863:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2874:	info("Camera: Companion FW, Setfile need to be dumped\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2878:	info("Camera: Start SPI read companion fw data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2886:	info("Camera: End SPI read companion fw data\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2905:	info("Camera: Companion FW Data has dumped successfully\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:2925:	info("Camera: Companion Setfile has dumped successfully\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3311:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3314:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3335:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3358:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3374:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR) || defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3395:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3411:			info("Camera: read cal data from Front EEPROM\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3430:			info("Camera: read cal data from Rear EEPROM\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3432:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3455:		err("Camera: Failed open phone firmware");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3465:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3490:	info("Camera: phone fw version: %s\n", phone_fw_version);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3507:#if defined(CONFIG_CAMERA_EEPROM_SUPPORT_FRONT)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3509:		if (is_ldo_enabled[0] && !core->running_front_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3512:		if (is_ldo_enabled[1] && !core->running_rear_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3517:		if (is_ldo_enabled[0] && !core->running_rear_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3527:#if !defined(CONFIG_CAMERA_EEPROM_SUPPORT_REAR)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3535:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3590:			info("Camera : CRC32 error for all section.\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3602:		info("Camera: f-rom fw version: %s\n", sysfs_finfo.header_ver);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3608:			info("Camera: There is no dumped firmware\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3619:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3643:		info("Camera: dumped fw version: %s\n", dump_fw_version);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3667:			err("Camera: Failed open phone firmware");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3675:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3700:		info("Camera: phone fw version: %s\n", phone_fw_version);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3719:#if defined(CAMERA_MODULE_DUALIZE) && defined(CAMERA_MODULE_AVAILABLE_DUMP_VERSION)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3720:		if (!strncmp(CAMERA_MODULE_AVAILABLE_DUMP_VERSION, sysfs_finfo.header_ver, 3)) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3843:	if (is_ldo_enabled && !core->running_rear_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3860:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3878:	    (cam_id == CAMERA_SINGLE_REAR /* || cam_id == CAMERA_DUAL_FRONT*/)) ||
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3975:		info("Camera: f-rom fw version: %s\n", sysfs_finfo.concord_header_ver);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3982:			info("Camera: There is no dumped Companion firmware\n");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:3993:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4017:		info("Camera: dumped companion fw version: %s\n", dump_c1_fw_version);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4040:			err("Camera: Failed open phone companion firmware");
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4049:#ifdef CAMERA_MODULE_DUALIZE
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4074:		info("Camera: phone companion fw version: %s\n", phone_c1_fw_version);
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4093:#if defined(CAMERA_MODULE_DUALIZE) && defined(CAMERA_MODULE_AVAILABLE_DUMP_VERSION)
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4094:		if (!strncmp(CAMERA_MODULE_AVAILABLE_DUMP_VERSION, sysfs_finfo.header_ver, 3)) {
media/platform/exynos/fimc-is2/vendor/fimc-is-sec-define.c:4157:				if (is_ldo_enabled && !core->running_rear_camera)
media/platform/exynos/fimc-is2/vendor/fimc-is-device-eeprom.c:12:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/vendor/fimc-is-device-eeprom.c:262:MODULE_DESCRIPTION("Camera eeprom driver");
media/platform/exynos/fimc-is2/vendor/fimc-is-device-ois.c:1482:	if (ois_minfo.header_ver[2] != CAMERA_OIS_DOM_UPDATE_VERSION
media/platform/exynos/fimc-is2/vendor/fimc-is-device-ois.c:1483:		&& ois_minfo.header_ver[2] != CAMERA_OIS_SEC_UPDATE_VERSION) {
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:164:		sizeof(struct camera2_node_group));
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:177:	struct camera2_node *node;
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:1615:			memset(&group->intent_ctl, 0, sizeof(struct camera2_aa_ctl));
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:1867:		memset(&frame->shot->uctl.scalerUd, 0, sizeof(struct camera2_scaler_uctl));
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:1890:				sizeof(struct camera2_aa_ctl));
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:1892:				sizeof(struct camera2_scaler_ctl));
media/platform/exynos/fimc-is2/fimc-is-groupmgr.c:2459:			sizeof(struct camera2_fd_uctl));
media/platform/exynos/fimc-is2/fimc-is-video-ispp.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-dt.c:288:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/fimc-is-dt.c:290:	struct fimc_is_cam_info *cam_infos, int camera_num)
media/platform/exynos/fimc-is2/fimc-is-dt.c:295:	DT_READ_U32(np, "isp", cam_infos[camera_num].isp);
media/platform/exynos/fimc-is2/fimc-is-dt.c:296:	DT_READ_U32(np, "cal_memory", cam_infos[camera_num].cal_memory);
media/platform/exynos/fimc-is2/fimc-is-dt.c:297:	DT_READ_U32(np, "read_version", cam_infos[camera_num].read_version);
media/platform/exynos/fimc-is2/fimc-is-dt.c:298:	DT_READ_U32(np, "core_voltage", cam_infos[camera_num].core_voltage);
media/platform/exynos/fimc-is2/fimc-is-dt.c:299:	DT_READ_U32(np, "upgrade", cam_infos[camera_num].upgrade);
media/platform/exynos/fimc-is2/fimc-is-dt.c:300:	DT_READ_U32(np, "fw_write", cam_infos[camera_num].fw_write);
media/platform/exynos/fimc-is2/fimc-is-dt.c:301:	DT_READ_U32(np, "fw_dump", cam_infos[camera_num].fw_dump);
media/platform/exynos/fimc-is2/fimc-is-dt.c:302:	DT_READ_U32(np, "companion", cam_infos[camera_num].companion);
media/platform/exynos/fimc-is2/fimc-is-dt.c:303:	DT_READ_U32(np, "ois", cam_infos[camera_num].ois);
media/platform/exynos/fimc-is2/fimc-is-dt.c:318:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/fimc-is-dt.c:320:	struct fimc_is_cam_info *camera_infos;
media/platform/exynos/fimc-is2/fimc-is-dt.c:322:	int camera_num;
media/platform/exynos/fimc-is2/fimc-is-dt.c:323:	int total_camera_num;
media/platform/exynos/fimc-is2/fimc-is-dt.c:419:#ifdef CAMERA_SYSFS_V2
media/platform/exynos/fimc-is2/fimc-is-dt.c:420:	ret = of_property_read_u32(np, "total_camera_num", &total_camera_num);
media/platform/exynos/fimc-is2/fimc-is-dt.c:422:		err("total_camera_num read is fail(%d)", ret);
media/platform/exynos/fimc-is2/fimc-is-dt.c:423:		total_camera_num = 0;
media/platform/exynos/fimc-is2/fimc-is-dt.c:425:	fimc_is_get_cam_info(&camera_infos);
media/platform/exynos/fimc-is2/fimc-is-dt.c:427:	for (camera_num = 0; camera_num < total_camera_num; camera_num++) {
media/platform/exynos/fimc-is2/fimc-is-dt.c:428:		sprintf(camInfo_string, "%s%d", "camera_info", camera_num);
media/platform/exynos/fimc-is2/fimc-is-dt.c:436:		parse_sysfs_caminfo(pdata, camInfo_np, camera_infos, camera_num);
media/platform/exynos/fimc-is2/fimc-is-framemgr.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-sensor.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is2/fimc-is-video-sensor.c:519:	case V4L2_CID_CAMERA_FADE_IN:
media/platform/exynos/fimc-is2/fimc-is-interface.c:7: * The header file related to camera
media/platform/exynos/fimc-is2/fimc-is-interface.c:186:		/* TWIZ & main camera*/
media/platform/exynos/fimc-is2/fimc-is-interface.c:192:		/* front camera | !TWIZ camera | dual camera */
media/platform/exynos/fimc-is2/fimc-is-interface.c:1214:	struct camera2_node *capture;
media/platform/exynos/fimc-is2/fimc-is-interface.c:2445:				panic("[@] camera panic!!!");
media/platform/exynos/fimc-is2/fimc-is-interface.c:2486:			panic("[@] camera sensor panic!!!");
media/platform/exynos/fimc-is/fimc-is-video-3aac.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-device-companion.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-dvfs.c:169:	struct camera2_node *node;
media/platform/exynos/fimc-is/fimc-is-companion.c:619:	pr_info("Camera: SPI write cal data, name = %s\n", name);
media/platform/exynos/fimc-is/fimc-is-companion.c:693:	pr_info("===Camera: I2C read cal data, addr [0x%04x], size(%d)\n", addr,data_size);
media/platform/exynos/fimc-is/fimc-is-companion.c:706://		pr_info("===Camera: I2C read addr[0x%04x],data[0x%04x]\n", data1,data2);
media/platform/exynos/fimc-is/fimc-is-video-vdisc.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-video.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-video.c:591:		ext_size = sizeof(struct camera2_shot_ext) - sizeof(struct camera2_shot);
media/platform/exynos/fimc-is/fimc-is-video.c:604:		frame->shot = (struct camera2_shot *)frame->kvaddr_shot;
media/platform/exynos/fimc-is/fimc-is-video.c:605:		frame->shot_ext = (struct camera2_shot_ext *)queue->buf_kva[index][spare];
media/platform/exynos/fimc-is/fimc-is-video.c:619:		frame->stream = (struct camera2_stream *)queue->buf_kva[index][spare];
media/platform/exynos/fimc-is/fimc-is-video-vdiso.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-device-flite.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-device-flite.c:51:/* Camera Source size */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:103:/* Camera Window Offset */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:119:/* Camera Output DMA Format */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:130:/* Camera Output Canvas */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:135:/* Camera Output DMA Offset */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:140:/* Camera Output DMA Address */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:144:/* Camera Status */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:161:/* Camera Status2 */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:166:/* Camera Status3 */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:175:/* Camera General Purpose */
media/platform/exynos/fimc-is/fimc-is-device-flite.c:668:static void flite_hw_set_camera_type(u32 __iomem *base_reg)
media/platform/exynos/fimc-is/fimc-is-device-flite.c:829:	flite_hw_set_camera_type(base_reg);
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:686:		.max_number = CAMERA2_MAX_FACES,
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:903:		info("Camera: the %s FW were applied successfully.\n",
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:904:			((cam_id == CAMERA_SINGLE_REAR) &&
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:913:	struct camera2_node *node,
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1098:		info("Camera: the %s Setfile were applied successfully.\n",
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1099:			((cam_id == CAMERA_SINGLE_REAR) &&
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1130:			info("Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1132:			info("Camera : Did not load dumped Cal. Sensor version is lower than V004.\n");
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1136:		info("Camera : the dumped Cal. data was applied successfully.\n");
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1140:			pr_err("Camera : CRC32 error but only header section is no problem.\n");
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:1143:			pr_err("Camera : CRC32 error for all section.\n");
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:2251:	struct camera2_sm *capability;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:2261:		sizeof(struct camera2_sm));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:2407:		merr("shot_ext size : %zd", device, sizeof(struct camera2_shot_ext));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:2625:		sizeof(struct camera2_uctl));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:2627:		sizeof(struct camera2_uctl)*SENSOR_MAX_CTL);
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:2629:		sizeof(struct camera2_sm));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:4567:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:4799:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:4804:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:5006:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:5011:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:5333:	 * this code is enabled when camera 2.0 feature is enabled
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:5533:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:5874:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:5879:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6224:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6229:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6533:	struct camera2_node *node)
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6537:	struct camera2_scaler_uctl *scalerUd;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6805:		sizeof(struct camera2_sm));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6841:	struct camera2_node *node, *leader_node;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6904:			sizeof(struct camera2_aa_ctl));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:6906:			sizeof(struct camera2_scaler_ctl));
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7023:	struct camera2_node *node, *leader_node;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7289:	struct camera2_node *node;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7415:	struct camera2_uctl *applied_ctl;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7417:	struct camera2_sensor_ctl *isp_sensor_ctl;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7418:	struct camera2_lens_ctl *isp_lens_ctl;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7419:	struct camera2_flash_ctl *isp_flash_ctl;
media/platform/exynos/fimc-is/fimc-is-device-ischain.c:7459:	struct camera2_uctl *applied_ctl;
media/platform/exynos/fimc-is/fimc-is-video-isp.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-mem.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-8b1.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-3h7.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-imx175.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-4h5.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr030.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr030.c:1524:	case V4L2_CID_CAMERA_EXIF_EXPTIME:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr030.c:1527:	case V4L2_CID_CAMERA_EXIF_FLASH:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr030.c:1530:	case V4L2_CID_CAMERA_EXIF_ISO:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr030.c:1533:	case V4L2_CID_CAMERA_EXIF_TV:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr030.c:1536:	case V4L2_CID_CAMERA_EXIF_BV:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:9708:/*CAMERA_RECORDING WITH 30fps  */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14838: *CAMERA_BRIGHTNESS_1 (1/9) M4   *
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14849: *CAMERA_BRIGHTNESS_2 (2/9) M3  *
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14861:  CAMERA_BRIGHTNESS_3 (3/9) M2
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14872:  CAMERA_BRIGHTNESS_4 (4/9) M1
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14884:  CAMERA_BRIGHTNESS_5 (5/9) Default
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14895:  CAMERA_BRIGHTNESS_6 (6/9) P1
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14906:  CAMERA_BRIGHTNESS_7 (7/9) P2
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14917:  CAMERA_BRIGHTNESS_8 (8/9) P3
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:14929:  CAMERA_BRIGHTNESS_9 (9/9) P4
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:15121:/*CAMERA_SCENE_off                         */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:15269:/*CAMERA_SCENE_Landscape                   */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:15423:/*CAMERA_SCENE_Party                       */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:15578:/*CAMERA_SCENE_sunset                      */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:15747:/*CAMERA_SCENE_Dawn                        */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:15915:/*CAMERA_SCENE_Fall                        */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:16069:/*CAMERA_SCENE_Nightshot	          */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:16228:/*CAMERA_SCENE_Backlight                        */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:16371:/*CAMERA_SCENE_Candle                      */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:16540:/*CAMERA_SCENE_Beach      */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:16688:/*CAMERA_SCENE_Sports              */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:16841:/*CAMERA_SCENE_Firework                      */
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:17559:	case V4L2_CID_CAMERA_EXIF_EXPTIME:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:17562:	case V4L2_CID_CAMERA_EXIF_FLASH:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:17565:	case V4L2_CID_CAMERA_EXIF_ISO:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:17568:	case V4L2_CID_CAMERA_EXIF_TV:
media/platform/exynos/fimc-is/sensor/fimc-is-device-sr352.c:17571:	case V4L2_CID_CAMERA_EXIF_BV:
media/platform/exynos/fimc-is/sensor/fimc-is-device-4ec.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-4ec.c:7543:	case V4L2_CID_CAMERA_EXIF_EXPTIME:
media/platform/exynos/fimc-is/sensor/fimc-is-device-4ec.c:7546:	case V4L2_CID_CAMERA_EXIF_FLASH:
media/platform/exynos/fimc-is/sensor/fimc-is-device-4ec.c:7549:	case V4L2_CID_CAMERA_EXIF_ISO:
media/platform/exynos/fimc-is/sensor/fimc-is-device-4ec.c:7552:	case V4L2_CID_CAMERA_EXIF_TV:
media/platform/exynos/fimc-is/sensor/fimc-is-device-4ec.c:7555:	case V4L2_CID_CAMERA_EXIF_BV:
media/platform/exynos/fimc-is/sensor/fimc-is-device-2p2_12m.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-imx240.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-6a3.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-6d1.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-2p2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-3h7_sunny.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-6b2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-4e5.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-3h5.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-imx135.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/sensor/fimc-is-device-3l2.c:22:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-core.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-core.c:94:struct class *camera_class = NULL;
media/platform/exynos/fimc-is/fimc-is-core.c:95:struct device *camera_front_dev;
media/platform/exynos/fimc-is/fimc-is-core.c:96:struct device *camera_rear_dev;
media/platform/exynos/fimc-is/fimc-is-core.c:280:static ssize_t camera_front_sensorid_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:295:static ssize_t camera_rear_sensorid_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:310:static DEVICE_ATTR(front_sensorid, S_IRUGO, camera_front_sensorid_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:311:static DEVICE_ATTR(rear_sensorid, S_IRUGO, camera_rear_sensorid_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:313:static ssize_t camera_front_camtype_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:317:#if defined(CONFIG_CAMERA_SENSOR_8B1)
media/platform/exynos/fimc-is/fimc-is-core.c:319:#elif defined(CONFIG_CAMERA_SENSOR_6D1)
media/platform/exynos/fimc-is/fimc-is-core.c:325:static ssize_t camera_front_camfw_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:329:#if defined(CONFIG_CAMERA_SENSOR_8B1)
media/platform/exynos/fimc-is/fimc-is-core.c:331:#elif defined(CONFIG_CAMERA_SENSOR_6D1)
media/platform/exynos/fimc-is/fimc-is-core.c:338:		camera_front_camtype_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:339:static DEVICE_ATTR(front_camfw, S_IRUGO, camera_front_camfw_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:357:			//fimc_is_sec_set_camid(CAMERA_DUAL_FRONT);
media/platform/exynos/fimc-is/fimc-is-core.c:382:static ssize_t camera_rear_camtype_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:398:static ssize_t camera_rear_camfw_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:430:static ssize_t camera_rear_camfw_full_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:462:static ssize_t camera_rear_companionfw_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:474:static ssize_t camera_rear_companionfw_full_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:487:static ssize_t camera_rear_camfw_write(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:501:static ssize_t camera_rear_calcheck_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:522:static ssize_t camera_isp_core_show(struct device *dev,
media/platform/exynos/fimc-is/fimc-is-core.c:546:		camera_rear_camtype_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:548:		camera_rear_camfw_show, camera_rear_camfw_write);
media/platform/exynos/fimc-is/fimc-is-core.c:550:		camera_rear_camfw_full_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:552:		camera_rear_companionfw_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:554:		camera_rear_companionfw_full_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:556:		camera_rear_calcheck_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:558:		camera_isp_core_show, NULL);
media/platform/exynos/fimc-is/fimc-is-core.c:1192:	if (camera_class == NULL) {
media/platform/exynos/fimc-is/fimc-is-core.c:1193:		camera_class = class_create(THIS_MODULE, "camera");
media/platform/exynos/fimc-is/fimc-is-core.c:1194:		if (IS_ERR(camera_class)) {
media/platform/exynos/fimc-is/fimc-is-core.c:1195:			pr_err("Failed to create class(camera)!\n");
media/platform/exynos/fimc-is/fimc-is-core.c:1196:			return PTR_ERR(camera_class);
media/platform/exynos/fimc-is/fimc-is-core.c:1200:	camera_front_dev = device_create(camera_class, NULL, 0,
media/platform/exynos/fimc-is/fimc-is-core.c:1203:	if (IS_ERR(camera_front_dev)) {
media/platform/exynos/fimc-is/fimc-is-core.c:1206:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1212:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1219:		if (device_create_file(camera_front_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1226:	camera_rear_dev = device_create(camera_class, NULL, 0,
media/platform/exynos/fimc-is/fimc-is-core.c:1229:	if (IS_ERR(camera_rear_dev)) {
media/platform/exynos/fimc-is/fimc-is-core.c:1232:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1238:		if (device_create_file(camera_rear_dev, &dev_attr_rear_camtype)
media/platform/exynos/fimc-is/fimc-is-core.c:1244:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1250:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1256:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1262:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1268:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1274:		if (device_create_file(camera_rear_dev,
media/platform/exynos/fimc-is/fimc-is-core.c:1344:#if defined(CONFIG_COMPANION_USE) || defined(CONFIG_CAMERA_EEPROM_SUPPORT)
media/platform/exynos/fimc-is/fimc-is-resourcemgr.c:10:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-video-companion.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-video-3aa.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-video-scc.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-sec-define.c:28://struct class *camera_class;
media/platform/exynos/fimc-is/fimc-is-sec-define.c:29://struct device *camera_front_dev; /*sys/class/camera/front*/
media/platform/exynos/fimc-is/fimc-is-sec-define.c:30://struct device *camera_rear_dev; /*sys/class/camera/rear*/
media/platform/exynos/fimc-is/fimc-is-sec-define.c:94:	read_data_from_file("/data/CameraID.txt", buf, 1, &pos);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:96:		cam_id = CAMERA_SINGLE_REAR;
media/platform/exynos/fimc-is/fimc-is-sec-define.c:98:		cam_id = CAMERA_SINGLE_FRONT;
media/platform/exynos/fimc-is/fimc-is-sec-define.c:100:		cam_id = CAMERA_DUAL_REAR;
media/platform/exynos/fimc-is/fimc-is-sec-define.c:102:		cam_id = CAMERA_DUAL_FRONT;
media/platform/exynos/fimc-is/fimc-is-sec-define.c:127:	if (cam_id == CAMERA_SINGLE_FRONT ||
media/platform/exynos/fimc-is/fimc-is-sec-define.c:128:		cam_id == CAMERA_DUAL_FRONT) {
media/platform/exynos/fimc-is/fimc-is-sec-define.c:184:		err("Camera: CRC32 error at the header (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:189:		err("Camera: Header checksum address has error(0x%08X)", checksum_base * 4);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:203:		err("Camera: CRC32 error at the OEM (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:207:		err("Camera: OEM checksum address has error(0x%08X)", checksum_base * 4);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:219:		err("Camera: CRC32 error at the AWB (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:223:		err("Camera: AWB checksum address has error(0x%08X)", checksum_base * 4);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:235:		err("Camera: CRC32 error at the Shading (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:239:		err("Camera: Shading checksum address has error(0x%08X)", checksum_base * 4);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:252:		err("Camera: CRC32 error at the pdaf cal (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:256:		err("Camera: pdaf cal checksum address has error(0x%08X)", checksum_base * 4);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:268:		err("Camera: CRC32 error at the concord cal (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:272:		err("Camera: concord cal checksum address has error(0x%08X)", checksum_base * 4);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:290:	pr_info("Camera: Start checking CRC32 FW\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:299:		err("Camera: CRC32 error at the binary section (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:304:	pr_info("Camera: End checking CRC32 FW\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:317:	pr_info("Camera: Start checking CRC32 Companion FW\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:325:		err("Camera: CRC32 error at the binary section (0x%08X != 0x%08X)",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:330:	pr_info("Camera: End checking CRC32 Companion FW\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:713:	printk(KERN_INFO "Camera: Cal map_version = %c%c%c%c\n", cal_map_version[0],
media/platform/exynos/fimc-is/fimc-is-sec-define.c:734:	pr_info("Camera: SPI read cal data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:824:		pr_info("Camera: Cal Data was dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:826:		pr_info("Camera: sysfs read. Cal Data will not dump\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:838:#ifdef CONFIG_CAMERA_EEPROM_SUPPORT
media/platform/exynos/fimc-is/fimc-is-sec-define.c:911:	printk(KERN_INFO "Camera: Cal map_version = %c%c%c%c\n", cal_map_version[0],
media/platform/exynos/fimc-is/fimc-is-sec-define.c:924:	pr_info("Camera: I2C read cal data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:997:		pr_info("Camera: Cal Data was dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:999:		pr_info("Camera: sysfs read. Cal Data will not dump\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1043:	pr_info("Camera: Cal map_version = %c%c%c%c\n", cal_map_version[0],
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1047:	pr_info("Camera: SPI read cal data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1303:	pr_info("Camera: FW, Setfile need to be dumped\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1315:	pr_info("Camera: Start SPI read fw data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1322:	pr_info("Camera: End SPI read fw data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1352:	pr_info("Camera: FW Data has dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1379:	pr_info("Camera: Setfile has dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1380:	pr_info("Camera: FW, Setfile were dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1399:	pr_info("Camera: Companion FW, Setfile need to be dumped\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1411:	pr_info("Camera: Start SPI read companion fw data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1418:	pr_info("Camera: End SPI read companion fw data\n\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1455:	pr_info("Camera: Companion FW Data has dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1483:	pr_info("Camera: Companion Setfile has dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1484:	pr_info("Camera: Companion FW, Setfile were dumped successfully\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1674:#ifdef CONFIG_CAMERA_EEPROM_SUPPORT
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1686:	    (cam_id == CAMERA_SINGLE_REAR || cam_id == CAMERA_DUAL_FRONT)) {
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1691:		if (cam_id == CAMERA_DUAL_FRONT) {
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1705:			pr_info("Camera : CRC32 error for all section.\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1718:			pr_info("Camera : change f-rom version from %s, to %s",
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1779:		if (cam_id != CAMERA_SINGLE_REAR) {
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1823:	    (cam_id == CAMERA_SINGLE_REAR /* || cam_id == CAMERA_DUAL_FRONT*/)) ||
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1852:			pr_info("Camera : CRC32 error for all section.\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1908:		if (cam_id != CAMERA_SINGLE_REAR) {
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1917:		pr_info("Camera: f-rom fw version: %s\n", sysfs_finfo.header_ver);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1923:			pr_info("Camera: There is no dumped firmware\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1947:		pr_info("Camera: dumped fw version: %s\n", dump_fw_version);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1970:			pr_err("Camera: Failed open phone firmware\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:1994:		pr_info("Camera: phone fw version: %s\n", phone_fw_version);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2126:	    (cam_id == CAMERA_SINGLE_REAR /* || cam_id == CAMERA_DUAL_FRONT*/)) ||
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2161:				pr_info("Camera : Wrong companion module version.\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2176:					pr_info("Camera : Wrong companion module version.\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2193:		pr_info("Camera: f-rom fw version: %s\n", sysfs_finfo.concord_header_ver);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2200:			pr_info("Camera: There is no dumped Companion firmware\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2224:		pr_info("Camera: dumped companion fw version: %s\n", dump_c1_fw_version);
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2245:			pr_err("Camera: Failed open phone companion firmware\n");
media/platform/exynos/fimc-is/fimc-is-sec-define.c:2269:		pr_info("Camera: phone companion fw version: %s\n", phone_c1_fw_version);
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:52:extern struct device *camera_front_dev;
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:53:extern struct device *camera_rear_dev;
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:333:	/* HACK: This is considerated only front camera vision scenario. */
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:776:	struct camera2_sensor_ctl *rsensor_ctl;
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:777:	struct camera2_sensor_ctl *csensor_ctl;
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:1100:	dev = pdev->id ? camera_front_dev : camera_rear_dev;
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:1153:	memset(&device->sensor_ctl, 0, sizeof(struct camera2_sensor_ctl));
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:1154:	memset(&device->lens_ctl, 0, sizeof(struct camera2_lens_ctl));
media/platform/exynos/fimc-is/fimc-is-device-sensor.c:1155:	memset(&device->flash_ctl, 0, sizeof(struct camera2_flash_ctl));
media/platform/exynos/fimc-is/fimc-is-video-scp.c:30:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-groupmgr.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-groupmgr.c:56:		sizeof(struct camera2_node_group));
media/platform/exynos/fimc-is/fimc-is-groupmgr.c:1164:		memset(&group->intent_ctl, 0, sizeof(struct camera2_ctl));
media/platform/exynos/fimc-is/fimc-is-groupmgr.c:1423:				sizeof(struct camera2_aa_ctl));
media/platform/exynos/fimc-is/fimc-is-groupmgr.c:1425:				sizeof(struct camera2_scaler_ctl));
media/platform/exynos/fimc-is/fimc-is-dt.c:568:		/* BACK CAMERA  - POWER ON */
media/platform/exynos/fimc-is/fimc-is-dt.c:570:		/* BACK CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-dt.c:572:		/* FRONT CAMERA  - POWER ON */
media/platform/exynos/fimc-is/fimc-is-dt.c:580:		/* FRONT CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-dt.c:588:		/* VISION CAMERA  - POWER ON */
media/platform/exynos/fimc-is/fimc-is-dt.c:596:		/* VISION CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-dt.c:606:		/* BACK CAMERA  - POWER ON */
media/platform/exynos/fimc-is/fimc-is-dt.c:608:		/* BACK CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-dt.c:610:		/* FRONT CAMERA  - POWER ON */
media/platform/exynos/fimc-is/fimc-is-dt.c:618:		/* FRONT CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-dt.c:626:		/* VISION CAMERA  - POWER ON */
media/platform/exynos/fimc-is/fimc-is-dt.c:634:		/* VISION CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-dt.c:800:	/* BACK CAMERA  - POWER OFF */
media/platform/exynos/fimc-is/fimc-is-framemgr.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-video-sensor.c:29:#include <linux/videodev2_exynos_camera.h>
media/platform/exynos/fimc-is/fimc-is-interface.c:7: * The header file related to camera
media/platform/exynos/fimc-is/fimc-is-interface.c:1146:	struct camera2_node *capture;
media/platform/exynos/fimc-is/fimc-is-interface.c:1625:	struct camera2_lens_uctl *isp_lens_uctl;
media/platform/exynos/fimc-is/fimc-is-interface.c:1626:	struct camera2_lens_uctl *lens_uctl;
media/platform/exynos/fimc-is/fimc-is-interface.c:1627:	struct camera2_sensor_uctl *isp_sensor_uctl;
media/platform/exynos/fimc-is/fimc-is-interface.c:1628:	struct camera2_sensor_uctl *sensor_uctl;
media/platform/exynos/fimc-is/fimc-is-interface.c:1629:	struct camera2_flash_uctl *isp_flash_uctl;
media/platform/exynos/fimc-is/fimc-is-interface.c:1630:	struct camera2_flash_uctl *flash_uctl;
media/platform/timblogiw.c:375:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/vivi.c:1072:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/vivi.c:1073:	sprintf(inp->name, "Camera %u", inp->index);
media/platform/fsl-viu.c:986:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/fsl-viu.c:988:	strcpy(inp->name, "Camera");
media/platform/arv.c:416:	strlcpy(vin->name, "Camera", sizeof(vin->name));
media/platform/arv.c:417:	vin->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/indycam.c:2: *  indycam.c - Silicon Graphics IndyCam digital camera driver
media/platform/indycam.c:148:	struct indycam *camera = to_indycam(sd);
media/platform/indycam.c:204:		if (camera->version == CAMERA_VERSION_MOOSE) {
media/platform/indycam.c:223:	struct indycam *camera = to_indycam(sd);
media/platform/indycam.c:272:		if (camera->version == CAMERA_VERSION_MOOSE) {
media/platform/indycam.c:290:	struct indycam *camera = to_indycam(sd);
media/platform/indycam.c:293:		       camera->version);
media/platform/indycam.c:312:	struct indycam *camera;
media/platform/indycam.c:318:	camera = kzalloc(sizeof(struct indycam), GFP_KERNEL);
media/platform/indycam.c:319:	if (!camera)
media/platform/indycam.c:322:	sd = &camera->sd;
media/platform/indycam.c:325:	camera->version = i2c_smbus_read_byte_data(client,
media/platform/indycam.c:327:	if (camera->version != CAMERA_VERSION_INDY &&
media/platform/indycam.c:328:	    camera->version != CAMERA_VERSION_MOOSE) {
media/platform/indycam.c:329:		kfree(camera);
media/platform/indycam.c:334:	       INDYCAM_VERSION_MAJOR(camera->version),
media/platform/indycam.c:335:	       INDYCAM_VERSION_MINOR(camera->version));
media/platform/indycam.c:343:		kfree(camera);
media/platform/indycam.c:353:		printk(KERN_ERR "IndyCam: White balancing camera failed\n");
media/platform/indycam.c:354:		kfree(camera);
media/platform/vino.c:317:	unsigned int camera_owner;
media/platform/vino.c:318:	struct v4l2_subdev *camera;
media/platform/vino.c:358:#define camera_call(o, f, args...) \
media/platform/vino.c:359:	v4l2_subdev_call(vino_drvdata->camera, o, f, ##args)
media/platform/vino.c:2540:		return vino_drvdata->camera_owner == vcs->channel;
media/platform/vino.c:2556:	if (vino_drvdata->camera
media/platform/vino.c:2557:	    && (vino_drvdata->camera_owner == VINO_NO_CHANNEL)) {
media/platform/vino.c:2558:		vino_drvdata->camera_owner = vcs->channel;
media/platform/vino.c:2701:		if (vino_drvdata->camera_owner == vcs->channel) {
media/platform/vino.c:2704:				vino_drvdata->camera_owner = vcs2->channel;
media/platform/vino.c:2706:				vino_drvdata->camera_owner = VINO_NO_CHANNEL;
media/platform/vino.c:2711:		if (!vino_drvdata->camera) {
media/platform/vino.c:2716:		if (vino_drvdata->camera_owner == VINO_NO_CHANNEL)
media/platform/vino.c:2717:			vino_drvdata->camera_owner = vcs->channel;
media/platform/vino.c:2762:	if (vino_drvdata->camera_owner == vcs->channel) {
media/platform/vino.c:2764:			vino_drvdata->camera_owner = vcs2->channel;
media/platform/vino.c:2766:			vino_drvdata->camera_owner = VINO_NO_CHANNEL;
media/platform/vino.c:2854:	if (vino_drvdata->decoder && vino_drvdata->camera) {
media/platform/vino.c:2875:	} else if (vino_drvdata->camera) {
media/platform/vino.c:2893:	if (vino_drvdata->decoder && vino_drvdata->camera) {
media/platform/vino.c:2914:	} else if (vino_drvdata->camera) {
media/platform/vino.c:2954:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/platform/vino.c:3686:		err = camera_call(core, g_ctrl, control);
media/platform/vino.c:3750:		err = camera_call(core, s_ctrl, control);
media/platform/vino.c:4335:	vino_drvdata->camera =
media/v4l2-core/v4l2-ctrls.c:219:	static const char * const camera_power_line_frequency[] = {
media/v4l2-core/v4l2-ctrls.c:226:	static const char * const camera_exposure_auto[] = {
media/v4l2-core/v4l2-ctrls.c:233:	static const char * const camera_exposure_metering[] = {
media/v4l2-core/v4l2-ctrls.c:240:	static const char * const camera_auto_focus_range[] = {
media/v4l2-core/v4l2-ctrls.c:279:	static const char * const camera_iso_sensitivity_auto[] = {
media/v4l2-core/v4l2-ctrls.c:496:		return camera_power_line_frequency;
media/v4l2-core/v4l2-ctrls.c:498:		return camera_exposure_auto;
media/v4l2-core/v4l2-ctrls.c:500:		return camera_exposure_metering;
media/v4l2-core/v4l2-ctrls.c:502:		return camera_auto_focus_range;
media/v4l2-core/v4l2-ctrls.c:508:		return camera_iso_sensitivity_auto;
media/v4l2-core/v4l2-ctrls.c:703:	/* CAMERA controls */
media/v4l2-core/v4l2-ctrls.c:705:	case V4L2_CID_CAMERA_CLASS:		return "Camera Controls";
media/v4l2-core/v4l2-ctrls.c:931:	case V4L2_CID_CAMERA_CLASS:
media/pci/saa7146/hexium_orion.c:44:	{ 0, "CVBS 1",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:45:	{ 1, "CVBS 2",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:46:	{ 2, "CVBS 3",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:47:	{ 3, "CVBS 4",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:48:	{ 4, "CVBS 5",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:49:	{ 5, "CVBS 6",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:50:	{ 6, "Y/C 1",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:51:	{ 7, "Y/C 2",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_orion.c:52:	{ 8, "Y/C 3",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/mxb.c:68:	{ AUX1,	   "AUX1",           V4L2_INPUT_TYPE_CAMERA, 0x3f, 0,
media/pci/saa7146/mxb.c:70:	{ AUX3,	   "AUX3 Composite", V4L2_INPUT_TYPE_CAMERA, 0x3f, 0,
media/pci/saa7146/mxb.c:72:	{ AUX3_YC, "AUX3 S-Video",   V4L2_INPUT_TYPE_CAMERA, 0x3f, 0,
media/pci/saa7146/hexium_gemini.c:43:	{ 0, "CVBS 1",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:44:	{ 1, "CVBS 2",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:45:	{ 2, "CVBS 3",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:46:	{ 3, "CVBS 4",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:47:	{ 4, "CVBS 5",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:48:	{ 5, "CVBS 6",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:49:	{ 6, "Y/C 1",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:50:	{ 7, "Y/C 2",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/saa7146/hexium_gemini.c:51:	{ 8, "Y/C 3",	V4L2_INPUT_TYPE_CAMERA,	0, 0, V4L2_STD_ALL, 0, V4L2_IN_CAP_STD },
media/pci/ivtv/ivtv-cards.c:1323:			V4L2_INPUT_TYPE_TUNER : V4L2_INPUT_TYPE_CAMERA);
media/pci/saa7134/saa7134-video.c:1750:	i->type  = V4L2_INPUT_TYPE_CAMERA;
media/pci/saa7134/saa7134-empress.c:188:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/pci/zoran/zoran_driver.c:2466:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/pci/cx88/cx88-video.c:1225:	i->type  = V4L2_INPUT_TYPE_CAMERA;
media/pci/saa7164/saa7164-encoder.c:258:		i->type  = V4L2_INPUT_TYPE_CAMERA;
media/pci/saa7164/saa7164-vbi.c:230:		i->type  = V4L2_INPUT_TYPE_CAMERA;
media/pci/cx23885/cx23885-video.c:1299:	i->type  = V4L2_INPUT_TYPE_CAMERA;
media/pci/ttpci/av7110_v4l.c:100:		.type		= V4L2_INPUT_TYPE_CAMERA,
media/pci/ttpci/av7110_v4l.c:118:		.type		= V4L2_INPUT_TYPE_CAMERA,
media/pci/ttpci/av7110_v4l.c:127:		.type		= V4L2_INPUT_TYPE_CAMERA,
media/pci/ttpci/budget-av.c:1415:	{ 1, "S-Video", V4L2_INPUT_TYPE_CAMERA, 2, 0,
media/pci/cx18/cx18-cards.c:613:			V4L2_INPUT_TYPE_TUNER : V4L2_INPUT_TYPE_CAMERA);
media/pci/mantis/mantis_input.c:81:	{ 0x0b, KEY_CAMERA	}, /* Capture */
media/pci/sta2x11/sta2x11_vip.c:514:	inp->type = V4L2_INPUT_TYPE_CAMERA;
media/pci/sta2x11/sta2x11_vip.c:516:	sprintf(inp->name, "Camera %u", inp->index);
media/pci/meye/meye.c:51:MODULE_DESCRIPTION("v4l2 driver for the MotionEye camera");
media/pci/meye/meye.c:908:	sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERASHARPNESS,
media/pci/meye/meye.c:910:	sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAAGC,
media/pci/meye/meye.c:912:	sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAPICTURE,
media/pci/meye/meye.c:1049:	strcpy(i->name, "Camera");
media/pci/meye/meye.c:1050:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/pci/meye/meye.c:1074:		sony_pic_camera_command(
media/pci/meye/meye.c:1075:			SONY_PIC_COMMAND_SETCAMERABRIGHTNESS, ctrl->val);
media/pci/meye/meye.c:1079:		sony_pic_camera_command(
media/pci/meye/meye.c:1080:			SONY_PIC_COMMAND_SETCAMERAHUE, ctrl->val);
media/pci/meye/meye.c:1084:		sony_pic_camera_command(
media/pci/meye/meye.c:1085:			SONY_PIC_COMMAND_SETCAMERACONTRAST, ctrl->val);
media/pci/meye/meye.c:1089:		sony_pic_camera_command(
media/pci/meye/meye.c:1090:			SONY_PIC_COMMAND_SETCAMERACOLOR, ctrl->val);
media/pci/meye/meye.c:1094:		sony_pic_camera_command(
media/pci/meye/meye.c:1095:			SONY_PIC_COMMAND_SETCAMERAAGC, ctrl->val);
media/pci/meye/meye.c:1099:		sony_pic_camera_command(
media/pci/meye/meye.c:1100:			SONY_PIC_COMMAND_SETCAMERASHARPNESS, ctrl->val);
media/pci/meye/meye.c:1104:		sony_pic_camera_command(
media/pci/meye/meye.c:1105:			SONY_PIC_COMMAND_SETCAMERAPICTURE, ctrl->val);
media/pci/meye/meye.c:1670:	if ((ret = sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERA, 1))) {
media/pci/meye/meye.c:1671:		v4l2_err(v4l2_dev, "meye: unable to power on the camera\n");
media/pci/meye/meye.c:1672:		v4l2_err(v4l2_dev, "meye: did you enable the camera in "
media/pci/meye/meye.c:1711:	/* Ask the camera to perform a soft reset. */
media/pci/meye/meye.c:1760:	v4l2_info(v4l2_dev, "Motion Eye Camera Driver v%s.\n",
media/pci/meye/meye.c:1778:	sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERA, 0);
media/pci/meye/meye.c:1811:	sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERA, 0);
media/pci/bt8xx/bttv-driver.c:1782:	i->type     = V4L2_INPUT_TYPE_CAMERA;
media/pci/bt8xx/bttv-cards.c:657:		/* .digital_mode= DIGITAL_MODE_CAMERA, */
media/pci/bt8xx/bttv-cards.c:1081:		/* .digital_mode= DIGITAL_MODE_CAMERA, */
media/pci/bt8xx/bttv-cards.c:1918:		.digital_mode   = DIGITAL_MODE_CAMERA,  todo!
media/pci/bt8xx/bttv-cards.c:2378:		*   00 - 03:	camera selector
media/pci/bt8xx/bttv-cards.c:2485:		/* .digital_mode= DIGITAL_MODE_CAMERA, */
media/pci/bt8xx/bttv-cards.c:4393: * an analog switch which connects any of 16 cameras to any of the BT87A's.
media/pci/bt8xx/bttv-cards.c:4404: * cameras is connected to which of the 4 controllers).  Rather than
media/pci/bt8xx/bttv-cards.c:4410: * First a routine to set the analog switch, which controls which camera
media/pci/bt8xx/bttv-cards.c:4412: * (gpio bits 0-3, representing the camera, ranging from 0-15), and a
media/pci/bt8xx/bttv-cards.c:4437: * requested camera number (0 - 15).
media/pci/bt8xx/bttv-cards.c:4454:	/* Check if the controller/camera pair has changed, else ignore */
media/pci/bt8xx/bttv-cards.c:4478:	/* Preset camera 0 to the 4 controllers */
media/pci/bt8xx/bttv-cards.c:4703: * camera is routed to which controller.  The switch comprises an X-address
media/pci/bt8xx/bttv-cards.c:4704: * (gpio bits 0-3, representing the camera, ranging from 0-15), and a
media/pci/bt8xx/bttv-cards.c:4718:	*   00 - 03:	camera selector
media/pci/bt8xx/bttv-cards.c:4743: * The parameter 'input' is the requested camera number (0-4) on the controller.
media/pci/bt8xx/bttv-cards.c:4747: * the physical "camera 1" connector corresponds to controller 0 input 0,
media/pci/bt8xx/bttv-cards.c:4748: * "camera 2" corresponds to controller 1 input 0, and so on.
media/pci/bt8xx/bttv-cards.c:4773:	/* Check if the controller/camera pair has changed, ignore otherwise */
media/pci/bt8xx/bttv-cards.c:4792:	/* Preset camera 0 to the 4 controllers */
media/pci/cx25821/cx25821-video.c:789:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/pci/cx25821/cx25821-video.c:837:	o->type = V4L2_INPUT_TYPE_CAMERA;
media/pci/cx25821/cx25821-medusa-video.c:118:		value |= 0x1C1E001A;	/* vblank_cnt + 2 to get camera ID */
media/pci/cx25821/cx25821-medusa-video.c:286:		value |= 0x28240026;	/* vblank_cnt + 2 to get camera ID */
media/rc/keymaps/rc-rc6-mce.c:74:	{ 0x800f0449, KEY_CAMERA },
media/rc/keymaps/rc-manli.c:107:	{ 0x19, KEY_CAMERA },
media/rc/keymaps/rc-norwood.c:56:	{ 0x2e, KEY_CAMERA },		/* Capture Video       */
media/rc/keymaps/rc-total-media-in-hand-02.c:40:	{ 0x000e, KEY_CAMERA },                 /* Snapshot */
media/rc/keymaps/rc-genius-tvgo-a11mce.c:53:	{ 0x05, KEY_CAMERA },		/* Snapshot */
media/rc/keymaps/rc-behold.c:115:	{ 0x6b865c, KEY_CAMERA },
media/rc/keymaps/rc-videomate-m1f.c:21:	{ 0x30, KEY_CAMERA },
media/rc/keymaps/rc-total-media-in-hand.c:48:	{ 0x02bd17, KEY_CAMERA },          /* Snapshot */
media/rc/keymaps/rc-leadtek-y04g0051.c:56:	{ 0x0348, KEY_CAMERA },
media/rc/keymaps/rc-azurewave-ad-tu700.c:75:	{ 0x0054, KEY_CAMERA },          /* Capture */
media/rc/keymaps/rc-avermedia-m733a-rm-k6.c:60:	{ 0x041b, KEY_CAMERA },      /* Snapshot */
media/rc/keymaps/rc-pixelview-002t.c:40:	{ 0x866b0a, KEY_CAMERA },	/* snapshot */
media/rc/keymaps/rc-purpletv.c:44:	{ 0x1f, KEY_CAMERA },	/* Snapshot */
media/rc/keymaps/rc-hauppauge.c:41:	{ 0x1e1a, KEY_CAMERA },		/* Pictures */
media/rc/keymaps/rc-winfast-usbii-deluxe.c:32:	{ 0x38, KEY_CAMERA},		/* SNAPSHOT */
media/rc/keymaps/rc-behold-columbus.c:52:	{ 0x19, KEY_CAMERA },	/* Snapshot key */
media/rc/keymaps/rc-videomate-s350.c:48:	{ 0x2f, KEY_CAMERA},	/* Snapshot */
media/rc/keymaps/rc-eztv.c:52:	{ 0x2e, KEY_CAMERA },	/* snapshot / shuffle */
media/rc/keymaps/rc-imon-pad.c:101:	{ 0x2ab715b7, KEY_CAMERA }, /* Thumbnail */
media/rc/keymaps/rc-pixelview-mk12.c:40:	{ 0x866b19, KEY_CAMERA },	/* snapshot */
media/rc/keymaps/rc-encore-enltv-fm53.c:39:	{ 0x05, KEY_CAMERA},		/* SNAPSHOT */
media/rc/keymaps/rc-nebula.c:31:	{ 0x0e, KEY_CAMERA },	/* labelled 'Picture' */
media/rc/keymaps/rc-dib0700-nec.c:40:	{ 0x866b0a, KEY_CAMERA },
media/rc/keymaps/rc-msi-tvanywhere-plus.c:87:	{ 0x1a, KEY_CAMERA },		/* Snapshot */
media/rc/keymaps/rc-winfast.c:61:	{ 0x28, KEY_CAMERA },		/* Screenshot */
media/rc/keymaps/rc-powercolor-real-angel.c:52:	{ 0x0e, KEY_CAMERA },		/* snapshot */
media/rc/keymaps/rc-dntv-live-dvb-t.c:41:	{ 0x13, KEY_CAMERA },		/* snap */
media/rc/keymaps/rc-tbs-nec.c:38:	{ 0x9a, KEY_CAMERA},		/* snapshot */
media/rc/keymaps/rc-gotview7135.c:42:	{ 0x3f, KEY_CAMERA },	/* SNAPSHOT */
media/rc/keymaps/rc-avermedia-m135a.c:112:	{ 0x041b, KEY_CAMERA },      /* Snapshot */
media/rc/keymaps/rc-imon-mce.c:88:	{ 0x800ff449, KEY_CAMERA },
media/rc/keymaps/rc-anysee.c:52:	{ 0x081b, KEY_CAMERA },          /* [symbol camera] */
media/rc/keymaps/rc-gadmei-rm008z.c:43:	{ 0x1e, KEY_CAMERA},		/* SNAPSHOT */
media/rc/keymaps/rc-real-audio-220-32-keys.c:52:	{ 0x19, KEY_CAMERA},		/* Snapshot */
media/rc/keymaps/rc-pixelview-new.c:47:	{ 0x19, KEY_CAMERA },		/* SNAPSHOT */
media/rc/keymaps/rc-pctv-sedna.c:45:	{ 0x19, KEY_CAMERA },	/* Snapshot */
media/rc/keymaps/rc-digittrade.c:52:	{ 0x001f, KEY_CAMERA },          /* SNAPSHOT */
media/rc/keymaps/rc-terratec-slim.c:47:	{ 0x02bd17, KEY_CAMERA },          /* snapshot */
media/rc/keymaps/rc-medion-x10-digitainer.c:73:	{ 0x18, KEY_CAMERA },
media/rc/keymaps/rc-encore-enltv2.c:58:	{ 0x51, KEY_CAMERA },		/* Snapshot */
media/rc/keymaps/rc-kworld-plus-tv-analog.c:71:	{ 0x1c, KEY_CAMERA},		/* snapshot */
media/rc/keymaps/rc-avermedia.c:45:	{ 0x3a, KEY_CAMERA },		/* SNAPSHOT */
media/rc/keymaps/rc-nec-terratec-cinergy-xs.c:49:	{ 0x144b, KEY_CAMERA},		/* PIC */
media/rc/keymaps/rc-evga-indtube.c:36:	{ 0x13, KEY_CAMERA},
media/rc/keymaps/rc-encore-enltv.c:28:	{ 0x02, KEY_CAMERA },		/* picture */
media/rc/keymaps/rc-encore-enltv.c:66:	{ 0x43, KEY_CAMERA },		/* camera icon */
media/rc/keymaps/rc-fusionhdtv-mce.c:60:	{ 0x52, KEY_CAMERA },
media/rc/keymaps/rc-dntv-live-dvbt-pro.c:57:	{ 0x54, KEY_CAMERA },		/* capture */
media/rc/imon.c:295:	{ 0x000000002100ffeell, KEY_CAMERA },
media/parport/bw-qcam.c:23: *	  When acquiring a frame from the camera, the data gathering
media/parport/bw-qcam.c:105:#define QC_PARAM_CHANGE	0x01 /* Camera status change has occurred */
media/parport/bw-qcam.c:178: * Almost all communication with the camera requires handshaking. */
media/parport/bw-qcam.c:189:			   until the camera wakes up. However, we are
media/parport/bw-qcam.c:190:			   busy blocked until the camera responds, so
media/parport/bw-qcam.c:203:			   until the camera wakes up. However, we are
media/parport/bw-qcam.c:204:			   busy blocked until the camera responds, so
media/parport/bw-qcam.c:232:		   until the camera wakes up. However, we are
media/parport/bw-qcam.c:233:		   busy blocked until the camera responds, so
media/parport/bw-qcam.c:247: * bytes *to* the camera.  Generally, these bytes are either commands
media/parport/bw-qcam.c:287:   camera (they send a reset and try to handshake), but this should be
media/parport/bw-qcam.c:289:   I plug it in before the camera. */
media/parport/bw-qcam.c:312:	/* Force camera detection during testing. Sometimes the camera
media/parport/bw-qcam.c:334: * camera takes the picture at the resolution specified in the
media/parport/bw-qcam.c:462:	/* Clear flag that we must update the grabbing parameters on the camera
media/parport/bw-qcam.c:551:/* requests a scan from the camera.  It sends the correct instructions
media/parport/bw-qcam.c:552: * to the camera and then reads back the correct number of bytes.  In
media/parport/bw-qcam.c:554: * the raw output from the camera, and there was a 'qc_convertscan'
media/parport/bw-qcam.c:682:	/* Update the camera parameters if we need to */
media/parport/bw-qcam.c:726:	strlcpy(vin->name, "Camera", sizeof(vin->name));
media/parport/bw-qcam.c:727:	vin->type = V4L2_INPUT_TYPE_CAMERA;
media/parport/bw-qcam.c:813:	/* We must update the camera before we grab. We could
media/parport/bw-qcam.c:1025:	qc_command(q, 0);	/* Dummy Parameter, ignored by the camera */
media/parport/pms.c:701:	vin->type = V4L2_INPUT_TYPE_CAMERA;
media/parport/c-qcam.c:11: *	probe=0		  -- do no probing, assume camera is present
media/parport/c-qcam.c:13: *	probe=2		  -- probe aggressively for cameras
media/parport/c-qcam.c:62:/* cameras maximum */
media/parport/c-qcam.c:84:			  "probe=<0|1|2> for camera detection method\n"
media/parport/c-qcam.c:122:	/* If the camera didn't respond within 1/25 second, poll slowly
media/parport/c-qcam.c:148:	/* If the camera didn't respond within 1/25 second, poll slowly
media/parport/c-qcam.c:244:	/* Reset the camera and try again */
media/parport/c-qcam.c:263:	/* no (or flatline) camera, give up */
media/parport/c-qcam.c:303:/* Read some bytes from the camera and put them in the buffer.
media/parport/c-qcam.c:393:	/* Wait for camera to become ready */
media/parport/c-qcam.c:531:	strlcpy(vin->name, "Camera", sizeof(vin->name));
media/parport/c-qcam.c:532:	vin->type = V4L2_INPUT_TYPE_CAMERA;
media/parport/w9966.c:83:#define W9966_MAXCAMS		4	/* Maximum number of cameras */
media/parport/w9966.c:142:		"\teach camera. 'aggressive' means brute-force search.\n"
media/parport/w9966.c:160:/* Set camera phase flags, so we know what to uninit when terminating */
media/parport/w9966.c:166:/* Get camera phase flags */
media/parport/w9966.c:460:/* Setup the cameras capture window etc.
media/parport/w9966.c:583:	strlcpy(vin->name, "Camera", sizeof(vin->name));
media/parport/w9966.c:584:	vin->type = V4L2_INPUT_TYPE_CAMERA;
media/parport/w9966.c:691:	/* Update camera regs */
media/parport/w9966.c:805:/* Initialize camera device. Setup all internal flags, set a
media/usb/stk1160/stk1160-v4l.c:428:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/gspca/etoms.c:28:MODULE_DESCRIPTION("Etoms USB Camera Driver");
media/usb/gspca/etoms.c:583:/* -- start the camera -- */
media/usb/gspca/spca506.c:2: * SPCA506 chip based cameras function
media/usb/gspca/spca506.c:29:MODULE_DESCRIPTION("GSPCA/SPCA506 USB Camera Driver");
media/usb/gspca/spca506.c:584:/*fixme: may be IntelPCCameraPro BRIDGE_SPCA505
media/usb/gspca/vc032x.c:30:MODULE_DESCRIPTION("GSPCA/VC032X USB Camera Driver");
media/usb/gspca/sn9c2028.c:28:MODULE_DESCRIPTION("Sonix SN9C2028 USB Camera Driver");
media/usb/gspca/sn9c2028.c:172:	PDEBUG(D_PROBE, "SN9C2028 camera detected (vid/pid 0x%04X:0x%04X)",
media/usb/gspca/sn9c2028.c:179:		PDEBUG(D_PROBE, "Genius Smart 300 camera");
media/usb/gspca/sn9c2028.c:185:		PDEBUG(D_PROBE, "Spy camera");
media/usb/gspca/sn9c2028.c:188:		PDEBUG(D_PROBE, "CIF camera");
media/usb/gspca/sn9c2028.c:191:		PDEBUG(D_PROBE, "Mini-Shotz ms-350 camera");
media/usb/gspca/sn9c2028.c:194:		PDEBUG(D_PROBE, "Vivitar 3350b type camera");
media/usb/gspca/sn9c2028.c:309:		/* Camera should start to capture now. */
media/usb/gspca/sn9c2028.c:386:		/* Camera should start to capture now. */
media/usb/gspca/sn9c2028.c:454:		/* Camera should start to capture now. */
media/usb/gspca/sn9c2028.c:526:		/* Camera should start to capture now. */
media/usb/gspca/sn9c2028.c:639:		pr_err("Starting unknown camera, please report this\n");
media/usb/gspca/sn9c2028.c:653:		PERR("Camera Stop read failed");
media/usb/gspca/sn9c2028.c:659:		PERR("Camera Stop command failed");
media/usb/gspca/sn9c2028.c:705:	/* {USB_DEVICE(0x0c45, 0x8000)}, DC31VC, Don't know this camera */
media/usb/gspca/sn9c2028.c:707:	{USB_DEVICE(0x0c45, 0x8003)}, /* Several small CIF cameras */
media/usb/gspca/sn9c2028.c:708:	/* {USB_DEVICE(0x0c45, 0x8006)}, Unknown VGA camera */
media/usb/gspca/stv0680.c:2: * STV0680 USB Camera Driver
media/usb/gspca/stv0680.c:8: *  STV0680 USB Camera Driver, by Kevin Sisson (kjsisson@bellsouth.net)
media/usb/gspca/stv0680.c:37:MODULE_DESCRIPTION("STV0680 USB Camera Driver");
media/usb/gspca/stv0680.c:101:		PERR("Get_Camera_Mode failed");
media/usb/gspca/stv0680.c:119:		PERR("Set_Camera_Mode failed");
media/usb/gspca/stv0680.c:125:		PERR("Error setting camera video mode!");
media/usb/gspca/stv0680.c:142:	/* Give the camera some time to settle, otherwise initalization will
media/usb/gspca/stv0680.c:146:	/* ping camera to be sure STV0680 is present */
media/usb/gspca/stv0680.c:149:		PERR("STV(e): camera ping failed!!");
media/usb/gspca/stv0680.c:153:	/* get camera descriptor */
media/usb/gspca/stv0680.c:170:		PERR("Camera supports neither CIF nor QVGA mode");
media/usb/gspca/stv0680.c:174:		PDEBUG(D_PROBE, "Camera supports CIF mode");
media/usb/gspca/stv0680.c:176:		PDEBUG(D_PROBE, "Camera supports VGA mode");
media/usb/gspca/stv0680.c:178:		PDEBUG(D_PROBE, "Camera supports QCIF mode");
media/usb/gspca/stv0680.c:180:		PDEBUG(D_PROBE, "Camera supports QVGA mode");
media/usb/gspca/stv0680.c:250:/* -- start the camera -- */
media/usb/gspca/stv0680.c:296:	/* Every now and then the camera sends a 16 byte packet, no idea
media/usb/gspca/m5602/m5602_s5k4aa.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_s5k4aa.c:223:		PDEBUG(D_CONF, "Configuring camera for SXGA mode");
media/usb/gspca/m5602/m5602_s5k4aa.c:256:		PDEBUG(D_CONF, "Configuring camera for VGA mode");
media/usb/gspca/m5602/m5602_core.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_core.c:194:   unfortunately this breaks the camera until it's power cycled */
media/usb/gspca/m5602/m5602_core.c:275:	/* Send start command to the camera */
media/usb/gspca/m5602/m5602_ov7660.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_ov9650.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_ov9650.c:356:		PDEBUG(D_CONF, "Configuring camera for VGA mode");
media/usb/gspca/m5602/m5602_ov9650.c:364:		PDEBUG(D_CONF, "Configuring camera for CIF mode");
media/usb/gspca/m5602/m5602_ov9650.c:372:		PDEBUG(D_CONF, "Configuring camera for QVGA mode");
media/usb/gspca/m5602/m5602_ov9650.c:380:		PDEBUG(D_CONF, "Configuring camera for QCIF mode");
media/usb/gspca/m5602/m5602_po1030.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_mt9m111.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_mt9m111.c:234:		PDEBUG(D_CONF, "Configuring camera for VGA mode");
media/usb/gspca/m5602/m5602_mt9m111.c:238:		PDEBUG(D_CONF, "Configuring camera for QVGA mode");
media/usb/gspca/m5602/m5602_mt9m111.c:447:	pr_info("Dumping the mt9m111 camera control registers\n");
media/usb/gspca/m5602/m5602_mt9m111.c:448:	value[1] = MT9M111_CAMERA_CONTROL;
media/usb/gspca/m5602/m5602_s5k83a.c:11: * for SN9C10x PC Camera Controllers
media/usb/gspca/m5602/m5602_s5k83a.c:187:			pr_info("Camera was flipped\n");
media/usb/gspca/m5602/m5602_s5k83a.c:219:	/* Create another thread, polling the GPIO ports of the camera to check
media/usb/gspca/m5602/m5602_s5k83a.c:406:/* Get camera rotation on Acer notebooks */
media/usb/gspca/ov534_9.c:47:MODULE_DESCRIPTION("GSPCA/OV534_9 USB Camera Driver");
media/usb/gspca/stv06xx/stv06xx_pb0100.c:260:	  this is only for getting the camera to work */
media/usb/gspca/stv06xx/stv06xx.c:36:MODULE_DESCRIPTION("STV06XX USB Camera Driver");
media/usb/gspca/stv06xx/stv06xx.c:256:	PDEBUG(D_PROBE, "Initializing camera");
media/usb/gspca/stv06xx/stv06xx.c:281:/* Start the camera */
media/usb/gspca/stv06xx/stv06xx.c:509:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/stv06xx/stv06xx.c:515:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/stv06xx/stv06xx.c:549:	PDEBUG(D_PROBE, "Configuring camera");
media/usb/gspca/gl860/gl860-mi1320.c:182:static int  mi1320_camera_settings(struct gspca_dev *gspca_dev);
media/usb/gspca/gl860/gl860-mi1320.c:213:	sd->dev_camera_settings = mi1320_camera_settings;
media/usb/gspca/gl860/gl860-mi1320.c:289:	mi1320_camera_settings(gspca_dev);
media/usb/gspca/gl860/gl860-mi1320.c:348:static int mi1320_camera_settings(struct gspca_dev *gspca_dev)
media/usb/gspca/gl860/gl860-ov2640.c:180:static int  ov2640_camera_settings(struct gspca_dev *gspca_dev);
media/usb/gspca/gl860/gl860-ov2640.c:210:	sd->dev_camera_settings = ov2640_camera_settings;
media/usb/gspca/gl860/gl860-ov2640.c:324:	ov2640_camera_settings(gspca_dev);
media/usb/gspca/gl860/gl860-ov2640.c:347:static int ov2640_camera_settings(struct gspca_dev *gspca_dev)
media/usb/gspca/gl860/gl860.c:28:MODULE_DESCRIPTION("Genesys Logic USB PC Camera Driver");
media/usb/gspca/gl860/gl860.c:507:		sd->dev_camera_settings(gspca_dev);
media/usb/gspca/gl860/gl860-mi2020.c:288:static int  mi2020_camera_settings(struct gspca_dev *gspca_dev);
media/usb/gspca/gl860/gl860-mi2020.c:319:	sd->dev_camera_settings = mi2020_camera_settings;
media/usb/gspca/gl860/gl860-mi2020.c:538:	mi2020_camera_settings(gspca_dev);
media/usb/gspca/gl860/gl860-mi2020.c:561:static int mi2020_camera_settings(struct gspca_dev *gspca_dev)
media/usb/gspca/gl860/gl860-ov9655.c:150:static int  ov9655_camera_settings(struct gspca_dev *gspca_dev);
media/usb/gspca/gl860/gl860-ov9655.c:178:	sd->dev_camera_settings = ov9655_camera_settings;
media/usb/gspca/gl860/gl860-ov9655.c:285:	ov9655_camera_settings(gspca_dev);
media/usb/gspca/gl860/gl860-ov9655.c:306:static int ov9655_camera_settings(struct gspca_dev *gspca_dev)
media/usb/gspca/sq930x.c:32:MODULE_DESCRIPTION("GSPCA/SQ930x USB Camera Driver");
media/usb/gspca/stk014.c:29:MODULE_DESCRIPTION("Syntek DV4000 (STK014) USB Camera Driver");
media/usb/gspca/stk014.c:179:/* set a camera parameter */
media/usb/gspca/stk014.c:246:/* -- start the camera -- */
media/usb/gspca/stk014.c:296:		PDEBUG(D_STREAM, "camera started alt: 0x%02x",
media/usb/gspca/stk014.c:318:	PDEBUG(D_STREAM, "camera stopped");
media/usb/gspca/xirlink_cit.c:2: * USB IBM C-It Video Camera driver
media/usb/gspca/xirlink_cit.c:4: * Supports Xirlink C-It Video Camera, IBM PC Camera,
media/usb/gspca/xirlink_cit.c:5: * IBM NetCamera and Veo Stingray.
media/usb/gspca/xirlink_cit.c:45:		 "Use IBM Netcamera Pro init sequences for Model 3 cams");
media/usb/gspca/xirlink_cit.c:675:/* TESTME the old ibmcam driver repeats certain commands to Model1 cameras, we
media/usb/gspca/xirlink_cit.c:719: * This procedure sends magic 3-command prefix to the camera.
media/usb/gspca/xirlink_cit.c:1287:		 * very internal image processing settings in the camera.
media/usb/gspca/xirlink_cit.c:1362: * Camera model 1:
media/usb/gspca/xirlink_cit.c:1365: * Camera model 2:
media/usb/gspca/xirlink_cit.c:1367: * low light. But values above 5 or so are useless because camera is
media/usb/gspca/xirlink_cit.c:1369: * This setting may be altered only in certain camera state.
media/usb/gspca/xirlink_cit.c:1375: * 2/20/00  Added support for Model 2 cameras.
media/usb/gspca/xirlink_cit.c:1878:	 * (fastest). The camera model 2 allows frame rate in range [0..0x1F]
media/usb/gspca/xirlink_cit.c:1940:	   auto-detecting between model3 and ibm netcamera pro */
media/usb/gspca/xirlink_cit.c:1958:	   auto-detecting between model3 and ibm netcamera pro */
media/usb/gspca/xirlink_cit.c:2593:/* -- start the camera -- */
media/usb/gspca/xirlink_cit.c:2747:		/* HDG windows does this, but I cannot get the camera
media/usb/gspca/xirlink_cit.c:2765:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/xirlink_cit.c:2942:		input_report_key(gspca_dev->input_dev, KEY_CAMERA,
media/usb/gspca/topro.c:4552:/* -- start the camera -- */
media/usb/gspca/konica.c:3: * chipset is used in Intel YC76 camera.
media/usb/gspca/konica.c:39:MODULE_DESCRIPTION("Konica chipset USB Camera Driver");
media/usb/gspca/konica.c:253:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/konica.c:349:						 KEY_CAMERA,
media/usb/gspca/spca505.c:2: * SPCA505 chip based cameras initialization data
media/usb/gspca/spca505.c:29:MODULE_DESCRIPTION("GSPCA/SPCA505 USB Camera Driver");
media/usb/gspca/spca505.c:37:#define IntelPCCameraPro 0
media/usb/gspca/spca505.c:125: * Data to initialize the camera using the internal CCD
media/usb/gspca/spca505.c:307: * SPCA505b chip based cameras initialization data
media/usb/gspca/spca505.c:373: * Data to initialize the camera using the internal CCD
media/usb/gspca/spca505.c:610:	if (sd->subtype != IntelPCCameraPro)
media/usb/gspca/spca505.c:612:	else			/* no 640x480 for IntelPCCameraPro */
media/usb/gspca/spca505.c:779:	{USB_DEVICE(0x0733, 0x0430), .driver_info = IntelPCCameraPro},
media/usb/gspca/sq905.c:24: * The original Linux driver for SQ905 based cameras was written by
media/usb/gspca/sq905.c:46:MODULE_DESCRIPTION("GSPCA/SQ905 USB Camera Driver");
media/usb/gspca/sq905.c:67: * the ID appears to indicate the camera can do 640*480. If the
media/usb/gspca/sq905.c:114: * Send a command to the camera.
media/usb/gspca/sq905.c:205: * This function is called as a workqueue function and runs whenever the camera
media/usb/gspca/sq905.c:210: * as the camera doesn't provide any controls.
media/usb/gspca/sq905.c:334:	/* connect to the camera and read
media/usb/gspca/sq905.c:347:	 * Camera model number is the right way round if we assume this
media/usb/gspca/sq905.c:353:	PDEBUG(D_CONF, "SQ905 camera ID %08x detected", ident);
media/usb/gspca/finepix.c:48: * the camera will return old frames. On the 4800Z, 20ms is bad, 25ms
media/usb/gspca/finepix.c:53:/* These cameras only support 320x200. */
media/usb/gspca/finepix.c:81: * This function is called as a workqueue function and runs whenever the camera
media/usb/gspca/finepix.c:86: * as the camera doesn't provide any controls.
media/usb/gspca/finepix.c:163:		 * the camera will disconnect. */
media/usb/gspca/finepix.c:194:/* start the camera */
media/usb/gspca/w996Xcf.c:3: * GSPCA sub driver for W996[78]CF JPEG USB Dual Mode Camera Chip.
media/usb/gspca/spca508.c:2: * SPCA508 chip based cameras subdriver
media/usb/gspca/spca508.c:28:MODULE_DESCRIPTION("GSPCA/SPCA508 USB Camera Driver");
media/usb/gspca/spca508.c:39:#define IntelEasyPCCamera 3
media/usb/gspca/spca508.c:484: * Initialization data for Intel EasyPC Camera CS110
media/usb/gspca/spca508.c:1360:		spca508cs110_init_data,		/* IntelEasyPCCamera 3 */
media/usb/gspca/spca508.c:1510:	{USB_DEVICE(0x8086, 0x0110), .driver_info = IntelEasyPCCamera},
media/usb/gspca/jeilinj.c:4: * Supports some Jeilin dual-mode cameras which use bulk transport and
media/usb/gspca/jeilinj.c:36:MODULE_DESCRIPTION("GSPCA/JEILINJ USB Camera Driver");
media/usb/gspca/jeilinj.c:79:/* AFAICT these cameras will only do 320x240. */
media/usb/gspca/jeilinj.c:155:	/* adapt camera quality from jpeg quality */
media/usb/gspca/mars.c:30:MODULE_DESCRIPTION("GSPCA/Mars USB Camera Driver");
media/usb/gspca/tv8532.c:2: * Quickcam cameras initialization data
media/usb/gspca/tv8532.c:26:MODULE_DESCRIPTION("TV8532 USB Camera Driver");
media/usb/gspca/tv8532.c:216:/* -- start the camera -- */
media/usb/gspca/pac7302.c:8: * Camera button input handling by Márton Németh <nm127@freemail.hu>
media/usb/gspca/pac7302.c:48: *		0x50 Values >= this switch the camera to a lower compression,
media/usb/gspca/pac7302.c:515:	 * on the scene being recorded, the camera switches to another
media/usb/gspca/pac7302.c:703:/* -- start the camera -- */
media/usb/gspca/pac7302.c:909:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/pac7302.c:911:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/pac207.c:289:/* -- start the camera -- */
media/usb/gspca/pac207.c:424:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/pac207.c:426:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/mr97310a.c:7: * Support for the MR97310A cameras in addition to the Aiptek Pencam VGA+
media/usb/gspca/mr97310a.c:8: * and for the routines for detecting and classifying these various cameras,
media/usb/gspca/mr97310a.c:11: * Support for the control settings for the CIF cameras is
media/usb/gspca/mr97310a.c:15: * Support for the control settings for the VGA cameras is
media/usb/gspca/mr97310a.c:18: * Several previously unsupported cameras are owned and have been tested by
media/usb/gspca/mr97310a.c:26: * of the registers in these cameras.
media/usb/gspca/mr97310a.c:77:MODULE_DESCRIPTION("GSPCA/Mars-Semi MR97310A USB Camera Driver");
media/usb/gspca/mr97310a.c:364:	/* Several of the supported CIF cameras share the same USB ID but
media/usb/gspca/mr97310a.c:366:	 * The same is true of the VGA cameras. Therefore, we are forced
media/usb/gspca/mr97310a.c:368:	 * camera is present. Some of the supported cameras require the
media/usb/gspca/mr97310a.c:389:		 * All but one of the known CIF cameras share the same USB ID,
media/usb/gspca/mr97310a.c:391:		 * settings are different, too. We need to detect which camera
media/usb/gspca/mr97310a.c:394:		 * A list of known CIF cameras follows. They all report either
media/usb/gspca/mr97310a.c:421:		PDEBUG(D_PROBE, "MR97310A CIF camera detected, sensor: %d",
media/usb/gspca/mr97310a.c:428:		 * type, from the known MR97310A VGA cameras. Six different
media/usb/gspca/mr97310a.c:429:		 * cameras of which five share the same USB ID.
media/usb/gspca/mr97310a.c:478:		PDEBUG(D_PROBE, "MR97310A VGA camera detected, sensor: %d",
media/usb/gspca/mr97310a.c:687:			/* These settings may be better for some cameras */
media/usb/gspca/mr97310a.c:743:			{0x1e, 0x00, {0x08}, 1}, /* moving jams the camera */
media/usb/gspca/mr97310a.c:761:	/* Some of the VGA cameras require the memory pointer
media/usb/gspca/mr97310a.c:953:	/* Setup controls depending on camera type */
media/usb/gspca/mr97310a.c:975:	 * different limits from the other mr97310a cameras, and separate gain
media/usb/gspca/mr97310a.c:976:	 * control for Sakar CyberPix camera. */
media/usb/gspca/mr97310a.c:978:	 * This control is disabled for CIF type 1 and VGA type 0 cameras.
media/usb/gspca/mr97310a.c:979:	 * It does not quite act linearly for the Argus QuickClix camera,
media/usb/gspca/gspca.c:2: * Main USB camera driver
media/usb/gspca/gspca.c:6: * Camera button input handling by Márton Németh
media/usb/gspca/gspca.c:59:MODULE_DESCRIPTION("GSPCA USB Camera Driver");
media/usb/gspca/gspca.c:175:		input_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);
media/usb/gspca/gspca.c:727:	 * If the camera:
media/usb/gspca/gspca.c:1319:			"USB Camera (%04x:%04x)",
media/usb/gspca/gspca.c:1339:	input->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/gspca/gspca.c:2140:	/* we don't handle multi-config cameras */
media/usb/gspca/sonixj.c:31:MODULE_DESCRIPTION("GSPCA/SONIX JPEG USB Camera Driver");
media/usb/gspca/sonixj.c:2176:/* -- start the camera -- */
media/usb/gspca/sonixj.c:2872:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/sonixj.c:2874:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/spca1528.c:29:MODULE_DESCRIPTION("SPCA1528 USB Camera Driver");
media/usb/gspca/spca1528.c:252:/* -- start the camera -- */
media/usb/gspca/conex.c:31:MODULE_DESCRIPTION("GSPCA USB Conexant Camera Driver");
media/usb/gspca/sunplus.c:30:MODULE_DESCRIPTION("GSPCA/SPCA5xx USB Camera Driver");
media/usb/gspca/jl2005bcd.c:29:MODULE_DESCRIPTION("JL2005B/C/D USB Camera Driver");
media/usb/gspca/jl2005bcd.c:50:	int block_size;	/* block size of camera */
media/usb/gspca/jl2005bcd.c:55:/* Camera has two resolution settings. What they are depends on model. */
media/usb/gspca/jl2005bcd.c:310: * This function is called as a workqueue function and runs whenever the camera
media/usb/gspca/jl2005bcd.c:315: * as the camera doesn't provide any controls.
media/usb/gspca/jl2005bcd.c:417:	/* For the rest, the camera needs to be detected */
media/usb/gspca/jl2005bcd.c:420:	 * First some JL2005B cameras
media/usb/gspca/jl2005bcd.c:423:	 * JL2005C cameras
media/usb/gspca/jl2005bcd.c:428:	 * Based upon this scanty evidence, we can detect a CIF camera by
media/usb/gspca/se401.c:2: * GSPCA Endpoints (formerly known as AOX) se401 USB Camera sub Driver
media/usb/gspca/se401.c:225:	/* Read the camera descriptor */
media/usb/gspca/se401.c:226:	se401_read_req(gspca_dev, SE401_REQ_GET_CAMERA_DESCRIPTOR, 1);
media/usb/gspca/se401.c:232:		se401_read_req(gspca_dev, SE401_REQ_GET_CAMERA_DESCRIPTOR, 0);
media/usb/gspca/se401.c:235:	/* Some cameras start with their LED on */
media/usb/gspca/se401.c:314:	/* See if the camera supports brightness */
media/usb/gspca/se401.c:336:/* -- start the camera -- */
media/usb/gspca/se401.c:343:	se401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 1, 1);
media/usb/gspca/se401.c:349:		se401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 1, 0);
media/usb/gspca/se401.c:394:	se401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 0, 0);
media/usb/gspca/se401.c:615:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, state);
media/usb/gspca/sq905c.c:39:MODULE_DESCRIPTION("GSPCA/SQ905C USB Camera Driver");
media/usb/gspca/sq905c.c:71: * Most of these cameras will do 640x480 and 320x240. 160x120 works
media/usb/gspca/sq905c.c:73: * The 0x2770:0x9050 cameras have max resolution of 320x240.
media/usb/gspca/sq905c.c:88:/* Send a command to the camera. */
media/usb/gspca/sq905c.c:127: * This function is called as a workqueue function and runs whenever the camera
media/usb/gspca/sq905c.c:132: * as the camera doesn't provide any controls.
media/usb/gspca/sq905c.c:213:		"SQ9050 camera detected"
media/usb/gspca/sq905c.c:262:	/* connect to the camera and reset it. */
media/usb/gspca/ov534.c:12: * PS3 Eye camera enhanced by Richard Kaswy http://kaswy.free.fr
media/usb/gspca/ov534.c:13: * PS3 Eye camera - brightness, contrast, awb, agc, aec controls
media/usb/gspca/ov534.c:54:MODULE_DESCRIPTION("GSPCA/OV534 USB Camera Driver");
media/usb/gspca/autogain_functions.c:97:/* Autogain + exposure algorithm for cameras with a coarse exposure control
media/usb/gspca/spca501.c:2: * SPCA501 chip based cameras initialization data
media/usb/gspca/spca501.c:29:MODULE_DESCRIPTION("GSPCA/SPCA501 USB Camera Driver");
media/usb/gspca/spca501.c:43:#define Arowana300KCMOSCamera 0
media/usb/gspca/spca501.c:46:#define MystFromOriUnknownCamera 3
media/usb/gspca/spca501.c:47:#define SmileIntlCamera 4
media/usb/gspca/spca501.c:113:/* Data for video camera initialization before capturing */
media/usb/gspca/spca501.c:503:/* Data for video camera init before capture.
media/usb/gspca/spca501.c:595: * I have a "SPCA501C pc camera chipset" manual by sunplus, but some
media/usb/gspca/spca501.c:1556:/* Unknown camera from Ori Usbid 0x0000:0x0000 */
media/usb/gspca/spca501.c:1842:	case Arowana300KCMOSCamera:
media/usb/gspca/spca501.c:1843:	case SmileIntlCamera:
media/usb/gspca/spca501.c:1844:		/* Arowana 300k CMOS Camera data */
media/usb/gspca/spca501.c:1848:	case MystFromOriUnknownCamera:
media/usb/gspca/spca501.c:1849:		/* Unknown Ori CMOS Camera data */
media/usb/gspca/spca501.c:1875:	case Arowana300KCMOSCamera:
media/usb/gspca/spca501.c:1876:	case SmileIntlCamera:
media/usb/gspca/spca501.c:1877:		/* Arowana 300k CMOS Camera data */
media/usb/gspca/spca501.c:1880:	case MystFromOriUnknownCamera:
media/usb/gspca/spca501.c:1881:		/* Unknown CMOS Camera data */
media/usb/gspca/spca501.c:2020:	{USB_DEVICE(0x0497, 0xc001), .driver_info = SmileIntlCamera},
media/usb/gspca/spca501.c:2024:	{USB_DEVICE(0x1776, 0x501c), .driver_info = Arowana300KCMOSCamera},
media/usb/gspca/spca501.c:2025:	{USB_DEVICE(0x0000, 0x0000), .driver_info = MystFromOriUnknownCamera},
media/usb/gspca/spca561.c:31:MODULE_DESCRIPTION("GSPCA/SPCA561 USB Camera Driver");
media/usb/gspca/spca561.c:742:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/spca561.c:744:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/vicam.c:43:MODULE_DESCRIPTION("GSPCA ViCam USB Camera Driver");
media/usb/gspca/vicam.c:98:static int vicam_set_camera_power(struct gspca_dev *gspca_dev, int state)
media/usb/gspca/vicam.c:174: * This function is called as a workqueue function and runs whenever the camera
media/usb/gspca/vicam.c:179: * as the cameras controls are only written from the workqueue.
media/usb/gspca/vicam.c:277:	ret = vicam_set_camera_power(gspca_dev, 1);
media/usb/gspca/vicam.c:302:		vicam_set_camera_power(gspca_dev, 0);
media/usb/gspca/zc3xx.c:30:MODULE_DESCRIPTION("GSPCA ZC03xx/VC3xx USB Camera Driver");
media/usb/gspca/zc3xx.c:6910:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/zc3xx.c:6912:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/sn9c20x.c:35:MODULE_DESCRIPTION("GSPCA/SN9C20X USB Camera Driver");
media/usb/gspca/sn9c20x.c:64:/* camera flags */
media/usb/gspca/sn9c20x.c:66:#define LED_REVERSE	0x2 /* some cameras unset gpio to turn on leds */
media/usb/gspca/sn9c20x.c:1986:			pr_warn("sn9c20x camera with unknown number of alt "
media/usb/gspca/sn9c20x.c:2216:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/sn9c20x.c:2218:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/ov519.c:53:MODULE_DESCRIPTION("OV519 USB Camera Driver");
media/usb/gspca/ov519.c:455:/* OV511 Camera interface register numbers */
media/usb/gspca/ov519.c:481:/* OV518 Camera interface register numbers */
media/usb/gspca/ov519.c:485:/* OV519 Camera interface register numbers */
media/usb/gspca/ov519.c:636:/* Settings for OV2610 camera chip */
media/usb/gspca/ov519.c:2209:		/* Select camera register */
media/usb/gspca/ov519.c:2241:		/* Select camera register */
media/usb/gspca/ov519.c:2313:	/* Select camera register */
media/usb/gspca/ov519.c:2339:	/* Select camera register */
media/usb/gspca/ov519.c:2489: * registers while the camera is streaming */
media/usb/gspca/ov519.c:2751:			PERR("Error detecting camera chip PID\n");
media/usb/gspca/ov519.c:2756:			PERR("Error detecting camera chip VER\n");
media/usb/gspca/ov519.c:2815:		pr_warn("WARNING: Sensor is an OV66308. Your camera may have been misdetected in previous driver versions.\n");
media/usb/gspca/ov519.c:2831:		pr_warn("WARNING: Sensor is an OV66307. Your camera may have been misdetected in previous driver versions.\n");
media/usb/gspca/ov519.c:4208:/* -- start the camera -- */
media/usb/gspca/ov519.c:4269:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/ov519.c:4284:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, state);
media/usb/gspca/sonixb.c:56:MODULE_DESCRIPTION("GSPCA/SN9C102 USB Camera Driver");
media/usb/gspca/sonixb.c:1098:/* -- start the camera -- */
media/usb/gspca/sonixb.c:1397:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/sonixb.c:1399:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/t613.c:38:MODULE_DESCRIPTION("GSPCA/T613 (JPEG Compliance) USB Camera Driver");
media/usb/gspca/t613.c:829:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/t613.c:849:						 KEY_CAMERA, state);
media/usb/gspca/benq.c:28:MODULE_DESCRIPTION("Benq DC E300 USB Camera Driver");
media/usb/gspca/benq.c:84:/* -- start the camera -- */
media/usb/gspca/pac7311.c:33: *		0x01 Use this to allow the camera to switch to higher compr.
media/usb/gspca/pac7311.c:36: *		0x2a Values >= this switch the camera to a lower compression,
media/usb/gspca/pac7311.c:337:	 * camera to use higher compression or we may run out of
media/usb/gspca/pac7311.c:444:/* -- start the camera -- */
media/usb/gspca/pac7311.c:642:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
media/usb/gspca/pac7311.c:644:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/spca500.c:2: * SPCA500 chip based cameras initialization data
media/usb/gspca/spca500.c:30:MODULE_DESCRIPTION("GSPCA/SPCA500 USB Camera Driver");
media/usb/gspca/spca500.c:46:#define IntelPocketPCCamera 6
media/usb/gspca/spca500.c:559:	/* switch to video camera mode */
media/usb/gspca/spca500.c:593:	/* initialisation of spca500 based cameras is deferred */
media/usb/gspca/spca500.c:646:		/* switch to video camera mode */
media/usb/gspca/spca500.c:674:		/* switch to video camera mode */
media/usb/gspca/spca500.c:685:	case IntelPocketPCCamera:	/* FIXME: Temporary fix for
media/usb/gspca/spca500.c:686:					 *	Intel Pocket PC Camera
media/usb/gspca/spca500.c:708:		/* switch to video camera mode */
media/usb/gspca/spca500.c:738:		/* switch to video camera mode */
media/usb/gspca/spca500.c:779:		/* switch to video camera mode */
media/usb/gspca/spca500.c:806:		/* switch to video camera mode */
media/usb/gspca/spca500.c:823:	/* switch to video camera mode */
media/usb/gspca/spca500.c:965:	{USB_DEVICE(0x8086, 0x0630), .driver_info = IntelPocketPCCamera},
media/usb/gspca/cpia1.c:70:/* Return offsets for GetCameraState */
media/usb/gspca/cpia1.c:146:#define CPIA_COMMAND_GetCameraStatus	(INPUT | CPIA_MODULE_CPIA | 3)
media/usb/gspca/cpia1.c:151:#define CPIA_COMMAND_ModifyCameraStatus	(OUTPUT | CPIA_MODULE_CPIA | 10)
media/usb/gspca/cpia1.c:259:		u16 cameraHeadID;
media/usb/gspca/cpia1.c:366:	struct cam_params params;		/* camera settings */
media/usb/gspca/cpia1.c:380:		   the camera will pad out usb frames, making the image
media/usb/gspca/cpia1.c:447:/* send an arbitrary command to the camera */
media/usb/gspca/cpia1.c:458:	case CPIA_COMMAND_GetCameraStatus:
media/usb/gspca/cpia1.c:502:	case CPIA_COMMAND_GetCameraStatus:
media/usb/gspca/cpia1.c:515:		sd->params.vpVersion.cameraHeadID =
media/usb/gspca/cpia1.c:544:			input_report_key(gspca_dev->input_dev, KEY_CAMERA, a);
media/usb/gspca/cpia1.c:565:/* send a command to the camera with an additional data transaction */
media/usb/gspca/cpia1.c:624:static void reset_camera_params(struct gspca_dev *gspca_dev)
media/usb/gspca/cpia1.c:630:	 * "Software Developer's Guide for CPiA Cameras".  Any changes
media/usb/gspca/cpia1.c:721:	ret = do_command(gspca_dev, CPIA_COMMAND_GetCameraStatus, 0, 0, 0, 0);
media/usb/gspca/cpia1.c:734:	PDEBUG(D_CONF, "camera now in LOW power state");
media/usb/gspca/cpia1.c:752:	ret = do_command(gspca_dev, CPIA_COMMAND_GetCameraStatus, 0, 0, 0, 0);
media/usb/gspca/cpia1.c:763:	PDEBUG(D_CONF, "camera now in HIGH power state");
media/usb/gspca/cpia1.c:780:static int save_camera_state(struct gspca_dev *gspca_dev)
media/usb/gspca/cpia1.c:1149:	/* get necessary stats and register settings from camera */
media/usb/gspca/cpia1.c:1409:	  see how far away camera exposure is from a valid
media/usb/gspca/cpia1.c:1436:	reset_camera_params(gspca_dev);
media/usb/gspca/cpia1.c:1438:	PDEBUG(D_PROBE, "cpia CPiA camera detected (vid/pid 0x%04X:0x%04X)",
media/usb/gspca/cpia1.c:1467:/* -- start the camera -- */
media/usb/gspca/cpia1.c:1473:	/* Start the camera in low power mode */
media/usb/gspca/cpia1.c:1504:	 * the camera powers up (developer's guide p 3-38) */
media/usb/gspca/cpia1.c:1508:	ret = do_command(gspca_dev, CPIA_COMMAND_ModifyCameraStatus,
media/usb/gspca/cpia1.c:1518:	/* Check the camera status */
media/usb/gspca/cpia1.c:1519:	ret = do_command(gspca_dev, CPIA_COMMAND_GetCameraStatus, 0, 0, 0, 0);
media/usb/gspca/cpia1.c:1529:	/* VPVersion can't be retrieved before the camera is in HiPower,
media/usb/gspca/cpia1.c:1560:	/* And now set the camera to a known state */
media/usb/gspca/cpia1.c:1631:	/* save camera state for later open (developers guide ch 3.5.3) */
media/usb/gspca/cpia1.c:1632:	save_camera_state(gspca_dev);
media/usb/gspca/cpia1.c:1637:	/* Update the camera status */
media/usb/gspca/cpia1.c:1638:	do_command(gspca_dev, CPIA_COMMAND_GetCameraStatus, 0, 0, 0, 0);
media/usb/gspca/cpia1.c:1643:		/* The camera latch will hold the pressed state until we reset
media/usb/gspca/cpia1.c:1646:		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
media/usb/gspca/cpia1.c:1658:	/* Start / Stop the camera to make sure we are talking to
media/usb/gspca/cpia1.c:1659:	   a supported camera, and to get some information from it
media/usb/gspca/cpia1.c:1683:			sd->params.vpVersion.cameraHeadID);
media/usb/gspca/cpia1.c:1747:	/* Update our knowledge of the camera state */
media/usb/gspca/kinect.c:2: * kinect sensor device camera, gspca driver
media/usb/gspca/kinect.c:36:MODULE_DESCRIPTION("GSPCA/Kinect Sensor Device USB Camera Driver");
media/usb/gspca/kinect.c:76:static const struct v4l2_pix_format video_camera_mode[] = {
media/usb/gspca/kinect.c:235:	cam->cam_mode = video_camera_mode;
media/usb/gspca/kinect.c:236:	cam->nmodes = ARRAY_SIZE(video_camera_mode);
media/usb/gspca/kinect.c:250:	PDEBUG(D_PROBE, "Kinect Camera device.");
media/usb/gspca/kinect.c:301:	 * and stop the depth stream before the camera will hand us 1280x1024
media/usb/gspca/nw80x.c:30:MODULE_DESCRIPTION("NW80x USB Camera Driver");
media/usb/gspca/nw80x.c:1849:/* -- start the camera -- */
media/usb/em28xx/em28xx-input.c:33:#define EM28XX_SNAPSHOT_KEY KEY_CAMERA
media/usb/em28xx/em28xx-camera.c:2:   em28xx-camera.c - driver for Empia EM25xx/27xx/28xx USB video capture devices
media/usb/em28xx/em28xx-camera.c:23:#include <media/soc_camera.h>
media/usb/em28xx/em28xx-camera.c:46:static struct soc_camera_link camlink = {
media/usb/em28xx/em28xx-camera.c:326:int em28xx_init_camera(struct em28xx *dev)
media/usb/em28xx/em28xx-i2c.c:712:		/* TODO: decrypt eeprom data for camera bridges (em25xx, em276x+) */
media/usb/em28xx/em28xx-cards.c:2789:	em28xx_init_camera(dev);
media/usb/em28xx/em28xx-video.c:11:	Some parts based on SN9C10x PC Camera Controllers GPL driver made
media/usb/em28xx/em28xx-video.c:1161:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/uvc/uvc_video.c:145:		/* The bandwidth estimate is too low for many cameras. Don't use
media/usb/uvc/uvc_video.c:148:		 * different camera models, the value is high enough to get most
media/usb/uvc/uvc_video.c:179:		/* Some cameras, mostly based on Bison Electronics chipsets,
media/usb/uvc/uvc_video.c:191:		/* Many cameras don't support the GET_DEF request on their
media/usb/uvc/uvc_video.c:1741: * Some cameras (namely the Fuji Finepix) set the format and frame
media/usb/uvc/uvc_v4l2.c:738:		if (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)
media/usb/uvc/uvc_v4l2.c:739:			input->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/uvc/uvc_v4l2.c:1069:	/* Analog video standards make no sense for digital cameras. */
media/usb/uvc/uvc_ctrl.c:199:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:207:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:216:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:224:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:233:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:240:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:250:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:260:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:270:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:278:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:288:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:298:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:308:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:318:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:328:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:338:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:346:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:503:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:516:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:526:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:597:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:609:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:620:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:630:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:640:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:650:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:662:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:672:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:682:		.entity		= UVC_GUID_UVC_CAMERA,
media/usb/uvc/uvc_ctrl.c:777:static const __u8 uvc_camera_guid[16] = UVC_GUID_UVC_CAMERA;
media/usb/uvc/uvc_ctrl.c:785:	case UVC_ITT_CAMERA:
media/usb/uvc/uvc_ctrl.c:786:		return memcmp(uvc_camera_guid, guid, 16) == 0;
media/usb/uvc/uvc_ctrl.c:906:			 * cameras still choke on it. Ignore errors and set the
media/usb/uvc/uvc_ctrl.c:1983: * are currently the ones that crash the camera or unconditionally return an
media/usb/uvc/uvc_ctrl.c:1999:	static const struct uvc_ctrl_blacklist camera_blacklist[] = {
media/usb/uvc/uvc_ctrl.c:2017:	case UVC_ITT_CAMERA:
media/usb/uvc/uvc_ctrl.c:2018:		blacklist = camera_blacklist;
media/usb/uvc/uvc_ctrl.c:2019:		count = ARRAY_SIZE(camera_blacklist);
media/usb/uvc/uvc_ctrl.c:2020:		controls = entity->camera.bmControls;
media/usb/uvc/uvc_ctrl.c:2021:		size = entity->camera.bControlSize;
media/usb/uvc/uvc_ctrl.c:2101:		} else if (UVC_ENTITY_TYPE(entity) == UVC_ITT_CAMERA) {
media/usb/uvc/uvc_ctrl.c:2102:			bmControls = entity->camera.bmControls;
media/usb/uvc/uvc_ctrl.c:2103:			bControlSize = entity->camera.bControlSize;
media/usb/uvc/uvc_driver.c:977:		if (type == UVC_ITT_CAMERA) {
media/usb/uvc/uvc_driver.c:999:		if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {
media/usb/uvc/uvc_driver.c:1000:			term->camera.bControlSize = n;
media/usb/uvc/uvc_driver.c:1001:			term->camera.bmControls = (__u8 *)term + sizeof *term;
media/usb/uvc/uvc_driver.c:1002:			term->camera.wObjectiveFocalLengthMin =
media/usb/uvc/uvc_driver.c:1004:			term->camera.wObjectiveFocalLengthMax =
media/usb/uvc/uvc_driver.c:1006:			term->camera.wOcularFocalLength =
media/usb/uvc/uvc_driver.c:1008:			memcpy(term->camera.bmControls, &buffer[15], n);
media/usb/uvc/uvc_driver.c:1023:		else if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)
media/usb/uvc/uvc_driver.c:1024:			sprintf(term->name, "Camera %u", buffer[3]);
media/usb/uvc/uvc_driver.c:1195:	 * handle the interrupt endpoint for those cameras.
media/usb/uvc/uvc_driver.c:1228: * - one or more Input Terminals (Camera, External or USB Streaming)
media/usb/uvc/uvc_driver.c:1291:	case UVC_ITT_CAMERA:
media/usb/uvc/uvc_driver.c:1439:	case UVC_ITT_CAMERA:
media/usb/uvc/uvc_driver.c:1852:			"UVC Camera (%04x:%04x)",
media/usb/uvc/uvc_driver.c:2050: * The Logitech cameras listed below have their interface class set to
media/usb/uvc/uvc_driver.c:2131:	/* Logitech Quickcam OEM Cisco VT Camera II */
media/usb/uvc/uvc_driver.c:2185:	/* Genesys Logic USB 2.0 PC Camera */
media/usb/uvc/uvc_driver.c:2339:	/* Aveo Technology USB 2.0 Camera */
media/usb/uvc/uvc_driver.c:2385:	/* The Imaging Source USB CCD cameras */
media/usb/uvc/uvc_driver.c:2413:	/* SiGma Micro USB Web Camera */
media/usb/uvc/uvc_status.c:44:	__set_bit(KEY_CAMERA, input->keybit);
media/usb/uvc/uvc_status.c:94:		uvc_input_report_key(dev, KEY_CAMERA, data[3]);
media/usb/cx231xx/cx231xx-video.c:1054:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/usbvision/usbvision-video.c:373:	/* If so far no errors then we shall start the camera */
media/usb/usbvision/usbvision-video.c:551:		vi->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/usbvision/usbvision-video.c:559:		vi->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/usbvision/usbvision-video.c:567:		vi->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/usbvision/usbvision-cards.c:141:	[X10_USB_CAMERA] = {
media/usb/usbvision/usbvision-cards.c:153:		.model_string   = "X10 USB Camera",
media/usb/usbvision/usbvision-cards.c:1070:	{ USB_DEVICE(0x0573, 0x2000), .driver_info = X10_USB_CAMERA },
media/usb/tm6000/tm6000-video.c:1105:		i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/zr364xx/zr364xx.c:53:/* Camera */
media/usb/zr364xx/zr364xx.c:99: * .driver_info contains the init method used by the camera */
media/usb/zr364xx/zr364xx.c:143:	struct zr364xx_camera	*cam;
media/usb/zr364xx/zr364xx.c:151:	void *cam;	/* back pointer to zr364xx_camera struct */
media/usb/zr364xx/zr364xx.c:171:/* Camera stuff */
media/usb/zr364xx/zr364xx.c:172:struct zr364xx_camera {
media/usb/zr364xx/zr364xx.c:209:/* function used to send initialisation commands to the camera */
media/usb/zr364xx/zr364xx.c:235:/* Control messages sent to the camera to initialize it
media/usb/zr364xx/zr364xx.c:363:	struct zr364xx_camera *cam = vq->priv_data;
media/usb/zr364xx/zr364xx.c:390:	struct zr364xx_camera *cam = vq->priv_data;
media/usb/zr364xx/zr364xx.c:429:	struct zr364xx_camera *cam = vq->priv_data;
media/usb/zr364xx/zr364xx.c:463:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:499:static void zr364xx_fillbuff(struct zr364xx_camera *cam,
media/usb/zr364xx/zr364xx.c:536:static int zr364xx_got_frame(struct zr364xx_camera *cam, int jpgsize)
media/usb/zr364xx/zr364xx.c:575:static int zr364xx_read_video_callback(struct zr364xx_camera *cam,
media/usb/zr364xx/zr364xx.c:590:	/* swap bytes if camera needs it */
media/usb/zr364xx/zr364xx.c:704:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:723:	strcpy(i->name, DRIVER_DESC " Camera");
media/usb/zr364xx/zr364xx.c:724:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/zr364xx/zr364xx.c:745:	struct zr364xx_camera *cam =
media/usb/zr364xx/zr364xx.c:746:		container_of(ctrl->handler, struct zr364xx_camera, ctrl_handler);
media/usb/zr364xx/zr364xx.c:787:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:819:	struct zr364xx_camera *cam;
media/usb/zr364xx/zr364xx.c:839:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:915:	/* Added some delay here, since opening/closing the camera quickly,
media/usb/zr364xx/zr364xx.c:934:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:946:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:956:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:969:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:980:	struct zr364xx_camera *cam;
media/usb/zr364xx/zr364xx.c:1041:static int zr364xx_start_readpipe(struct zr364xx_camera *cam)
media/usb/zr364xx/zr364xx.c:1073:static void zr364xx_stop_readpipe(struct zr364xx_camera *cam)
media/usb/zr364xx/zr364xx.c:1098:static int zr364xx_start_acquire(struct zr364xx_camera *cam)
media/usb/zr364xx/zr364xx.c:1114:static inline int zr364xx_stop_acquire(struct zr364xx_camera *cam)
media/usb/zr364xx/zr364xx.c:1120:static int zr364xx_prepare(struct zr364xx_camera *cam)
media/usb/zr364xx/zr364xx.c:1151:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:1176:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:1188:/* open the camera */
media/usb/zr364xx/zr364xx.c:1191:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:1203:	/* Added some delay here, since opening/closing the camera quickly,
media/usb/zr364xx/zr364xx.c:1217:	struct zr364xx_camera *cam =
media/usb/zr364xx/zr364xx.c:1218:		container_of(v4l2_dev, struct zr364xx_camera, v4l2_dev);
media/usb/zr364xx/zr364xx.c:1240:/* release the camera */
media/usb/zr364xx/zr364xx.c:1243:	struct zr364xx_camera *cam;
media/usb/zr364xx/zr364xx.c:1267:	/* Added some delay here, since opening/closing the camera quickly,
media/usb/zr364xx/zr364xx.c:1278:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:1298:	struct zr364xx_camera *cam = video_drvdata(file);
media/usb/zr364xx/zr364xx.c:1353:static int zr364xx_board_init(struct zr364xx_camera *cam)
media/usb/zr364xx/zr364xx.c:1416:	struct zr364xx_camera *cam = NULL;
media/usb/zr364xx/zr364xx.c:1430:	cam = kzalloc(sizeof(struct zr364xx_camera), GFP_KERNEL);
media/usb/zr364xx/zr364xx.c:1452:	/* save the init method used by this camera */
media/usb/zr364xx/zr364xx.c:1572:	struct zr364xx_camera *cam = usb_get_intfdata(intf);
media/usb/zr364xx/zr364xx.c:1593:	struct zr364xx_camera *cam = usb_get_intfdata(intf);
media/usb/zr364xx/zr364xx.c:1605:	struct zr364xx_camera *cam = usb_get_intfdata(intf);
media/usb/dvb-usb/opera1.c:367:	{0x07f9, KEY_CAMERA},		/*capture */
media/usb/dvb-usb/digitv.c:184:	{ 0x9f5a, KEY_CAMERA },     /* labelled 'Picture' */
media/usb/dvb-usb/a800.c:55:	{ 0x0217, KEY_CAMERA },      /* SNAP SHOT */
media/usb/dvb-usb/dw2102.c:1447:	{ 0xf805, KEY_CAMERA },		/*cap*/
media/usb/dvb-usb/cxusb.c:532:	{ 0xfe52, KEY_CAMERA },
media/usb/dvb-usb/cxusb.c:569:	{ 0xfc16, KEY_CAMERA },
media/usb/dvb-usb/m920x.c:734:	{ 0x000d, KEY_CAMERA }, /* screenshot */
media/usb/dvb-usb/m920x.c:740:	{ 0x0002, KEY_CAMERA }, /* snapshot */
media/usb/dvb-usb/m920x.c:796:	{ 0x54, KEY_CAMERA },		/* Capture */
media/usb/au0828/au0828-video.c:1419:		input->type |= V4L2_INPUT_TYPE_CAMERA;
media/usb/cpia2/cpia2_core.c:9: *     This is a USB driver for CPia2 based video cameras.
media/usb/cpia2/cpia2_core.c:63:static int apply_vp_patch(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:64:static int set_default_user_mode(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:65:static int set_vw_size(struct camera_data *cam, int size);
media/usb/cpia2/cpia2_core.c:66:static int configure_sensor(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:68:static int config_sensor_410(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:70:static int config_sensor_500(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:72:static int set_all_properties(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:73:static void wake_system(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:74:static void set_lowlight_boost(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:75:static void reset_camera_struct(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:76:static int cpia2_set_high_power(struct camera_data *cam);
media/usb/cpia2/cpia2_core.c:137: *  Send an arbitrary command to the camera.  For commands that read from
media/usb/cpia2/cpia2_core.c:138: *  the camera, copy the buffers into the proper param structures.
media/usb/cpia2/cpia2_core.c:140:int cpia2_do_command(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:157:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:162:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:167:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:171:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:175:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:181:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:191:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:198:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:208:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:215:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:222:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:229:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:235:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:243:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:248:		cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:262:		    CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:274:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:281:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:289:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:297:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:308:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:315:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:320:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:328:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:335:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:342:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:349:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:356:		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:362:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:369:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:374:		cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:380:		cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:393:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:403:		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:482:		cam->params.camera_state.system_ctrl = cmd.buffer.block_data[0];
media/usb/cpia2/cpia2_core.c:520:int cpia2_send_command(struct camera_data *cam, struct cpia2_command *cmd)
media/usb/cpia2/cpia2_core.c:528:	case CAMERAACCESS_TYPE_RANDOM:
media/usb/cpia2/cpia2_core.c:536:	case CAMERAACCESS_TYPE_BLOCK:
media/usb/cpia2/cpia2_core.c:544:	case CAMERAACCESS_TYPE_MASK:
media/usb/cpia2/cpia2_core.c:552:	case CAMERAACCESS_TYPE_REPEAT:	/* For patch blocks only */
media/usb/cpia2/cpia2_core.c:573:			if((cmd->req_mode & 0x0c) == CAMERAACCESS_TYPE_BLOCK)
media/usb/cpia2/cpia2_core.c:576:			if((cmd->req_mode & 0x0c) == CAMERAACCESS_TYPE_RANDOM)
media/usb/cpia2/cpia2_core.c:588: * Functions to implement camera functionality
media/usb/cpia2/cpia2_core.c:595:static void cpia2_get_version_info(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:606: *  cpia2_reset_camera
media/usb/cpia2/cpia2_core.c:610:int cpia2_reset_camera(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:630:	cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:647:		cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:667:		cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:734:	cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:781:	cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:840:static int cpia2_set_high_power(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:848:		if(cam->params.camera_state.system_ctrl &
media/usb/cpia2/cpia2_core.c:864:			cam->params.camera_state.power_mode = LO_POWER_MODE;
media/usb/cpia2/cpia2_core.c:865:			ERR("Camera did not wake up\n");
media/usb/cpia2/cpia2_core.c:871:	cam->params.camera_state.power_mode = HI_POWER_MODE;
media/usb/cpia2/cpia2_core.c:880:int cpia2_set_low_power(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:882:	cam->params.camera_state.power_mode = LO_POWER_MODE;
media/usb/cpia2/cpia2_core.c:892:static int cpia2_send_onebyte_command(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:902:static int apply_vp_patch(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:916:	cmd.req_mode = CAMERAACCESS_TYPE_REPEAT | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:947:static int set_default_user_mode(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1046:static int set_vw_size(struct camera_data *cam, int size)
media/usb/cpia2/cpia2_core.c:1116:static int configure_sensor(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:1143:static int config_sensor_410(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:1189:	cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:1329:static int config_sensor_500(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:1363:	cmd.req_mode = CAMERAACCESS_TYPE_RANDOM | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:1536:static int set_all_properties(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1544:					  cam->params.camera_state.stream_mode);
media/usb/cpia2/cpia2_core.c:1563: *  cpia2_save_camera_state
media/usb/cpia2/cpia2_core.c:1566:void cpia2_save_camera_state(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1581:int cpia2_set_flicker_mode(struct camera_data *cam, int mode)
media/usb/cpia2/cpia2_core.c:1654:void cpia2_set_property_flip(struct camera_data *cam, int prop_val)
media/usb/cpia2/cpia2_core.c:1679:void cpia2_set_property_mirror(struct camera_data *cam, int prop_val)
media/usb/cpia2/cpia2_core.c:1704:int cpia2_set_gpio(struct camera_data *cam, unsigned char setting)
media/usb/cpia2/cpia2_core.c:1737:int cpia2_set_fps(struct camera_data *cam, int framerate)
media/usb/cpia2/cpia2_core.c:1779:void cpia2_set_brightness(struct camera_data *cam, unsigned char value)
media/usb/cpia2/cpia2_core.c:1796:void cpia2_set_contrast(struct camera_data *cam, unsigned char value)
media/usb/cpia2/cpia2_core.c:1807:void cpia2_set_saturation(struct camera_data *cam, unsigned char value)
media/usb/cpia2/cpia2_core.c:1818:static void wake_system(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1829:static void set_lowlight_boost(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1838:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:1867:void cpia2_set_format(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1873:	/* reset camera to new size */
media/usb/cpia2/cpia2_core.c:1875:	cpia2_reset_camera(cam);
media/usb/cpia2/cpia2_core.c:1888:void cpia2_dbg_dump_registers(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:1899:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
media/usb/cpia2/cpia2_core.c:1911:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_core.c:2004:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
media/usb/cpia2/cpia2_core.c:2102: *  reset_camera_struct
media/usb/cpia2/cpia2_core.c:2106:static void reset_camera_struct(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:2163: *  cpia2_init_camera_struct
media/usb/cpia2/cpia2_core.c:2165: *  Initializes camera struct, does not call reset to fill in defaults.
media/usb/cpia2/cpia2_core.c:2167:struct camera_data *cpia2_init_camera_struct(struct usb_interface *intf)
media/usb/cpia2/cpia2_core.c:2169:	struct camera_data *cam;
media/usb/cpia2/cpia2_core.c:2178:	cam->v4l2_dev.release = cpia2_camera_release;
media/usb/cpia2/cpia2_core.c:2193: *  cpia2_init_camera
media/usb/cpia2/cpia2_core.c:2195: *  Initializes camera.
media/usb/cpia2/cpia2_core.c:2197:int cpia2_init_camera(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:2219:	reset_camera_struct(cam);
media/usb/cpia2/cpia2_core.c:2233:int cpia2_allocate_buffers(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:2282:void cpia2_free_buffers(struct camera_data *cam)
media/usb/cpia2/cpia2_core.c:2299:long cpia2_read(struct camera_data *cam,
media/usb/cpia2/cpia2_core.c:2313:		ERR("%s: Internal error, camera_data NULL!\n",__func__);
media/usb/cpia2/cpia2_core.c:2320:				       cam->params.camera_state.stream_mode);
media/usb/cpia2/cpia2_core.c:2359:unsigned int cpia2_poll(struct camera_data *cam, struct file *filp,
media/usb/cpia2/cpia2_core.c:2368:				       cam->params.camera_state.stream_mode);
media/usb/cpia2/cpia2_core.c:2384:int cpia2_remap_buffer(struct camera_data *cam, struct vm_area_struct *vma)
media/usb/cpia2/cpia2_v4l.c:10: *     This is a USB driver for CPia2 based video cameras.
media/usb/cpia2/cpia2_v4l.c:71:MODULE_DESCRIPTION("V4L-driver for STMicroelectronics CPiA2 based cameras");
media/usb/cpia2/cpia2_v4l.c:76:#define ABOUT "V4L-Driver for Vision CPiA2 based cameras"
media/usb/cpia2/cpia2_v4l.c:86:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:102:		/* reset the camera */
media/usb/cpia2/cpia2_v4l.c:103:		if (cpia2_reset_camera(cam) < 0) {
media/usb/cpia2/cpia2_v4l.c:127:	struct camera_data *cam = video_get_drvdata(dev);
media/usb/cpia2/cpia2_v4l.c:133:		/* save camera state for later open */
media/usb/cpia2/cpia2_v4l.c:134:		cpia2_save_camera_state(cam);
media/usb/cpia2/cpia2_v4l.c:156:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:178:	struct camera_data *cam = video_drvdata(filp);
media/usb/cpia2/cpia2_v4l.c:188:static int sync(struct camera_data *cam, int frame_nr)
media/usb/cpia2/cpia2_v4l.c:224:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:231:		strcpy(vc->card, "CPiA2 Camera");
media/usb/cpia2/cpia2_v4l.c:288:	strcpy(i->name, "Camera");
media/usb/cpia2/cpia2_v4l.c:289:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/cpia2/cpia2_v4l.c:351:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:413:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:463:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:488:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:523:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:542:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:605:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:640:	struct camera_data *cam =
media/usb/cpia2/cpia2_v4l.c:641:		container_of(ctrl->handler, struct camera_data, hdl);
media/usb/cpia2/cpia2_v4l.c:679:		cam->params.camera_state.stream_mode = ctrl->val;
media/usb/cpia2/cpia2_v4l.c:698:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:740:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:789:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:812:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:862:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:885:static int find_earliest_filled_buffer(struct camera_data *cam)
media/usb/cpia2/cpia2_v4l.c:918:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:967:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:976:				cam->params.camera_state.stream_mode);
media/usb/cpia2/cpia2_v4l.c:985:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:1007:	struct camera_data *cam = video_drvdata(file);
media/usb/cpia2/cpia2_v4l.c:1022: *  reset_camera_struct_v4l
media/usb/cpia2/cpia2_v4l.c:1026:static void reset_camera_struct_v4l(struct camera_data *cam)
media/usb/cpia2/cpia2_v4l.c:1038:	cam->params.camera_state.stream_mode = alternate;
media/usb/cpia2/cpia2_v4l.c:1084:	.name =		"CPiA2 Camera",
media/usb/cpia2/cpia2_v4l.c:1090:void cpia2_camera_release(struct v4l2_device *v4l2_dev)
media/usb/cpia2/cpia2_v4l.c:1092:	struct camera_data *cam =
media/usb/cpia2/cpia2_v4l.c:1093:		container_of(v4l2_dev, struct camera_data, v4l2_dev);
media/usb/cpia2/cpia2_v4l.c:1106: *  cpia2_register_camera
media/usb/cpia2/cpia2_v4l.c:1109:int cpia2_register_camera(struct camera_data *cam)
media/usb/cpia2/cpia2_v4l.c:1174:	reset_camera_struct_v4l(cam);
media/usb/cpia2/cpia2_v4l.c:1187: *  cpia2_unregister_camera
media/usb/cpia2/cpia2_v4l.c:1190:void cpia2_unregister_camera(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:9: *     This is a USB driver for CPia2 based video cameras.
media/usb/cpia2/cpia2_usb.c:52:static void process_frame(struct camera_data *cam);
media/usb/cpia2/cpia2_usb.c:60:static void free_sbufs(struct camera_data *cam);
media/usb/cpia2/cpia2_usb.c:61:static void add_APPn(struct camera_data *cam);
media/usb/cpia2/cpia2_usb.c:62:static void add_COM(struct camera_data *cam);
media/usb/cpia2/cpia2_usb.c:63:static int submit_urbs(struct camera_data *cam);
media/usb/cpia2/cpia2_usb.c:64:static int set_alternate(struct camera_data *cam, unsigned int alt);
media/usb/cpia2/cpia2_usb.c:65:static int configure_transfer_mode(struct camera_data *cam, unsigned int alt);
media/usb/cpia2/cpia2_usb.c:91:static void process_frame(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:145:			 * than it would for the camera to send
media/usb/cpia2/cpia2_usb.c:170:static void add_APPn(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:189:static void add_COM(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:213:	struct camera_data *cam = (struct camera_data *) urb->context;
media/usb/cpia2/cpia2_usb.c:384:static int configure_transfer_mode(struct camera_data *cam, unsigned int alt)
media/usb/cpia2/cpia2_usb.c:410:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_usb.c:420:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_usb.c:445:	cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
media/usb/cpia2/cpia2_usb.c:456:int cpia2_usb_change_streaming_alternate(struct camera_data *cam,
media/usb/cpia2/cpia2_usb.c:464:	if(alt == cam->params.camera_state.stream_mode)
media/usb/cpia2/cpia2_usb.c:471:	cam->params.camera_state.stream_mode = alt;
media/usb/cpia2/cpia2_usb.c:473:	/* Reset the camera to prevent image quality degradation */
media/usb/cpia2/cpia2_usb.c:474:	cpia2_reset_camera(cam);
media/usb/cpia2/cpia2_usb.c:486:static int set_alternate(struct camera_data *cam, unsigned int alt)
media/usb/cpia2/cpia2_usb.c:520:static void free_sbufs(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:589:int cpia2_usb_transfer_cmd(struct camera_data *cam,
media/usb/cpia2/cpia2_usb.c:637:static int submit_urbs(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:708:int cpia2_usb_stream_start(struct camera_data *cam, unsigned int alternate)
media/usb/cpia2/cpia2_usb.c:728:	old_alt = cam->params.camera_state.stream_mode;
media/usb/cpia2/cpia2_usb.c:729:	cam->params.camera_state.stream_mode = 0;
media/usb/cpia2/cpia2_usb.c:734:		cam->params.camera_state.stream_mode = old_alt;
media/usb/cpia2/cpia2_usb.c:755:int cpia2_usb_stream_pause(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:770:int cpia2_usb_stream_resume(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:775:		ret = set_alternate(cam, cam->params.camera_state.stream_mode);
media/usb/cpia2/cpia2_usb.c:792:int cpia2_usb_stream_stop(struct camera_data *cam)
media/usb/cpia2/cpia2_usb.c:813:	struct camera_data *cam;
media/usb/cpia2/cpia2_usb.c:816:	/* A multi-config CPiA2 camera? */
media/usb/cpia2/cpia2_usb.c:821:	/* If we get to this point, we found a CPiA2 camera */
media/usb/cpia2/cpia2_usb.c:822:	LOG("CPiA2 USB camera found\n");
media/usb/cpia2/cpia2_usb.c:824:	cam = cpia2_init_camera_struct(intf);
media/usb/cpia2/cpia2_usb.c:839:	if((ret = cpia2_init_camera(cam)) < 0) {
media/usb/cpia2/cpia2_usb.c:840:		ERR("%s: failed to initialize cpia2 camera (ret = %d)\n", __func__, ret);
media/usb/cpia2/cpia2_usb.c:859:	ret = cpia2_register_camera(cam);
media/usb/cpia2/cpia2_usb.c:861:		ERR("%s: Failed to register cpia2 camera (ret = %d)\n", __func__, ret);
media/usb/cpia2/cpia2_usb.c:876:	struct camera_data *cam = usb_get_intfdata(intf);
media/usb/cpia2/cpia2_usb.c:883:	DBG("Unregistering camera\n");
media/usb/cpia2/cpia2_usb.c:884:	cpia2_unregister_camera(cam);
media/usb/cpia2/cpia2_usb.c:900:	LOG("CPiA2 camera disconnected.\n");
media/usb/cpia2/cpia2_usb.c:905:	struct camera_data *cam = usb_get_intfdata(intf);
media/usb/cpia2/cpia2_usb.c:921:	struct camera_data *cam = usb_get_intfdata(intf);
media/usb/cpia2/cpia2_usb.c:928:				cam->params.camera_state.stream_mode);
media/usb/pvrusb2/pvrusb2-v4l2.c:245:		tmp.type = V4L2_INPUT_TYPE_CAMERA;
media/usb/pwc/pwc-v4l.c:511:	strlcpy(i->name, "Camera", sizeof(i->name));
media/usb/pwc/pwc-v4l.c:512:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/pwc/pwc-misc.c:45:	/* Find the largest size supported by the camera that fits into the
media/usb/pwc/pwc-ctrl.c:83:/* Entries for the Nala (645/646) camera; the Nala doesn't have compression
media/usb/pwc/pwc-ctrl.c:485:void pwc_camera_power(struct pwc_device *pdev, int power)
media/usb/pwc/pwc-ctrl.c:502:		PWC_ERROR("Failed to power %s camera (%d)\n",
media/usb/pwc/pwc-timon.c:26:/* This tables contains entries for the 675/680/690 (Timon) camera, with
media/usb/pwc/pwc-if.c:52:   - Mark Burazin: solving hang in VIDIOCSYNC when camera gets unplugged
media/usb/pwc/pwc-if.c:93:	{ USB_DEVICE(0x0471, 0x0329) }, /* Philips SPC 900NC PC Camera */
media/usb/pwc/pwc-if.c:101:	{ USB_DEVICE(0x046D, 0x08B6) }, /* Cisco VT Camera */
media/usb/pwc/pwc-if.c:184:		input_report_key(pdev->button_dev, KEY_CAMERA, down);
media/usb/pwc/pwc-if.c:664:	/* Turn on camera and set LEDS on */
media/usb/pwc/pwc-if.c:665:	pwc_camera_power(pdev, 1);
media/usb/pwc/pwc-if.c:670:		/* If we failed turn camera and LEDS back off */
media/usb/pwc/pwc-if.c:672:		pwc_camera_power(pdev, 0);
media/usb/pwc/pwc-if.c:689:		pwc_camera_power(pdev, 0);
media/usb/pwc/pwc-if.c:859:			PWC_INFO("Logitech/Cisco VT Camera webcam detected.\n");
media/usb/pwc/pwc-if.c:860:			name = "Cisco VT Camera";
media/usb/pwc/pwc-if.c:880:		   I suppose the difference is the sensor, but both cameras
media/usb/pwc/pwc-if.c:1033:		PWC_DEBUG_OPEN("This %s camera is equipped with a %s (%d).\n",
media/usb/pwc/pwc-if.c:1048:	/* Register controls (and read default values from camera */
media/usb/pwc/pwc-if.c:1055:	/* And powerdown the camera until streaming starts */
media/usb/pwc/pwc-if.c:1056:	pwc_camera_power(pdev, 0);
media/usb/pwc/pwc-if.c:1094:	pdev->button_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);
media/usb/pwc/pwc-if.c:1161:MODULE_PARM_DESC(power_save, "Turn power saving for new cameras on or off");
media/usb/pwc/pwc-kiara.c:26:/* This tables contains entries for the 730/740/750 (Kiara) camera, with
media/usb/sn9c102/sn9c102_tas5110d.c:2: * Plug-in for TAS5110D image sensor connected to the SN9C1xx PC Camera    *
media/usb/sn9c102/sn9c102_pas106b.c:2: * Plug-in for PAS106B image sensor connected to the SN9C1xx PC Camera     *
media/usb/sn9c102/sn9c102_core.c:2: * V4L2 driver for SN9C1xx PC Camera Controllers                           *
media/usb/sn9c102/sn9c102_core.c:46:#define SN9C102_MODULE_NAME     "V4L2 driver for SN9C1xx PC Camera Controllers"
media/usb/sn9c102/sn9c102_core.c:71:		 " cameras this way."
media/usb/sn9c102/sn9c102_core.c:74:		 "\nthe second camera and use auto for the first"
media/usb/sn9c102/sn9c102_core.c:75:		 "\none and for every other camera."
media/usb/sn9c102/sn9c102_core.c:87:		 "\ndetected camera."
media/usb/sn9c102/sn9c102_core.c:100:		 "\nThis parameter is specific for each detected camera."
media/usb/sn9c102/sn9c102_core.c:1008:		DBG(1, "URB timeout reached. The camera is misconfigured. "
media/usb/sn9c102/sn9c102_core.c:1902:		DBG(1, "The camera is misconfigured. Close and open it "
media/usb/sn9c102/sn9c102_core.c:2026:		DBG(1, "The camera is misconfigured. Close and open it "
media/usb/sn9c102/sn9c102_core.c:2104:		DBG(1, "The camera is misconfigured. Close and open it "
media/usb/sn9c102/sn9c102_core.c:2188:	strcpy(i.name, "Camera");
media/usb/sn9c102/sn9c102_core.c:2189:	i.type = V4L2_INPUT_TYPE_CAMERA;
media/usb/sn9c102/sn9c102_core.c:2438:		       "use the camera, close and open %s again.",
media/usb/sn9c102/sn9c102_core.c:2451:		       "use the camera, close and open %s again.",
media/usb/sn9c102/sn9c102_core.c:2697:		       "use the camera, close and open %s again.",
media/usb/sn9c102/sn9c102_core.c:2709:		       "use the camera, close and open %s again.",
media/usb/sn9c102/sn9c102_core.c:2756:		       "To use the camera, close and open %s again.",
media/usb/sn9c102/sn9c102_core.c:3213:		DBG(1, "The camera is misconfigured. Close and open it "
media/usb/sn9c102/sn9c102_core.c:3271:		DBG(1, "Sorry, this is not a SN9C1xx-based camera "
media/usb/sn9c102/sn9c102_core.c:3281:		DBG(2, "SN9C10[12] PC Camera Controller detected "
media/usb/sn9c102/sn9c102_core.c:3285:		DBG(2, "SN9C103 PC Camera Controller detected "
media/usb/sn9c102/sn9c102_core.c:3289:		DBG(2, "SN9C105 PC Camera Controller detected "
media/usb/sn9c102/sn9c102_core.c:3293:		DBG(2, "SN9C120 PC Camera Controller detected "
media/usb/sn9c102/sn9c102_core.c:3325:	strcpy(cam->v4ldev->name, "SN9C1xx PC Camera");
media/usb/sn9c102/sn9c102_mt9v111.c:2: * Plug-in for MT9V111 image sensor connected to the SN9C1xx PC Camera     *
media/usb/sn9c102/sn9c102_tas5130d1b.c:2: * Plug-in for TAS5130D1B image sensor connected to the SN9C1xx PC Camera  *
media/usb/sn9c102/sn9c102_mi0343.c:2: * Plug-in for MI-0343 image sensor connected to the SN9C1xx PC Camera     *
media/usb/sn9c102/sn9c102_hv7131r.c:2: * Plug-in for HV7131R image sensor connected to the SN9C1xx PC Camera     *
media/usb/sn9c102/sn9c102_hv7131d.c:2: * Plug-in for HV7131D image sensor connected to the SN9C1xx PC Camera     *
media/usb/sn9c102/sn9c102_pas202bcb.c:2: * Plug-in for PAS202BCB image sensor connected to the SN9C1xx PC Camera   *
media/usb/sn9c102/sn9c102_tas5110c1b.c:2: * Plug-in for TAS5110C1B image sensor connected to the SN9C1xx PC Camera  *
media/usb/sn9c102/sn9c102_mi0360.c:2: * Plug-in for MI-0360 image sensor connected to the SN9C1xx PC Camera     *
media/usb/sn9c102/sn9c102_ov7660.c:2: * Plug-in for OV7660 image sensor connected to the SN9C1xx PC Camera      *
media/usb/sn9c102/sn9c102_ov7630.c:2: * Plug-in for OV7630 image sensor connected to the SN9C1xx PC Camera      *
media/usb/hdpvr/hdpvr-video.c:756:	i->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/stkwebcam/stk-webcam.c:59:/* Some cameras have audio interfaces, we aren't interested in those */
media/usb/stkwebcam/stk-webcam.c:121:int stk_camera_write_reg(struct stk_camera *dev, u16 index, u8 value)
media/usb/stkwebcam/stk-webcam.c:140:int stk_camera_read_reg(struct stk_camera *dev, u16 index, int *value)
media/usb/stkwebcam/stk-webcam.c:159:static int stk_start_stream(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:178:	stk_camera_read_reg(dev, 0x0116, &value_116);
media/usb/stkwebcam/stk-webcam.c:179:	stk_camera_read_reg(dev, 0x0117, &value_117);
media/usb/stkwebcam/stk-webcam.c:181:	stk_camera_write_reg(dev, 0x0116, 0x0000);
media/usb/stkwebcam/stk-webcam.c:182:	stk_camera_write_reg(dev, 0x0117, 0x0000);
media/usb/stkwebcam/stk-webcam.c:184:	stk_camera_read_reg(dev, 0x0100, &value);
media/usb/stkwebcam/stk-webcam.c:185:	stk_camera_write_reg(dev, 0x0100, value | 0x80);
media/usb/stkwebcam/stk-webcam.c:187:	stk_camera_write_reg(dev, 0x0116, value_116);
media/usb/stkwebcam/stk-webcam.c:188:	stk_camera_write_reg(dev, 0x0117, value_117);
media/usb/stkwebcam/stk-webcam.c:201:static int stk_stop_stream(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:206:		stk_camera_read_reg(dev, 0x0100, &value);
media/usb/stkwebcam/stk-webcam.c:207:		stk_camera_write_reg(dev, 0x0100, value & ~0x80);
media/usb/stkwebcam/stk-webcam.c:262:static int stk_initialise(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:272:		ret = stk_camera_write_reg(dev, rv->reg, rv->val);
media/usb/stkwebcam/stk-webcam.c:300:	struct stk_camera *dev;
media/usb/stkwebcam/stk-webcam.c:303:	dev = (struct stk_camera *) urb->context;
media/usb/stkwebcam/stk-webcam.c:415:static int stk_prepare_iso(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:487:static void stk_clean_iso(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:510:static int stk_setup_siobuf(struct stk_camera *dev, int index)
media/usb/stkwebcam/stk-webcam.c:529:static int stk_free_sio_buffers(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:561:static int stk_prepare_sio_buffers(struct stk_camera *dev, unsigned n_sbufs)
media/usb/stkwebcam/stk-webcam.c:580:static int stk_allocate_buffers(struct stk_camera *dev, unsigned n_sbufs)
media/usb/stkwebcam/stk-webcam.c:596:static void stk_free_buffers(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:607:	struct stk_camera *dev = video_drvdata(fp);
media/usb/stkwebcam/stk-webcam.c:616:		stk_camera_write_reg(dev, 0x0, 0x24);
media/usb/stkwebcam/stk-webcam.c:629:	struct stk_camera *dev = video_drvdata(fp);
media/usb/stkwebcam/stk-webcam.c:635:		stk_camera_write_reg(dev, 0x0, 0x49); /* turn off the LED */
media/usb/stkwebcam/stk-webcam.c:653:	struct stk_camera *dev = video_drvdata(fp);
media/usb/stkwebcam/stk-webcam.c:711:	struct stk_camera *dev = video_drvdata(fp);
media/usb/stkwebcam/stk-webcam.c:723:	struct stk_camera *dev = video_drvdata(fp);
media/usb/stkwebcam/stk-webcam.c:760:	struct stk_camera *dev = video_drvdata(fp);
media/usb/stkwebcam/stk-webcam.c:790:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:808:	strcpy(input->name, "Syntek USB Camera");
media/usb/stkwebcam/stk-webcam.c:809:	input->type = V4L2_INPUT_TYPE_CAMERA;
media/usb/stkwebcam/stk-webcam.c:827:	struct stk_camera *dev =
media/usb/stkwebcam/stk-webcam.c:828:		container_of(ctrl->handler, struct stk_camera, hdl);
media/usb/stkwebcam/stk-webcam.c:898:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:973:static int stk_setup_format(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:989:	stk_camera_write_reg(dev, 0x001b, 0x0e);
media/usb/stkwebcam/stk-webcam.c:991:		stk_camera_write_reg(dev, 0x001c, 0x0e);
media/usb/stkwebcam/stk-webcam.c:993:		stk_camera_write_reg(dev, 0x001c, 0x46);
media/usb/stkwebcam/stk-webcam.c:998:	stk_camera_write_reg(dev, 0x0115,
media/usb/stkwebcam/stk-webcam.c:1000:	stk_camera_write_reg(dev, 0x0114,
media/usb/stkwebcam/stk-webcam.c:1002:	stk_camera_write_reg(dev, 0x0117,
media/usb/stkwebcam/stk-webcam.c:1004:	stk_camera_write_reg(dev, 0x0116,
media/usb/stkwebcam/stk-webcam.c:1014:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1040:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1051:		stk_camera_write_reg(dev, 0x0, 0x49); /* turn off the LED */
media/usb/stkwebcam/stk-webcam.c:1073:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1086:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1110:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1143:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1155:	struct stk_camera *dev = video_drvdata(filp);
media/usb/stkwebcam/stk-webcam.c:1238:	struct stk_camera *dev = vdev_to_camera(vd);
media/usb/stkwebcam/stk-webcam.c:1254:static int stk_register_video_device(struct stk_camera *dev)
media/usb/stkwebcam/stk-webcam.c:1268:		STK_INFO("Syntek USB2.0 Camera is now controlling device %s\n",
media/usb/stkwebcam/stk-webcam.c:1276:static int stk_camera_probe(struct usb_interface *interface,
media/usb/stkwebcam/stk-webcam.c:1283:	struct stk_camera *dev = NULL;
media/usb/stkwebcam/stk-webcam.c:1288:	dev = kzalloc(sizeof(struct stk_camera), GFP_KERNEL);
media/usb/stkwebcam/stk-webcam.c:1380:static void stk_camera_disconnect(struct usb_interface *interface)
media/usb/stkwebcam/stk-webcam.c:1382:	struct stk_camera *dev = usb_get_intfdata(interface);
media/usb/stkwebcam/stk-webcam.c:1389:	STK_INFO("Syntek USB2.0 Camera release resources device %s\n",
media/usb/stkwebcam/stk-webcam.c:1398:static int stk_camera_suspend(struct usb_interface *intf, pm_message_t message)
media/usb/stkwebcam/stk-webcam.c:1400:	struct stk_camera *dev = usb_get_intfdata(intf);
media/usb/stkwebcam/stk-webcam.c:1409:static int stk_camera_resume(struct usb_interface *intf)
media/usb/stkwebcam/stk-webcam.c:1411:	struct stk_camera *dev = usb_get_intfdata(intf);
media/usb/stkwebcam/stk-webcam.c:1416:	stk_camera_write_reg(dev, 0x0, 0x49);
media/usb/stkwebcam/stk-webcam.c:1424:static struct usb_driver stk_camera_driver = {
media/usb/stkwebcam/stk-webcam.c:1426:	.probe = stk_camera_probe,
media/usb/stkwebcam/stk-webcam.c:1427:	.disconnect = stk_camera_disconnect,
media/usb/stkwebcam/stk-webcam.c:1430:	.suspend = stk_camera_suspend,
media/usb/stkwebcam/stk-webcam.c:1431:	.resume = stk_camera_resume,
media/usb/stkwebcam/stk-webcam.c:1435:module_usb_driver(stk_camera_driver);
media/usb/stkwebcam/stk-sensor.c:29: * The camera uses an OmniVision sensor and the stk1125 provides an
media/usb/stkwebcam/stk-sensor.c:228:static int stk_sensor_outb(struct stk_camera *dev, u8 reg, u8 val)
media/usb/stkwebcam/stk-sensor.c:233:	if (stk_camera_write_reg(dev, STK_IIC_TX_INDEX, reg))
media/usb/stkwebcam/stk-sensor.c:235:	if (stk_camera_write_reg(dev, STK_IIC_TX_VALUE, val))
media/usb/stkwebcam/stk-sensor.c:237:	if (stk_camera_write_reg(dev, STK_IIC_OP, STK_IIC_OP_TX))
media/usb/stkwebcam/stk-sensor.c:240:		if (stk_camera_read_reg(dev, STK_IIC_STAT, &tmpval))
media/usb/stkwebcam/stk-sensor.c:253:static int stk_sensor_inb(struct stk_camera *dev, u8 reg, u8 *val)
media/usb/stkwebcam/stk-sensor.c:258:	if (stk_camera_write_reg(dev, STK_IIC_RX_INDEX, reg))
media/usb/stkwebcam/stk-sensor.c:260:	if (stk_camera_write_reg(dev, STK_IIC_OP, STK_IIC_OP_RX))
media/usb/stkwebcam/stk-sensor.c:263:		if (stk_camera_read_reg(dev, STK_IIC_STAT, &tmpval))
media/usb/stkwebcam/stk-sensor.c:274:	if (stk_camera_read_reg(dev, STK_IIC_RX_VALUE, &tmpval))
media/usb/stkwebcam/stk-sensor.c:281:static int stk_sensor_write_regvals(struct stk_camera *dev,
media/usb/stkwebcam/stk-sensor.c:296:int stk_sensor_sleep(struct stk_camera *dev)
media/usb/stkwebcam/stk-sensor.c:303:int stk_sensor_wakeup(struct stk_camera *dev)
media/usb/stkwebcam/stk-sensor.c:365:int stk_sensor_init(struct stk_camera *dev)
media/usb/stkwebcam/stk-sensor.c:370:	if (stk_camera_write_reg(dev, STK_IIC_ENABLE, STK_IIC_ENABLE_YES)
media/usb/stkwebcam/stk-sensor.c:371:		|| stk_camera_write_reg(dev, STK_IIC_ADDR, SENSOR_ADDRESS)
media/usb/stkwebcam/stk-sensor.c:469: * Store a set of start/stop values into the camera.
media/usb/stkwebcam/stk-sensor.c:471:static int stk_sensor_set_hw(struct stk_camera *dev,
media/usb/stkwebcam/stk-sensor.c:500:int stk_sensor_configure(struct stk_camera *dev)
media/usb/stkwebcam/stk-sensor.c:587:int stk_sensor_set_brightness(struct stk_camera *dev, int br)
media/usb/s2255/s2255drv.c:329: *  =                         = B/W camera      = input     =
media/usb/s2255/s2255drv.c:338: * If COLORFILTER is 0 with a composite color camera connected,
media/usb/s2255/s2255drv.c:1372:	inp->type = V4L2_INPUT_TYPE_CAMERA;
battery/sec_adc.c:81:	case SEC_BAT_ADC_CHANNEL_CAMERA_TEMP:
battery/sec_adc.c:86:			pr_debug("CAMERA THM(%d)\n", data);
battery/sec_battery.c:102:	SEC_BATTERY_ATTR(camera),
battery/sec_battery.c:174:	SEC_BATTERY_ATTR(camera_temp_adc),
battery/sec_battery.c:175:	SEC_BATTERY_ATTR(camera_temp),
battery/sec_battery.c:176:	SEC_BATTERY_ATTR(camera_limit),
battery/sec_battery.c:1039:	case SEC_BAT_ADC_CHANNEL_CAMERA_TEMP:
battery/sec_battery.c:1040:		temp_adc_table = battery->pdata->camera_temp_adc_table;
battery/sec_battery.c:1042:			battery->pdata->camera_temp_adc_table_size;
battery/sec_battery.c:1043:		battery->camera_temp_adc = temp_adc;
battery/sec_battery.c:1323:static void sec_bat_camera_temp_check(struct sec_battery_info *battery)
battery/sec_battery.c:1327:				       SEC_BAT_ADC_CHANNEL_CAMERA_TEMP,
battery/sec_battery.c:1329:	battery->camera_temp = value.intval;
battery/sec_battery.c:1331:	if (battery->camera_temp >= battery->pdata->camera_temp_limit)
battery/sec_battery.c:1332:		battery->camera_limit = true;
battery/sec_battery.c:1334:	pr_info("%s : CAMERA_TEMP(%d) CAMERA_TEMP_ADC(%d) || CAMERA_LIMIT(%d)\n",
battery/sec_battery.c:1335:		__func__, battery->camera_temp, battery->camera_temp_adc,
battery/sec_battery.c:1336:		battery->camera_limit);
battery/sec_battery.c:1389:		   (battery->pdata->camera_temp_check && battery->camera_limit)) {
battery/sec_battery.c:1417:		   (!battery->pdata->camera_temp_check ||
battery/sec_battery.c:1418:		    (battery->pdata->camera_temp_check && !battery->camera_limit))) {
battery/sec_battery.c:3226:	if (battery->pdata->camera_temp_check)
battery/sec_battery.c:3227:		sec_bat_camera_temp_check(battery);
battery/sec_battery.c:3890:	case BATT_EVENT_CAMERA:
battery/sec_battery.c:3892:			(battery->event & EVENT_CAMERA) ? 1 : 0);
battery/sec_battery.c:4264:	case CAMERA_TEMP_ADC:
battery/sec_battery.c:4265:		if (battery->pdata->camera_temp_check) {
battery/sec_battery.c:4266:			sec_bat_camera_temp_check(battery);
battery/sec_battery.c:4268:				       battery->camera_temp_adc);
battery/sec_battery.c:4271:	case CAMERA_TEMP:
battery/sec_battery.c:4272:		if (battery->pdata->camera_temp_check) {
battery/sec_battery.c:4273:			sec_bat_camera_temp_check(battery);
battery/sec_battery.c:4275:				       battery->camera_temp);
battery/sec_battery.c:4278:	case CAMERA_LIMIT:
battery/sec_battery.c:4280:			       battery->camera_limit);
battery/sec_battery.c:4720:	case BATT_EVENT_CAMERA:
battery/sec_battery.c:4722:			sec_bat_event_set(battery, EVENT_CAMERA, x);
battery/sec_battery.c:5356:	case CAMERA_TEMP_ADC:
battery/sec_battery.c:5358:	case CAMERA_TEMP:
battery/sec_battery.c:5360:	case CAMERA_LIMIT:
battery/sec_battery.c:5735:	    (battery->pdata->camera_temp_check && battery->camera_limit)){
battery/sec_battery.c:5770:	    (battery->pdata->camera_temp_check && battery->camera_limit)){
battery/sec_battery.c:5823:	if (battery->pdata->camera_temp_check && battery->camera_limit) {
battery/sec_battery.c:6480:	pdata->camera_temp_check = of_property_read_bool(np,
battery/sec_battery.c:6481:							 "battery,camera_temp_check");
battery/sec_battery.c:6483:	if (pdata->camera_temp_check) {
battery/sec_battery.c:6484:		p = of_get_property(np, "battery,camera_temp_table_adc", &len);
battery/sec_battery.c:6490:		pdata->camera_temp_adc_table_size = len;
battery/sec_battery.c:6492:		pdata->camera_temp_adc_table =
battery/sec_battery.c:6494:				pdata->camera_temp_adc_table_size, GFP_KERNEL);
battery/sec_battery.c:6496:		for(i = 0; i < pdata->camera_temp_adc_table_size; i++) {
battery/sec_battery.c:6498:							 "battery,camera_temp_table_adc", i, &temp);
battery/sec_battery.c:6499:			pdata->camera_temp_adc_table[i].adc = (int)temp;
battery/sec_battery.c:6501:				pr_info("%s : CAMERA_Temp_adc_table(adc) is Empty\n",
battery/sec_battery.c:6505:							 "battery,camera_temp_table_data", i, &temp);
battery/sec_battery.c:6506:			pdata->camera_temp_adc_table[i].data = (int)temp;
battery/sec_battery.c:6508:				pr_info("%s : CAMERA_Temp_adc_table(data) is Empty\n",
battery/sec_battery.c:6512:		ret = of_property_read_u32(np, "battery,camera_temp_limit",
battery/sec_battery.c:6513:					   &pdata->camera_temp_limit);
battery/sec_battery.c:6515:			pr_info("%s : camera_temp_limit is Empty\n", __func__);
battery/sec_battery.c:7264:	battery->camera_limit = false;
gpu/drm/omapdrm/omap_gem_dmabuf.c:37:	/* camera, etc, need physically contiguous.. but we need a
gpu/drm/exynos/exynos_drm_fimc.c:29: * FIMC stands for Fully Interactive Mobile Camera and
gpu/drm/exynos/exynos_drm_fimc.c:215:	return regmap_update_bits(ctx->sysreg, SYSREG_CAMERA_BLK,
sensorhub/stm/ssp_dev.c:83:	data->cameraGyroSyncMode = false;
sensorhub/stm/ssp_iio.c:120:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm/ssp_data.c:95:		// CAMERA SYNC MODE
sensorhub/stm/ssp_data.c:96:		if (data->cameraGyroSyncMode && sensor == GYROSCOPE_SENSOR) {
sensorhub/stm/ssp_data.c:637:				if (data->cameraGyroSyncMode) {
sensorhub/stm/ssp_spi.c:315:		if (data->cameraGyroSyncMode && uSensorType == GYROSCOPE_SENSOR) {
sensorhub/stm/ssp_spi.c:394:		if (data->cameraGyroSyncMode && uSensorType == GYROSCOPE_SENSOR) {
sensorhub/stm/ssp_sysfs.c:71:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm/ssp_sysfs.c:132:	// SUPPORT CAMERA SYNC ++++++
sensorhub/stm/ssp_sysfs.c:134:		if (delay == CAMERA_GYROSCOPE_SYNC) {
sensorhub/stm/ssp_sysfs.c:135:			delay = CAMERA_GYROSCOPE_SYNC_DELAY;
sensorhub/stm/ssp_sysfs.c:137:			data->cameraGyroSyncMode = true;
sensorhub/stm/ssp_sysfs.c:139:			data->cameraGyroSyncMode = false;
sensorhub/stm/ssp_sysfs.c:142:	// SUPPORT CAMERA SYNC -----
sensorhub/stm/ssp_sysfs.c:336:				// SUPPORT CAMERA SYNC ++++++
sensorhub/stm/ssp_sysfs.c:338:					if (data->adDelayBuf[changed_sensor] == CAMERA_GYROSCOPE_SYNC) {
sensorhub/stm/ssp_sysfs.c:339:						data->adDelayBuf[changed_sensor] = CAMERA_GYROSCOPE_SYNC_DELAY;
sensorhub/stm/ssp_sysfs.c:340:						data->cameraGyroSyncMode = true;
sensorhub/stm/ssp_sysfs.c:342:						data->cameraGyroSyncMode = false;
sensorhub/stm/ssp_sysfs.c:354:				// SUPPORT CAMERA SYNC -----
sensorhub/stm/ssp_sysfs.c:653:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm/ssp_sysfs.c:971:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm/ssp_sysfs.c:1029:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_data.c:149:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_data.c:775:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_data.c:808:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_spi.c:36:/* in camera driver file*/
sensorhub/brcm_legacy/ssp_sysfs.c:71:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_sysfs.c:746:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_sysfs.c:988:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_sysfs.c:1152:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_sysfs.c:1226:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_sysfs.c:1247:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:470:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:665:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:719:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:736:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:1161:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:1438:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm_legacy/ssp_input.c:1561:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/atmel/ssp_spi.c:36:/* in camera driver file*/
sensorhub/stm_legacy/ssp_iio.c:120:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm_legacy/ssp_sysfs.c:70:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm_legacy/ssp_sysfs.c:622:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm_legacy/ssp_sysfs.c:804:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/stm_legacy/ssp_sysfs.c:851:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_dev.c:92:	data->cameraGyroSyncMode = false;
sensorhub/brcm/ssp_data.c:113:		// CAMERA SYNC MODE
sensorhub/brcm/ssp_data.c:114:		if (data->cameraGyroSyncMode && sensor_type == GYROSCOPE_SENSOR) {
sensorhub/brcm/ssp_data.c:258:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_data.c:848:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_data.c:882:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_i2c.c:235:		if (data->cameraGyroSyncMode && uSensorType == GYROSCOPE_SENSOR) {
sensorhub/brcm/ssp_i2c.c:314:		if (data->cameraGyroSyncMode && uSensorType == GYROSCOPE_SENSOR) {
sensorhub/brcm/ssp_spi.c:36:/* in camera driver file*/
sensorhub/brcm/ssp_sysfs.c:71:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_sysfs.c:143:	// SUPPORT CAMERA SYNC ++++++
sensorhub/brcm/ssp_sysfs.c:145:		if (dNewDelay == CAMERA_GYROSCOPE_SYNC) {
sensorhub/brcm/ssp_sysfs.c:146:			dNewDelay = CAMERA_GYROSCOPE_SYNC_DELAY;
sensorhub/brcm/ssp_sysfs.c:148:			data->cameraGyroSyncMode = true;
sensorhub/brcm/ssp_sysfs.c:150:			data->cameraGyroSyncMode = false;
sensorhub/brcm/ssp_sysfs.c:153:	// SUPPORT CAMERA SYNC -----
sensorhub/brcm/ssp_sysfs.c:342:				// SUPPORT CAMERA SYNC ++++++
sensorhub/brcm/ssp_sysfs.c:344:					if (data->adDelayBuf[uChangedSensor] == CAMERA_GYROSCOPE_SYNC) {
sensorhub/brcm/ssp_sysfs.c:345:						data->adDelayBuf[uChangedSensor] = CAMERA_GYROSCOPE_SYNC_DELAY;
sensorhub/brcm/ssp_sysfs.c:346:						data->cameraGyroSyncMode = true;
sensorhub/brcm/ssp_sysfs.c:348:						data->cameraGyroSyncMode = false;
sensorhub/brcm/ssp_sysfs.c:360:				// SUPPORT CAMERA SYNC -----
sensorhub/brcm/ssp_sysfs.c:769:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_sysfs.c:1035:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_sysfs.c:1200:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_sysfs.c:1274:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_sysfs.c:1295:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:470:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:682:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:736:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:753:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:1192:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:1506:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
sensorhub/brcm/ssp_input.c:1629:#ifdef CONFIG_SENSORS_SSP_IRDATA_FOR_CAMERA
leds/leds-lp3944.c:26: * leds, the camera flash light and the displays backlights.
leds/trigger/ledtrig-camera.c:2: * Camera Flash and Torch On/Off Trigger
leds/trigger/ledtrig-camera.c:40:static int __init ledtrig_camera_init(void)
leds/trigger/ledtrig-camera.c:46:module_init(ledtrig_camera_init);
leds/trigger/ledtrig-camera.c:48:static void __exit ledtrig_camera_exit(void)
leds/trigger/ledtrig-camera.c:53:module_exit(ledtrig_camera_exit);
leds/trigger/ledtrig-camera.c:55:MODULE_DESCRIPTION("LED Trigger for Camera Flash/Torch Control");
leds/leds-s2mpb02.c:26:extern struct class *camera_class; /*sys/class/camera*/
leds/leds-s2mpb02.c:505:	s2mpb02_led_dev = device_create(camera_class, NULL, 3, NULL, "flash");
leds/leds-s2mpb02.c:550:	if (camera_class && s2mpb02_led_dev) {
leds/leds-s2mpb02.c:551:		device_destroy(camera_class, s2mpb02_led_dev->devt);
leds/leds-ktd2692.c:25:extern struct class *camera_class; /*sys/class/camera*/
leds/leds-ktd2692.c:250:	ktd2692_dev = device_create(camera_class, NULL, 0, NULL, "flash");
leds/leds-ktd2692.c:266:	device_destroy(camera_class, 0);
leds/leds-ktd2692.c:267:	class_destroy(camera_class);
dma/ipu/ipu_idmac.c:115:/* Enable direct write to memory by the Camera Sensor Interface */
staging/media/davinci_vpfe/vpfe_mc_capture.c:82: * and for capture raw bayer data from camera sensors such as mt9p031. At this
staging/media/davinci_vpfe/vpfe_mc_capture.c:85: * capture or camera capture.
staging/media/davinci_vpfe/vpfe_mc_capture.c:87: * interface = 1 - Camera capture (from mt9p031 or such)
staging/media/davinci_vpfe/vpfe_mc_capture.c:367:		if (interface == sdinfo->is_camera) {
staging/media/go7007/go7007-usb.c:302:				.name		= "Camera",
staging/media/go7007/go7007-usb.c:390:				.name		= "Camera",
staging/media/go7007/go7007-v4l2.c:710:		inp->type = V4L2_INPUT_TYPE_CAMERA;
staging/media/solo6x10/solo6x10-v4l2-enc.c:759:	input->type = V4L2_INPUT_TYPE_CAMERA;
staging/media/solo6x10/solo6x10-g723.c:342:		sprintf(ss->name, "Camera #%d Audio", i);
staging/media/solo6x10/solo6x10-v4l2.c:421:		snprintf(input->name, sizeof(input->name), "Camera %d",
staging/media/solo6x10/solo6x10-v4l2.c:429:	input->type = V4L2_INPUT_TYPE_CAMERA;
staging/media/dt3155v4l/dt3155v4l.c:631:	input->type = V4L2_INPUT_TYPE_CAMERA;
pinctrl/mvebu/pinctrl-dove.c:96:	case 24: /* mpp_camera */
pinctrl/mvebu/pinctrl-dove.c:127:	case 24: /* mpp_camera */
pinctrl/mvebu/pinctrl-dove.c:364:	MPP_FUNC_CTRL(24, 39, "mpp_camera", dove_mpp4_ctrl),
pinctrl/mvebu/pinctrl-dove.c:528:		MPP_FUNCTION(0x00, "camera", NULL),
parport/probe.c:29:	{ "DIGICAM",     "Digital camera" },
bts/bts-exynos7420.c:252:/*	 DISPLAY     VPP         CAMERA      BRB         BRB_VPP     NSP         NSP_VPP     NSP_SPDMA  */
video/tmiofb.c:139:#define LCR_CCIFC		0x024 /* CMOS Camera IF Control		*/
video/tmiofb.c:169:#define LCR_VCCIS		0x17e /* Video / CMOS Camera Interface Select */
video/tmiofb.c:177:#define LCR_VCS			0x18e /* Video/Camera Select		*/
video/exynos/decon/decon_mdnie.c:34:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon/panels/mdnie_lite.c:25:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_dual_display/decon_mdnie.c:34:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_dual_display/panels/mdnie_lite.c:45:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_dual_dsi/decon_mdnie.c:34:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_dual_dsi/panels/mdnie_lite.c:47:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_royce/decon_mdnie.c:34:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_royce/panels/mdnie_lite.c:51:#define IS_SCENARIO(idx)		((idx < SCENARIO_MAX) && !((idx > VIDEO_NORMAL_MODE) && (idx < CAMERA_MODE)))
video/exynos/decon_display/decon_pm_core.c:402:		if (!check_camera_is_running()) {
video/exynos/decon_display/decon_pm_exynos5430.c:517:bool check_camera_is_running(void)
video/via/via-core.c:35: * The OLPC XO-1.5 puts the camera power and reset lines onto
video/via/via-core.c:114: * Currently, the camera driver is the only user of the DMA code, so we
video/via/via-core.c:115: * only compile it in if the camera driver is being built.  Chances are,
video/via/via-core.c:119:#if defined(CONFIG_VIDEO_VIA_CAMERA) || defined(CONFIG_VIDEO_VIA_CAMERA_MODULE)
video/via/via-core.c:121: * Access to the DMA engine.  This currently provides what the camera
video/via/via-core.c:348:#endif /* CONFIG_VIDEO_VIA_CAMERA */
video/via/via-core.c:545:#if defined(CONFIG_VIDEO_VIA_CAMERA) || defined(CONFIG_VIDEO_VIA_CAMERA_MODULE)
video/via/via-core.c:547:		.name = "viafb-camera",
video/via/accel.c:361:#if defined(CONFIG_VIDEO_VIA_CAMERA) || defined(CONFIG_VIDEO_VIA_CAMERA_MODULE)
video/via/accel.c:363:	 * Set aside a chunk of framebuffer memory for the camera
video/via/accel.c:371:	viapar->shared->vdev->camera_fbmem_size = 3*VGA_HEIGHT*VGA_WIDTH*2;
video/via/accel.c:372:	viapar->fbmem_free -= viapar->shared->vdev->camera_fbmem_size;
video/via/accel.c:373:	viapar->fbmem_used += viapar->shared->vdev->camera_fbmem_size;
video/via/accel.c:374:	viapar->shared->vdev->camera_fbmem_offset = viapar->fbmem_free;
video/decon_display/fimd_pm_exynos.c:374:bool check_camera_is_running(void)
video/decon_display/decon_pm_core.c:442:		if (!check_camera_is_running()) {
video/decon_display/decon_pm_exynos5430.c:490:bool check_camera_is_running(void)
usb/core/quirks.c:68:	/* Logitech Quickcam OEM Cisco VT Camera II */
usb/core/quirks.c:165:	/* Logitech UVC Cameras */
usb/image/mdc800.c:21: *	USB-Kernel Driver for the Mustek MDC800 Digital Camera
usb/image/mdc800.c:26: * To use the Camera you must support the USB Protocol of the camera
usb/image/mdc800.c:31: * The driver supports only one camera.
usb/image/mdc800.c:55: * driver running like the camera is connected and causes some
usb/image/mdc800.c:108:#define DRIVER_DESC "USB Driver for Mustek MDC800 Digital Camera"
usb/image/mdc800.c:149:	int			camera_busy;          // is camera busy ?
usb/image/mdc800.c:150:	int 			camera_request_ready; // Status to synchronize with irq
usb/image/mdc800.c:151:	char 			camera_response [8];  // last Bytes send after busy
usb/image/mdc800.c:171:	int			open;		// Camera device open ?
usb/image/mdc800.c:247: * Checks whether the camera responds busy
usb/image/mdc800.c:263: * Checks whether the Camera is ready
usb/image/mdc800.c:293:			if (!mdc800->camera_busy)
usb/image/mdc800.c:295:				mdc800->camera_busy=1;
usb/image/mdc800.c:301:			if (mdc800->camera_busy && mdc800_isReady (b))
usb/image/mdc800.c:303:				mdc800->camera_busy=0;
usb/image/mdc800.c:309:			/* Store Data in camera_answer field */
usb/image/mdc800.c:312:			memcpy (mdc800->camera_response,b,8);
usb/image/mdc800.c:316:	wake_up= ( mdc800->camera_request_ready > 0 )
usb/image/mdc800.c:319:			((mdc800->camera_request_ready == 1) && (!mdc800->camera_busy))
usb/image/mdc800.c:321:			((mdc800->camera_request_ready == 2) && data_received)
usb/image/mdc800.c:323:			((mdc800->camera_request_ready == 3) && (mdc800->camera_busy))
usb/image/mdc800.c:330:		mdc800->camera_request_ready=0;
usb/image/mdc800.c:338: * Waits a while until the irq responds that camera is ready
usb/image/mdc800.c:340: *  mode : 0: Wait for camera gets ready
usb/image/mdc800.c:342: *         2: Wait for camera gets busy
usb/image/mdc800.c:348:	mdc800->camera_request_ready=1+mode;
usb/image/mdc800.c:353:	if (mdc800->camera_request_ready>0)
usb/image/mdc800.c:355:		mdc800->camera_request_ready=0;
usb/image/mdc800.c:356:		dev_err(&mdc800->dev->dev, "timeout waiting for camera.\n");
usb/image/mdc800.c:362:		printk(KERN_WARNING "mdc800: Camera gets disconnected "
usb/image/mdc800.c:364:		mdc800->camera_request_ready=0;
usb/image/mdc800.c:418:	Probing for the Camera
usb/image/mdc800.c:643:	mdc800->camera_busy=0;
usb/image/mdc800.c:644:	mdc800->camera_request_ready=0;
usb/image/mdc800.c:666: * Close the Camera and release Memory
usb/image/mdc800.c:787: * If a 8Byte Command is received, it will be send to the camera.
usb/image/mdc800.c:789: * just waits until the camera becomes ready.
usb/image/mdc800.c:844:		/* Command Buffer full ? -> send it to camera */
usb/image/mdc800.c:852:					"Camera didn't get ready.\n");
usb/image/mdc800.c:914:						memcpy (mdc800->out, mdc800->camera_response,8);
usb/image/mdc800.c:917:						memcpy (&mdc800->out[8], mdc800->camera_response,8);
usb/image/mdc800.c:925:							mdc800->pic_len=(int) 65536*(unsigned char) mdc800->camera_response[0]+256*(unsigned char) mdc800->camera_response[1]+(unsigned char) mdc800->camera_response[2];
usb/misc/isight_firmware.c:10: * The USB isight cameras in recent Apples are roughly compatible with the USB
usb/storage/scsiglue.c:153:		 * and digital cameras.  Since these devices always use
usb/gadget/webcam.c:96:static const struct uvc_camera_terminal_descriptor uvc_camera_terminal = {
usb/gadget/webcam.c:97:	.bLength		= UVC_DT_CAMERA_TERMINAL_SIZE(3),
usb/gadget/webcam.c:272:	(const struct uvc_descriptor_header *) &uvc_camera_terminal,
usb/gadget/webcam.c:280:	(const struct uvc_descriptor_header *) &uvc_camera_terminal,
usb/gadget/f_uvc.c:58:	[UVC_STRING_CONTROL_IDX].s = "UVC Camera",
